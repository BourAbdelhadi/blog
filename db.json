{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/again/source/js/app.js","path":"js/app.js","modified":1},{"_id":"themes/again/source/images/banner-small.png","path":"images/banner-small.png","modified":1},{"_id":"themes/again/source/images/banner-large.png","path":"images/banner-large.png","modified":1},{"_id":"themes/again/source/images/avatar.png","path":"images/avatar.png","modified":1},{"_id":"themes/again/source/favicon.ico","path":"favicon.ico","modified":1},{"_id":"themes/again/source/css/app.scss","path":"css/app.scss","modified":1}],"Cache":[{"_id":"source/_posts/How-Medium-Load-Images/inspect.png","shasum":"1a97326447787e0323820c9a0b25cbcebd2ab9a5","modified":1456830269396},{"_id":"source/_posts/How-Medium-Load-Images/network.png","shasum":"a18d03e816c5b414923510f5887890b899cf4e60","modified":1456838143507},{"_id":"source/_posts/How-Medium-Load-Images.md","shasum":"69318f9d73a11b46738afedddf8cd93adf58bbc5","modified":1456839556445},{"_id":"source/_posts/BFC-in-CSS-0-WTF.md","shasum":"cfce731583bda74090ca0d811a3d1bee2ede5309","modified":1453875998744},{"_id":"source/_posts/JavaScript-For-Kids-This.md","shasum":"a2b53fce976fdb9df4643123d8204c2b9468cf93","modified":1456338675599},{"_id":"source/_posts/JavaScript-Module-A-Beginner-Guide.md","shasum":"4dff791e604b29c16c6c40ac1967eba70bb122c2","modified":1454919196021},{"_id":"source/_posts/ES6-In-Practice-0-watch-a-demo.md","shasum":"feadd9b2114d38e92e88501fd3837e6295ec8dcb","modified":1453876010793},{"_id":"source/_posts/5-Ways-to-Make-a-Sticky-Footer.md","shasum":"55234c57739b4c0b6ebe704aefdc41e60505703b","modified":1453879256285},{"_id":"source/_posts/Scope-0-What-Is-Scope.md","shasum":"0dfe8837884a060f1a72406ef4a2e15ef2847f1d","modified":1453875987662},{"_id":"source/_posts/Scope-2-Lexical-Scope-Dynamical-Scope.md","shasum":"3acd118097d91d9696cbbb9aa10076f7d5112b65","modified":1453876076572},{"_id":"source/_posts/Scope-1-Nested-Scope.md","shasum":"16b875e100911f9b19b5aa827beb22ee88b1af30","modified":1453876029049},{"_id":"source/_posts/Virtual-DOM/vdom0.png","shasum":"e68599840c52b920be8e0d792284d8f326636ed2","modified":1454224113689},{"_id":"source/_posts/Virtual-DOM/vdom1.png","shasum":"7e900ff6a710a45c99c704cda30e665f19694ac2","modified":1454224377334},{"_id":"source/_posts/Virtual-DOM/vdom2.png","shasum":"ab790847d320a49315483d1272b79de066176c5d","modified":1454225261160},{"_id":"source/_posts/Promise.md","shasum":"ee09b5bff6e94fb737fb5d49cc0438e9b77606f0","modified":1454763516959},{"_id":"source/_posts/Scope-3-What-Is-Closure.md","shasum":"d51dd7bc6a54002302dd23bee3d3d092e60bdb13","modified":1453876040969},{"_id":"source/_posts/Virtual-DOM.md","shasum":"1460912403a98f4bbe1c59276f149bf72da491fc","modified":1454763594509},{"_id":"source/_posts/为你的JavaScript代码写测试/0.png","shasum":"cff3e867fa4f604612fbc072c84315dfe6ba1397","modified":1455717406770},{"_id":"source/_posts/gulp-in-practice.md","shasum":"a991886aeb5831ee13f76dac788603862751d0e5","modified":1453875764542},{"_id":"source/_posts/google-chrome-Devtools-Overview.md","shasum":"644e2b03fa6cd0d29e6bb9260e1794600a5ee1f9","modified":1453876015685},{"_id":"source/_posts/从零开始编写一个Hexo主题/hexo.png","shasum":"c2a8a470c1111865e6efaee878695e84ce62965c","modified":1453912778344},{"_id":"source/_posts/从零开始编写一个Hexo主题/hexo1.png","shasum":"b80330c96520a4f6dddc4a445eeea258c4741d0b","modified":1453912422994},{"_id":"source/_posts/从零开始编写一个Hexo主题/hexo2.png","shasum":"c7dbf46e9b5c991f9d08cf098869ef630d7ab025","modified":1453912979050},{"_id":"source/_posts/实现一个简单的AMD模块加载器.md","shasum":"911aec81e2ae99c2fe588ecbf3da4a12dab433f7","modified":1455211113424},{"_id":"source/_posts/从零开始编写一个Hexo主题.md","shasum":"009f5f049cd2d8b814317518fe946b5b281444b9","modified":1453914004396},{"_id":"source/about/index.md","shasum":"4612cea4f98c9ac07adbb9959f96c81c67891d03","modified":1453883304850},{"_id":"themes/again/README.md","shasum":"c1d90898bf21e885033d090bc23002f2e9631544","modified":1454174021530},{"_id":"themes/again/_config.yml","shasum":"ca87d86914259540c742f254243a40fde9e54938","modified":1456743924178},{"_id":"themes/again/layout/_partial/article.ejs","shasum":"4fb49c13a5d056885ab7f8fd8afee8ac718aa8ec","modified":1453807312265},{"_id":"themes/again/layout/_partial/archive.ejs","shasum":"9b487c55e1e116d6af69fd4075ed223acb379d16","modified":1453827308801},{"_id":"themes/again/layout/_partial/footer.ejs","shasum":"77df042cad1427d78ff857eec80cde3698b3c374","modified":1453883364639},{"_id":"themes/again/layout/_partial/head.ejs","shasum":"14e4e081426c5f39c3c62c6251fa86231c19b70f","modified":1456752577794},{"_id":"source/_posts/为你的JavaScript代码写测试.md","shasum":"7dc4c1baa6287a2ad2cfba1dc4c2dc1144fdd824","modified":1455730190709},{"_id":"themes/again/layout/_partial/index.ejs","shasum":"3758d4a85316b9454dd15b42e99488de07d4ccc3","modified":1453826851384},{"_id":"themes/again/layout/_widget/back-to-home.ejs","shasum":"fce1d7e5d0e756bfb9f85eb8750ea4c501346834","modified":1453785521406},{"_id":"themes/again/layout/_partial/nav.ejs","shasum":"a65731d63e74c1ff535f2cf223d3b6b841898c35","modified":1455204431583},{"_id":"themes/again/layout/_widget/disqus.ejs","shasum":"d0dcef6da1b180ff0956fd05ab7bdfdfa4bc9a26","modified":1453787151470},{"_id":"themes/again/layout/_widget/paginator.ejs","shasum":"00cb3b763b0a16275b31b3c529940e54911438c5","modified":1453826030720},{"_id":"themes/again/layout/_widget/twitter.ejs","shasum":"b5b550e641e6fa19c2c9aafc297fae09e131aa82","modified":1453791217508},{"_id":"themes/again/layout/_widget/sharing.ejs","shasum":"f9b4023e3f592ca9328be38f3bbef62e765bf699","modified":1453873616973},{"_id":"themes/again/layout/archive.ejs","shasum":"eede5af91dd42b43b52c8c731b6d0c2ccd650c7f","modified":1453826406850},{"_id":"themes/again/layout/layout.ejs","shasum":"bdc8b3401957fd6cc5f755a82ac37a3636793197","modified":1456751494315},{"_id":"themes/again/layout/index.ejs","shasum":"01a7ca2dab0957bfe07e9af2e4206adb6b27b73d","modified":1456751498530},{"_id":"themes/again/layout/page.ejs","shasum":"674479bce322a062668a2ccff8dffee7e5f38728","modified":1453805815000},{"_id":"themes/again/source/css/_base.scss","shasum":"3409e6b18b97de3705edb0d8f18579f7c43f0648","modified":1456752815122},{"_id":"themes/again/source/css/_font.scss","shasum":"2dc5501dd168c2c11e6ea78d7fab764c8f50697d","modified":1456752817297},{"_id":"themes/again/source/css/_helper/grid.scss","shasum":"7d7a8197de56b03acd4cf92d6c75a8973508f7e6","modified":1453782666526},{"_id":"themes/again/source/css/_helper/index.scss","shasum":"d0d8d144f7323fee4924583ec0f0104abfffb752","modified":1453781781934},{"_id":"themes/again/source/css/_partial/archive.scss","shasum":"30b4d07563a2c65e8762449c04defc6d1b0b82df","modified":1453834325113},{"_id":"themes/again/source/css/_partial/article.scss","shasum":"5d620df86592f7ff822af242a7e07a11edecc6a6","modified":1453833825687},{"_id":"themes/again/source/css/_partial/footer.scss","shasum":"5e6af6777b05040924494671fab7a1b4b48144a7","modified":1453830164232},{"_id":"themes/again/source/css/_partial/header.scss","shasum":"4867af6175ab8e59d5068a52eeb575013c405fcd","modified":1456749384084},{"_id":"themes/again/source/css/_partial/index.scss","shasum":"b893ad25ed5c9bed3a8bc473320275bbb20be457","modified":1453876392950},{"_id":"themes/again/source/css/_partial/nav.scss","shasum":"ccf6978722a23d8cb6d5f4b3626d98f3f46e2f2e","modified":1455202834390},{"_id":"themes/again/source/css/_partial/page.scss","shasum":"fee0df45bb99641f619b74cd6a8e61af53b7140e","modified":1453829913789},{"_id":"themes/again/source/css/_partial/partials.scss","shasum":"9f4d33c8bb1da9310f719bed613a2a876a203bb3","modified":1453826960821},{"_id":"themes/again/source/css/_widget/back-to-home.scss","shasum":"93e787f0886a6e2cced153e2b7f967f4fcd4973b","modified":1453785450248},{"_id":"themes/again/source/css/_variables.scss","shasum":"7cc298489fe62aa4515276025210ec0ff238bae8","modified":1456752751848},{"_id":"themes/again/source/css/_widget/highlight.scss","shasum":"0d753fb36f8636478624ed85545176822a762257","modified":1455210863098},{"_id":"themes/again/source/css/_widget/index.scss","shasum":"4bb796898dc77b75cd8aeefe42d4c6fe2ff64696","modified":1453807467642},{"_id":"themes/again/source/css/_widget/sharing.scss","shasum":"e9c95d23c8eb6c250a77b9b3fa6d1eeb6997ec80","modified":1453877112849},{"_id":"themes/again/source/css/app.scss","shasum":"f0966d1a5fe93bc566b83e60882db3cba0e534e6","modified":1456752865354},{"_id":"themes/again/source/favicon.ico","shasum":"47f8c468756506ff0c9a1df1dcbc48c1ae54c81d","modified":1456742178122},{"_id":"themes/again/layout/post.ejs","shasum":"39706b2e1f1639344f2ddbbe1373cc0b12a8e98f","modified":1453883227494},{"_id":"themes/again/source/images/avatar.png","shasum":"60d81ac876c5c4aa0e92dbed5abcdbed357c2bf4","modified":1456741906137},{"_id":"themes/again/source/js/app.js","shasum":"c67676c1d631261682dc34ca572c3f68d47e2bd3","modified":1456750468477},{"_id":"themes/again/source/images/banner-small.png","shasum":"4b87b439bbf9507f7bed53d7c2c1a22e07a064e8","modified":1456741808488},{"_id":"themes/again/layout/_partial/header.ejs","shasum":"603fdf31f0a438c0619199b0fa955209de458905","modified":1456749195754},{"_id":"source/_posts/JavaScript-Modules-Part-2.md","shasum":"5346f5f40376f195f241fb150d769ed2680d80e1","modified":1454919143919},{"_id":"themes/again/source/images/banner-large.png","shasum":"3e91a135ca4c446301995aedc998784e035d485a","modified":1456741795034},{"_id":"public/js/app.js","modified":1456839604245,"shasum":"8e00097211a064209ae0e9fb556920673f5b9a42"},{"_id":"public/images/banner-small.png","modified":1456839604261,"shasum":"4b87b439bbf9507f7bed53d7c2c1a22e07a064e8"},{"_id":"public/images/banner-large.png","modified":1456839604268,"shasum":"3e91a135ca4c446301995aedc998784e035d485a"},{"_id":"public/images/avatar.png","modified":1456839604273,"shasum":"60d81ac876c5c4aa0e92dbed5abcdbed357c2bf4"},{"_id":"public/favicon.ico","modified":1456839604285,"shasum":"47f8c468756506ff0c9a1df1dcbc48c1ae54c81d"},{"_id":"public/css/app.css","modified":1456839604304,"shasum":"564c09d3982bfe03aecc12e73821c1cf3bd4e5dc"},{"_id":"public/2016/01/27/从零开始编写一个Hexo主题/hexo.png","modified":1456839604321,"shasum":"c2a8a470c1111865e6efaee878695e84ce62965c"},{"_id":"public/2016/01/27/从零开始编写一个Hexo主题/hexo1.png","modified":1456839604330,"shasum":"b80330c96520a4f6dddc4a445eeea258c4741d0b"},{"_id":"public/2016/01/27/从零开始编写一个Hexo主题/hexo2.png","modified":1456839604333,"shasum":"c7dbf46e9b5c991f9d08cf098869ef630d7ab025"},{"_id":"public/2016/02/17/为你的JavaScript代码写测试/0.png","modified":1456839604337,"shasum":"cff3e867fa4f604612fbc072c84315dfe6ba1397"},{"_id":"public/2016/01/31/Virtual-DOM/vdom0.png","modified":1456839604346,"shasum":"e68599840c52b920be8e0d792284d8f326636ed2"},{"_id":"public/2016/01/31/Virtual-DOM/vdom1.png","modified":1456839604352,"shasum":"7e900ff6a710a45c99c704cda30e665f19694ac2"},{"_id":"public/2016/01/31/Virtual-DOM/vdom2.png","modified":1456839604358,"shasum":"ab790847d320a49315483d1272b79de066176c5d"},{"_id":"public/2016/03/01/How-Medium-Load-Images/inspect.png","modified":1456839604366,"shasum":"1a97326447787e0323820c9a0b25cbcebd2ab9a5"},{"_id":"public/2016/03/01/How-Medium-Load-Images/network.png","modified":1456839604375,"shasum":"a18d03e816c5b414923510f5887890b899cf4e60"},{"_id":"public/about/index.html","modified":1456839604399,"shasum":"f9338bfd225afa8bb619c3b21d53a00808ffe9d3"},{"_id":"public/2016/03/01/How-Medium-Load-Images/index.html","modified":1456839604418,"shasum":"690485196f32b0182d621d7da6ecd39a8c9a21bb"},{"_id":"public/2016/02/17/为你的JavaScript代码写测试/index.html","modified":1456839604436,"shasum":"1fee14254f77392b226e568f5cc6d56f97aa5cf3"},{"_id":"public/2016/02/11/实现一个简单的AMD模块加载器/index.html","modified":1456839604460,"shasum":"17389d7236d743ebfddfcc9bceaeeb328f759bc0"},{"_id":"public/2016/02/08/JavaScript-Modules-Part-2/index.html","modified":1456839604475,"shasum":"9c681066ddcd22bdb8276c2d5d70d7d05bb2a2e6"},{"_id":"public/2016/02/07/JavaScript-Module-A-Beginner-Guide/index.html","modified":1456839604497,"shasum":"e63096ec0cdfe642936e45fb1eb530766881f5f6"},{"_id":"public/2016/02/06/Promise/index.html","modified":1456839604512,"shasum":"544525e029c250a34be16d6175383462598af3e1"},{"_id":"public/2016/01/31/Virtual-DOM/index.html","modified":1456839604530,"shasum":"0f650702063ebd2d4dc04fa156d384b196c52b26"},{"_id":"public/2016/01/27/从零开始编写一个Hexo主题/index.html","modified":1456839604541,"shasum":"2459f80a5392a3b00e33e184d0e6c2570bc7eb6e"},{"_id":"public/2016/01/20/5-Ways-to-Make-a-Sticky-Footer/index.html","modified":1456839604553,"shasum":"4a72ba9dfff003844c38306e2a0409f805249fcb"},{"_id":"public/2015/07/25/BFC-in-CSS-0-WTF/index.html","modified":1456839604571,"shasum":"c29b2eddec5511b25131af5c1b130646a6cd0308"},{"_id":"public/2015/07/19/Scope-3-What-Is-Closure/index.html","modified":1456839604585,"shasum":"5da0dd41172155b43ad970f59d4c185503be734a"},{"_id":"public/2015/07/18/Scope-2-Lexical-Scope-Dynamical-Scope/index.html","modified":1456839604598,"shasum":"09584aec5bb654eb8b368f8b81e702277be62e1e"},{"_id":"public/2015/07/16/google-chrome-Devtools-Overview/index.html","modified":1456839604615,"shasum":"667da6ad5a72f9478ab5f7490c003bd5f1662697"},{"_id":"public/2015/07/09/Scope-1-Nested-Scope/index.html","modified":1456839604630,"shasum":"48a1d59b823fa8676c0b6dba16591756d5201fc9"},{"_id":"public/2015/07/06/Scope-0-What-Is-Scope/index.html","modified":1456839604649,"shasum":"f7266b3ec92ce3e25e6d708ea17395992896bc4d"},{"_id":"public/2015/06/18/ES6-In-Practice-0-watch-a-demo/index.html","modified":1456839604664,"shasum":"a532e2c2f8aff730b6db25a6e2eca60bb5792b1b"},{"_id":"public/2015/06/11/gulp-in-practice/index.html","modified":1456839604684,"shasum":"2ec77c4ed90d864b85fa4b8ec3d60b63a417bb0a"},{"_id":"public/2015/06/09/JavaScript-For-Kids-This/index.html","modified":1456839604700,"shasum":"f36dd60607362cf6af51dd76440d7d90f3a7d6e3"},{"_id":"public/archives/index.html","modified":1456839604740,"shasum":"9f917e4d9a9bf25cd25e30e2717e296af2fa21a2"},{"_id":"public/archives/page/2/index.html","modified":1456839604754,"shasum":"5ca4831e2d9f668545a7ac47231927c218d95e2b"},{"_id":"public/archives/page/3/index.html","modified":1456839604767,"shasum":"c44c5473a66bb8b28c017fd700638d4b5a5bd932"},{"_id":"public/archives/2015/index.html","modified":1456839604780,"shasum":"4e058ad14c3c49059a0dc57725cb8710e1f7f2bf"},{"_id":"public/archives/2015/page/2/index.html","modified":1456839604789,"shasum":"a96af7c0013398ea8cd4e8e4817e47beceb40530"},{"_id":"public/archives/2015/06/index.html","modified":1456839604800,"shasum":"fd068251672a0937f6b324f88f65697c1c3497e2"},{"_id":"public/archives/2015/07/index.html","modified":1456839604812,"shasum":"b5cfa96b8889da178b4ca9dd25da63029767b801"},{"_id":"public/archives/2016/index.html","modified":1456839604831,"shasum":"509eb017704cfe43d9038eb85f1c6a9a106e7fe2"},{"_id":"public/archives/2016/page/2/index.html","modified":1456839604844,"shasum":"d3db48d93ec97c67afd333addd80689e2ea01073"},{"_id":"public/archives/2016/01/index.html","modified":1456839604854,"shasum":"402a2cd7768ae3111c1e123d75dcc9db68a61835"},{"_id":"public/archives/2016/02/index.html","modified":1456839604866,"shasum":"5619dac2f7cdfed408a8bba4afa9b10f261738e8"},{"_id":"public/archives/2016/03/index.html","modified":1456839604875,"shasum":"2a04fea5dd69bf2591f8d10dcb8b8ae1f26adf5c"},{"_id":"public/categories/FrontEnd/index.html","modified":1456839604887,"shasum":"85ecb01fc949de1b9eed47c36e407b75d15c7fb8"},{"_id":"public/categories/Tools/index.html","modified":1456839604896,"shasum":"ec2a624874d28d04db00d9e2e1d93733ffb4da0e"},{"_id":"public/categories/JavaScript/index.html","modified":1456839604906,"shasum":"d63a326e44ab1c0dc179f9d555d6b206a33f9c54"},{"_id":"public/categories/JavaScript/page/2/index.html","modified":1456839604915,"shasum":"11f787aa3d3ec451f088da947b0ac3b937a4fa5d"},{"_id":"public/categories/翻译/index.html","modified":1456839604932,"shasum":"a083713a08074d2a79ca94c84f731152b581411f"},{"_id":"public/categories/CSS/index.html","modified":1456839604938,"shasum":"4f44a566891238837f2106c764abe9279ba6cfd6"},{"_id":"public/atom.xml","modified":1456839604950,"shasum":"018839b2fc9b2efd8f9acea0cc7f307bf1864a68"},{"_id":"public/index.html","modified":1456839604970,"shasum":"daaa068493f60ab93d7511f2f4c35c5339d4dc6c"},{"_id":"public/page/2/index.html","modified":1456839604982,"shasum":"223b458a8211ea35ff38632165bd2bb986a26cb5"},{"_id":"public/page/3/index.html","modified":1456839604993,"shasum":"84e7fc3b21f20188c8315fe2633aa0253da8fc9e"},{"_id":"public/page/4/index.html","modified":1456839605001,"shasum":"095ecec3623fad12cd98edf01b69997481378fa2"},{"_id":"public/tags/hexo/index.html","modified":1456839605010,"shasum":"0b3072d45340574c2fe17bf8b593be7393210981"},{"_id":"public/tags/theme/index.html","modified":1456839605018,"shasum":"0b3072d45340574c2fe17bf8b593be7393210981"},{"_id":"public/tags/JavaScript/index.html","modified":1456839605027,"shasum":"a2d294f7ae6365201bd00752298f06fa7ffaa1fe"},{"_id":"public/tags/test/index.html","modified":1456839605035,"shasum":"a2d294f7ae6365201bd00752298f06fa7ffaa1fe"},{"_id":"public/tags/gulp/index.html","modified":1456839605045,"shasum":"85ecb01fc949de1b9eed47c36e407b75d15c7fb8"},{"_id":"public/tags/google-chrome/index.html","modified":1456839605056,"shasum":"ec2a624874d28d04db00d9e2e1d93733ffb4da0e"},{"_id":"public/tags/devtools/index.html","modified":1456839605064,"shasum":"ec2a624874d28d04db00d9e2e1d93733ffb4da0e"},{"_id":"public/tags/scope/index.html","modified":1456839605072,"shasum":"e19ea0a364e87ecaff66beddcf8a34353dcd66ef"},{"_id":"public/tags/closure/index.html","modified":1456839605081,"shasum":"9a64f5b5d538e4a8871dbb4db5df93e3ca12f190"},{"_id":"public/tags/作用域/index.html","modified":1456839605092,"shasum":"6bbd2dc16e12ab3cfb5f0d85f9301f845550bdb9"},{"_id":"public/tags/This/index.html","modified":1456839605096,"shasum":"8750152bc0e07b30d826c2be8df6bebccc4a4efb"},{"_id":"public/tags/ES6/index.html","modified":1456839605103,"shasum":"7a6e721b751ab342f979d91db40b5d4de3bee497"},{"_id":"public/tags/BFC/index.html","modified":1456839605112,"shasum":"4f44a566891238837f2106c764abe9279ba6cfd6"}],"Category":[{"name":"FrontEnd","_id":"cil9gon6n000eqorejdr76x6d"},{"name":"Tools","_id":"cil9gon6t000jqoredmrunt60"},{"name":"JavaScript","_id":"cil9gon7h000rqore5rlawlq3"},{"name":"翻译","_id":"cil9gon8d001aqorefbm2vdw0"},{"name":"CSS","_id":"cil9gon9b001oqoren170t24a"}],"Data":[],"Page":[{"title":"about","date":"2016-01-26T09:49:08.000Z","_content":"\n我们去找点儿朋友吧!\n\n## Contact\n- 邮箱: *drakeleung42@gmail.com*\n\n## Information\n- 梁远成 / 男 / 1994\n- 本科 / 广东工业大学计算机\n\n- GitHub: https://github.com/DrakeLeung\n- 博客: https://drakeleung.github.io/blog/\n\n- 期待职位: Web前端工程师\n\n## Project\n- 广州优校云\n- 长沙烟草局\n- 海口应急指挥调度系统\n\n## Work\n- 操作系统课设-[多道批处理系统两级调度的模拟](https://github.com/DrakeLeung/OS-scheduling)\n- Hexo博客主题 - [again](https://github.com/DrakeLeung/hexo-theme-again)\n","source":"about/index.md","raw":"---\ntitle: \"about\"\ndate: 2016-01-26 17:49:08\n---\n\n我们去找点儿朋友吧!\n\n## Contact\n- 邮箱: *drakeleung42@gmail.com*\n\n## Information\n- 梁远成 / 男 / 1994\n- 本科 / 广东工业大学计算机\n\n- GitHub: https://github.com/DrakeLeung\n- 博客: https://drakeleung.github.io/blog/\n\n- 期待职位: Web前端工程师\n\n## Project\n- 广州优校云\n- 长沙烟草局\n- 海口应急指挥调度系统\n\n## Work\n- 操作系统课设-[多道批处理系统两级调度的模拟](https://github.com/DrakeLeung/OS-scheduling)\n- Hexo博客主题 - [again](https://github.com/DrakeLeung/hexo-theme-again)\n","updated":"2016-01-27T08:28:24.850Z","path":"about/index.html","comments":1,"layout":"page","_id":"cil9gon560001qorenkm1usp8"}],"Post":[{"title":"5 Ways To Make A Sticky Footer","author":"Drake Leung","date":"2016-01-20T07:19:06.000Z","foreword":"总结一下创建Sticky Footer的5种方法。","_content":"\n*Sticky Footer*在内容展示的网站都会用到。比如blog，xx的主页等等。\n\n## What is Sticky Footer\n\n为了简单起见，我们不妨假设我们的`index.html`是这样的:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Ways to make a sticky foote</title>\n</head>\n<body>\n  <main></main>\n  <footer></footer>\n</body>\n</html>\n```\n\n那么，如下面的图所示，图`a`和`b`都不是*Sticky Footer*.\n\n![](http://ww2.sinaimg.cn/large/7f85b91egw1f0asb7siypj20go088q4x.jpg)\n\n因为图`a`的页脚的后面还有空白部分。我们想要的应该是页脚就是在页面的最底部。\n\n那么图`b`为什么不是呢？他不是在页面的最底部吗？没错，但是我们想要的是只有当**scroller bar**滑到最底部的时候，才会出现页脚。\n\n像下面的图`c`和`d`才是我们的*Sticky Footer*:\n![](http://ww2.sinaimg.cn/large/7f85b91egw1f0asq75p07j20gl09i0vh.jpg)\n\n## Ways to Sticky Footer\n废话少说，下面会介绍几种创建*Sticky Footer*的方法。\n\n我们会从最简单的方法开始，但最简单的不一定是最好的，符合自己的使用场景才是最好的。最后总结每种方法的优缺点。\n\n(P.S. 假设我们都使用上面的`index.html`所示结构)\n\n### Flexbox\n*[方法来源](https://philipwalton.github.io/solved-by-flexbox/demos/sticky-footer/)*\n\n```css\n/* #0 */\nbody {\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  margin: 0;\n}\n\n/* #1 */\nmain {\n  flex: 1;\n}\n```\n\n`#0`是中的`min-height: 100vh`是为了让`<main>`的高度没有大于屏幕的高度时，使得`footer`可以在页面的底部。而，`margin: 0`是去掉原本浏览器自带的`<body>`的样式。\n\n`#1`的`flex: 1`是为了让`<main>`占满多余的空间。\n\n### Modern Way\n*[方法来源](http://mystrd.at/modern-clean-css-sticky-footer/)*\n\n```css\n/* #0 */\nhtml {\n  position: relative;\n  min-height: 100%;\n}\n\n/* #1 */\nbody {\n  margin: 0;\n  margin-bottom: 100px; /* same to footer height */\n}\n\n/* #2 */\nfooter {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  height: 100px;\n}\n```\n\n`#0`中的`position: relative`很显然是为了让`<html>`变成*containning block*，\n这个在`#2`会说到。同样地，`min-height: 100%`和上面的*flexbox*方法中的`#0`一样。\n\n`#1`的`margin-bottom`设为`100px`是和`<footer>`的高度一样的。目的是当`<body>`的内容溢出\n的时候，防止`<footer>`的内容蹿到`<body>`里面。\n\n`#2`设置了`position: absolute`，这样，`left`和`bottom`的值都是相对于`<footer>`的*containning block*来说的。\n由于在`#0`设置了`<html>`的`position`为`relative`，所以`<html>`就是`<footer>`的*containning block*。\n\n### Table Way\n*[方法来源](http://codepen.io/anon/pen/zrRLVW)或者[这个](https://gist.github.com/goldsky/7322156)*\n\n```css\nhtml,\nbody {\n  height: 100%;\n}\n\nbody {\n  margin: 0;\n  display: table; /* #0 */\n}\nmain,\nfooter {\n  display: table-row;\n}\n\n/* #1\nmain {\n  height: 100%;\n}\n*/\n\nfooter {\n  height: 1px; /* #2 */\n}\n```\n\n其实这个方法就是利用了`table`布局，然后设置`<footer>`的高度为`1px`(如`#2`所示)。但是我并不知道为什么。\n并且，如果我把`#2`注释掉，把`#1`的注释去掉，也是work的。所以不知道设置`1px`有什么用。\n\n### Old Way\n*[方法来源](http://ryanfait.com/resources/footer-stick-to-bottom-of-page/)*\n\n这种方法需要我们改变一下我们的`index.html`，给我们的`<main>`添加一个空白的`<div>`。\n他其实是`<footer>`的*placeholder*。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Ways to make a sticky foote</title>\n</head>\n<body>\n  <main>\n    <div class=\"push\"></div> <!-- new -->\n  </main>\n  <footer></footer>\n</body>\n<html>\n```\n那么，对应的CSS是这样的：\n\n```css\nhtml, body {\n  height: 100%;\n}\n\nbody {\n  margin: 0;\n}\n\nmain {\n  min-height: 100%;\n  margin-bottom: -100px; /* #0 */\n}\n\nfooter,\n.push {\n  height: 100px; /* #1 */\n}\n```\n\n`#0`给`<main>`设置了`margin-bottom: -100px`。这是`<footer>`的高度的相反数。\n他是为了让`<footer>`可以蹿到`<div class=\"push\"></div>`的位置。\n\n因为`.push`就是`<footer>`的placeholder, 显然他们的`height`必须是一样的，如`#1`所示。\n\n其实我们还可以使用为了`:after`改进一下。因为`.push`存在的意义只是为了样式而样式，并不是页面的结构，所以也没有必要出现在`index.html`里面。因此，我们有了下面的*Old Way Plus*。\n\n### Old Way Plus\n*[方法来源](https://css-tricks.com/snippets/css/sticky-footer/)*\n\n(注意，这个时候我们并不需要给`<main>`添加一个`<div class=\"push\"></div>`)\n\n```css\nhtml, body {\n  height: 100%;\n}\n\nmain {\n  min-height: 100%;\n  /* equal to footer height */\n  margin-bottom: -100px;\n}\n\n/* #0 */\nmain:after {\n  content: \"\";\n  display: block;\n  height: 100px;\n}\n\nfooter {\n  height: 100px;\n}\n```\n`#0`, 我们利用伪类`:after`来替代上面的*Old Way*的`.push`，这样就不需要给`index.html`\n添加不必要的标签。\n\n## To Sum Up\n方法  | 难度   | Footer需要固定高度 | 浏览器兼容\n----    | ----  | -------            |  ------\nFlexbox | +  | No                 |   +\nModern way | ++ | Yes                 |  +++\nTable way | ++   | No             | ++?\nOld way | +++     | Yes |     +++\nOld way Plus | ++ | Yes |   ++\n","source":"_posts/5-Ways-to-Make-a-Sticky-Footer.md","raw":"title: 5 Ways To Make A Sticky Footer\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-01-20 15:19:06\nforeword: 总结一下创建Sticky Footer的5种方法。\n---\n\n*Sticky Footer*在内容展示的网站都会用到。比如blog，xx的主页等等。\n\n## What is Sticky Footer\n\n为了简单起见，我们不妨假设我们的`index.html`是这样的:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Ways to make a sticky foote</title>\n</head>\n<body>\n  <main></main>\n  <footer></footer>\n</body>\n</html>\n```\n\n那么，如下面的图所示，图`a`和`b`都不是*Sticky Footer*.\n\n![](http://ww2.sinaimg.cn/large/7f85b91egw1f0asb7siypj20go088q4x.jpg)\n\n因为图`a`的页脚的后面还有空白部分。我们想要的应该是页脚就是在页面的最底部。\n\n那么图`b`为什么不是呢？他不是在页面的最底部吗？没错，但是我们想要的是只有当**scroller bar**滑到最底部的时候，才会出现页脚。\n\n像下面的图`c`和`d`才是我们的*Sticky Footer*:\n![](http://ww2.sinaimg.cn/large/7f85b91egw1f0asq75p07j20gl09i0vh.jpg)\n\n## Ways to Sticky Footer\n废话少说，下面会介绍几种创建*Sticky Footer*的方法。\n\n我们会从最简单的方法开始，但最简单的不一定是最好的，符合自己的使用场景才是最好的。最后总结每种方法的优缺点。\n\n(P.S. 假设我们都使用上面的`index.html`所示结构)\n\n### Flexbox\n*[方法来源](https://philipwalton.github.io/solved-by-flexbox/demos/sticky-footer/)*\n\n```css\n/* #0 */\nbody {\n  display: flex;\n  flex-direction: column;\n  min-height: 100vh;\n  margin: 0;\n}\n\n/* #1 */\nmain {\n  flex: 1;\n}\n```\n\n`#0`是中的`min-height: 100vh`是为了让`<main>`的高度没有大于屏幕的高度时，使得`footer`可以在页面的底部。而，`margin: 0`是去掉原本浏览器自带的`<body>`的样式。\n\n`#1`的`flex: 1`是为了让`<main>`占满多余的空间。\n\n### Modern Way\n*[方法来源](http://mystrd.at/modern-clean-css-sticky-footer/)*\n\n```css\n/* #0 */\nhtml {\n  position: relative;\n  min-height: 100%;\n}\n\n/* #1 */\nbody {\n  margin: 0;\n  margin-bottom: 100px; /* same to footer height */\n}\n\n/* #2 */\nfooter {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  height: 100px;\n}\n```\n\n`#0`中的`position: relative`很显然是为了让`<html>`变成*containning block*，\n这个在`#2`会说到。同样地，`min-height: 100%`和上面的*flexbox*方法中的`#0`一样。\n\n`#1`的`margin-bottom`设为`100px`是和`<footer>`的高度一样的。目的是当`<body>`的内容溢出\n的时候，防止`<footer>`的内容蹿到`<body>`里面。\n\n`#2`设置了`position: absolute`，这样，`left`和`bottom`的值都是相对于`<footer>`的*containning block*来说的。\n由于在`#0`设置了`<html>`的`position`为`relative`，所以`<html>`就是`<footer>`的*containning block*。\n\n### Table Way\n*[方法来源](http://codepen.io/anon/pen/zrRLVW)或者[这个](https://gist.github.com/goldsky/7322156)*\n\n```css\nhtml,\nbody {\n  height: 100%;\n}\n\nbody {\n  margin: 0;\n  display: table; /* #0 */\n}\nmain,\nfooter {\n  display: table-row;\n}\n\n/* #1\nmain {\n  height: 100%;\n}\n*/\n\nfooter {\n  height: 1px; /* #2 */\n}\n```\n\n其实这个方法就是利用了`table`布局，然后设置`<footer>`的高度为`1px`(如`#2`所示)。但是我并不知道为什么。\n并且，如果我把`#2`注释掉，把`#1`的注释去掉，也是work的。所以不知道设置`1px`有什么用。\n\n### Old Way\n*[方法来源](http://ryanfait.com/resources/footer-stick-to-bottom-of-page/)*\n\n这种方法需要我们改变一下我们的`index.html`，给我们的`<main>`添加一个空白的`<div>`。\n他其实是`<footer>`的*placeholder*。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Ways to make a sticky foote</title>\n</head>\n<body>\n  <main>\n    <div class=\"push\"></div> <!-- new -->\n  </main>\n  <footer></footer>\n</body>\n<html>\n```\n那么，对应的CSS是这样的：\n\n```css\nhtml, body {\n  height: 100%;\n}\n\nbody {\n  margin: 0;\n}\n\nmain {\n  min-height: 100%;\n  margin-bottom: -100px; /* #0 */\n}\n\nfooter,\n.push {\n  height: 100px; /* #1 */\n}\n```\n\n`#0`给`<main>`设置了`margin-bottom: -100px`。这是`<footer>`的高度的相反数。\n他是为了让`<footer>`可以蹿到`<div class=\"push\"></div>`的位置。\n\n因为`.push`就是`<footer>`的placeholder, 显然他们的`height`必须是一样的，如`#1`所示。\n\n其实我们还可以使用为了`:after`改进一下。因为`.push`存在的意义只是为了样式而样式，并不是页面的结构，所以也没有必要出现在`index.html`里面。因此，我们有了下面的*Old Way Plus*。\n\n### Old Way Plus\n*[方法来源](https://css-tricks.com/snippets/css/sticky-footer/)*\n\n(注意，这个时候我们并不需要给`<main>`添加一个`<div class=\"push\"></div>`)\n\n```css\nhtml, body {\n  height: 100%;\n}\n\nmain {\n  min-height: 100%;\n  /* equal to footer height */\n  margin-bottom: -100px;\n}\n\n/* #0 */\nmain:after {\n  content: \"\";\n  display: block;\n  height: 100px;\n}\n\nfooter {\n  height: 100px;\n}\n```\n`#0`, 我们利用伪类`:after`来替代上面的*Old Way*的`.push`，这样就不需要给`index.html`\n添加不必要的标签。\n\n## To Sum Up\n方法  | 难度   | Footer需要固定高度 | 浏览器兼容\n----    | ----  | -------            |  ------\nFlexbox | +  | No                 |   +\nModern way | ++ | Yes                 |  +++\nTable way | ++   | No             | ++?\nOld way | +++     | Yes |     +++\nOld way Plus | ++ | Yes |   ++\n","slug":"5-Ways-to-Make-a-Sticky-Footer","published":1,"updated":"2016-01-27T07:20:56.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon4y0000qoreccoraco7"},{"title":"实现一个简单的 AMD 模块加载器","author":"Drake Leung","date":"2016-02-11T15:32:53.000Z","foreword":"讲一下实现过程中遇到的问题。","_content":"\n(完整代码请看[GitHub - tiny module loader](https://github.com/DrakeLeung/tiny-module-loader))\n\n## What\n不了解JavaScript模块化的请看[「译」JavaScript Modules Part1: A Beginner Guide](http://drakeleung.github.io/blog/2016/02/07/JavaScript-Module-A-Beginner-Guide/)。\n\n简单来说，AMD规范定义了模块加载的方式是异步的而不是同步。\n\n接着，语法是这样子的：`define`函数去请求依赖。其中，第一个参数是依赖的模块数组，第二个参数是函数。当依赖都加载完毕之后，就会作为参数，传进这个函数里面。\n\n## Why\n为了探究 AMD 模块加载器的原理，我们不妨尝试着从零开始实现他。\n\n我们只实现一个 `define` 函数。其他后面再慢慢完善。\n\n## How\n主要分成3部分：下载依赖，执行依赖并导出，读取依赖并执行回调(递归地)。\n\n### 下载依赖\n接受一个依赖模块的URL，然后用Ajax请求。这时会返回包含文件内容的字符串。\n\n这个很简单，只是用*Promise*简便一点而已。\n\n```JavaScript\n// getModule.js\n\nexport const fetchDeps = name =>\n  new Promise((resolve, reject) => {\n    let req = new XMLHttpRequest()\n\n    req.addEventListener('load', () => {\n      if (req.status < 400) resolve(req.responseText)\n      else reject(req.status)\n    }, false)\n\n    req.addEventListener('error', () => {\n      reject(req.status)\n    }, false)\n\n    req.open('GET', name, true)\n    req.send(null)\n  })\n```\n\n### 执行依赖\n由于请求依赖返回的是一个字符串。但我们想要的是把这个字符串当作 JavaScript 代码来执行，解决方法有2种，分别是 `eval()` 和 `new Function()`。我们采取后者。\n\n还有一种方法应该可以：动态创建 `<script>` 标签。\n\n```JavaScript\n// getModule.js\n\nlet currentModule = null\n\nexport const getModule = code => {\n  let module = {\n    exports: null,\n    exported: false,\n    onExport: []\n  }\n\n  currentModule = module\n  new Function ('', code)() // work with eval(), as well\n\n  return module\n}\n\nexport {\n  currentModule,\n  getModule\n}\n```\n\n这里有一个我觉得是最难的问题：由于 `new Function()` 执行的时候，是不返回东西的（其实我并不知道 `new Function` 的工作原理)。\n\n所以，这个时候依赖虽然是请求回来并执行了，但是他依然还没有导出(`exports`)。所以，返回的 `module` 对象的 `exports` 是 `null`的。并且，我们还用了一个变量 `currentModule` 还存储当前的变量。\n\n\n### 导出依赖并执行回调函数\n\n```javascript\n// myDefine.js\n\n// import {\n//   currentModule,\n//   getModule\n// } from './getModule'\n//\n// import {fetchDeps} from './fetchDeps'\n// import {whenDepsExported} from './whenDepsExported'\n\nexport const define = (deps, callback) => {\n  let myModule = currentModule // #0\n  const getDeps = deps.map(fetchDeps)\n\n  Promise.all(getDeps)\n    .then(codes => {\n      const modules = codes.map(getModule)\n\n      // #1\n      modules.forEach(m =>\n        !m.exported && m.onExport.push(() =>\n          whenDepsExported(callback, modules, myModule)\n        )\n      )\n\n      whenDepsExported(callback, modules, myModule) // #2\n    })\n}\n```\n\n`#0` 我们把 `currentModule` 赋给一个局部变量，这样使得每个 `define` 都有自己的「模块」。这个也是困惑了我好久的一步。我也似懂非懂，因为反正已经 work 起来了= =\n\n这个时候问题就来了。因为我们需要递归地加载依赖，那么，肯定是加载最外面的依赖，然后才到里面。如果没有了 `#1`，那么就会执行 `#2`，这样就会导致和想我们想要的相反，即先执行最里面的依赖的回调，再执行外面的。\n\n因此，我们把最里面的模块先放到一个数组里面，然后当他的依赖执行完之后，再去执行他的回调，这时他的回调的参数才有值。\n\n```JavaScript\n// whenDepsExported.js\n\nexport const whenDepsExported = (cb, deps, myModule) => {\n  if (!deps.every(dep => dep.exported)) return\n\n  // params for 'callback of define'\n  let args = deps.map(dep => dep.exports)\n  let exports = cb.apply(null, args)\n\n  // #0\n  if (myModule) {\n    myModule.exports = exports\n    myModule.exported = true\n    myModule.onExport.forEach(f => f())\n  }\n\n  return exports\n}\n```\n\n`#0` 中，我们导出了依赖，并且执行了 `onExport` 的回调函数。\n\n## Wrap up\n原理看起来不是很难，但自己实现一遍还是挺难的。\n\n不过 AMD，CommonJS 这些规范倒是改善了 JavaScript 模块系统，使得 JavaScript 能够在规模较大的项目中更加容易开发，以及维护。\n\n(完整代码请看[GitHub - tiny module loader](https://github.com/DrakeLeung/tiny-module-loader))\n\n## Resources\n- [eloquent javascript - modules](http://eloquentjavascript.net/10_modules.html)\n","source":"_posts/实现一个简单的AMD模块加载器.md","raw":"---\ntitle: 实现一个简单的 AMD 模块加载器\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-02-11 23:32:53\nforeword: 讲一下实现过程中遇到的问题。\n---\n\n(完整代码请看[GitHub - tiny module loader](https://github.com/DrakeLeung/tiny-module-loader))\n\n## What\n不了解JavaScript模块化的请看[「译」JavaScript Modules Part1: A Beginner Guide](http://drakeleung.github.io/blog/2016/02/07/JavaScript-Module-A-Beginner-Guide/)。\n\n简单来说，AMD规范定义了模块加载的方式是异步的而不是同步。\n\n接着，语法是这样子的：`define`函数去请求依赖。其中，第一个参数是依赖的模块数组，第二个参数是函数。当依赖都加载完毕之后，就会作为参数，传进这个函数里面。\n\n## Why\n为了探究 AMD 模块加载器的原理，我们不妨尝试着从零开始实现他。\n\n我们只实现一个 `define` 函数。其他后面再慢慢完善。\n\n## How\n主要分成3部分：下载依赖，执行依赖并导出，读取依赖并执行回调(递归地)。\n\n### 下载依赖\n接受一个依赖模块的URL，然后用Ajax请求。这时会返回包含文件内容的字符串。\n\n这个很简单，只是用*Promise*简便一点而已。\n\n```JavaScript\n// getModule.js\n\nexport const fetchDeps = name =>\n  new Promise((resolve, reject) => {\n    let req = new XMLHttpRequest()\n\n    req.addEventListener('load', () => {\n      if (req.status < 400) resolve(req.responseText)\n      else reject(req.status)\n    }, false)\n\n    req.addEventListener('error', () => {\n      reject(req.status)\n    }, false)\n\n    req.open('GET', name, true)\n    req.send(null)\n  })\n```\n\n### 执行依赖\n由于请求依赖返回的是一个字符串。但我们想要的是把这个字符串当作 JavaScript 代码来执行，解决方法有2种，分别是 `eval()` 和 `new Function()`。我们采取后者。\n\n还有一种方法应该可以：动态创建 `<script>` 标签。\n\n```JavaScript\n// getModule.js\n\nlet currentModule = null\n\nexport const getModule = code => {\n  let module = {\n    exports: null,\n    exported: false,\n    onExport: []\n  }\n\n  currentModule = module\n  new Function ('', code)() // work with eval(), as well\n\n  return module\n}\n\nexport {\n  currentModule,\n  getModule\n}\n```\n\n这里有一个我觉得是最难的问题：由于 `new Function()` 执行的时候，是不返回东西的（其实我并不知道 `new Function` 的工作原理)。\n\n所以，这个时候依赖虽然是请求回来并执行了，但是他依然还没有导出(`exports`)。所以，返回的 `module` 对象的 `exports` 是 `null`的。并且，我们还用了一个变量 `currentModule` 还存储当前的变量。\n\n\n### 导出依赖并执行回调函数\n\n```javascript\n// myDefine.js\n\n// import {\n//   currentModule,\n//   getModule\n// } from './getModule'\n//\n// import {fetchDeps} from './fetchDeps'\n// import {whenDepsExported} from './whenDepsExported'\n\nexport const define = (deps, callback) => {\n  let myModule = currentModule // #0\n  const getDeps = deps.map(fetchDeps)\n\n  Promise.all(getDeps)\n    .then(codes => {\n      const modules = codes.map(getModule)\n\n      // #1\n      modules.forEach(m =>\n        !m.exported && m.onExport.push(() =>\n          whenDepsExported(callback, modules, myModule)\n        )\n      )\n\n      whenDepsExported(callback, modules, myModule) // #2\n    })\n}\n```\n\n`#0` 我们把 `currentModule` 赋给一个局部变量，这样使得每个 `define` 都有自己的「模块」。这个也是困惑了我好久的一步。我也似懂非懂，因为反正已经 work 起来了= =\n\n这个时候问题就来了。因为我们需要递归地加载依赖，那么，肯定是加载最外面的依赖，然后才到里面。如果没有了 `#1`，那么就会执行 `#2`，这样就会导致和想我们想要的相反，即先执行最里面的依赖的回调，再执行外面的。\n\n因此，我们把最里面的模块先放到一个数组里面，然后当他的依赖执行完之后，再去执行他的回调，这时他的回调的参数才有值。\n\n```JavaScript\n// whenDepsExported.js\n\nexport const whenDepsExported = (cb, deps, myModule) => {\n  if (!deps.every(dep => dep.exported)) return\n\n  // params for 'callback of define'\n  let args = deps.map(dep => dep.exports)\n  let exports = cb.apply(null, args)\n\n  // #0\n  if (myModule) {\n    myModule.exports = exports\n    myModule.exported = true\n    myModule.onExport.forEach(f => f())\n  }\n\n  return exports\n}\n```\n\n`#0` 中，我们导出了依赖，并且执行了 `onExport` 的回调函数。\n\n## Wrap up\n原理看起来不是很难，但自己实现一遍还是挺难的。\n\n不过 AMD，CommonJS 这些规范倒是改善了 JavaScript 模块系统，使得 JavaScript 能够在规模较大的项目中更加容易开发，以及维护。\n\n(完整代码请看[GitHub - tiny module loader](https://github.com/DrakeLeung/tiny-module-loader))\n\n## Resources\n- [eloquent javascript - modules](http://eloquentjavascript.net/10_modules.html)\n","slug":"实现一个简单的AMD模块加载器","published":1,"updated":"2016-02-11T17:18:33.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon580002qorea53b5fzq"},{"title":"从零开始编写一个Hexo主题","author":"Drake Leung","date":"2016-01-27T14:23:29.000Z","foreword":"从零开始写一个主题的话，就意味着我们要了解Hexo的workflow。","_content":"\n之前我也不会写，但是当我了解以下东西的时候，就可以从零开始写一个Hexo主题了。\n{% asset_img hexo2.png %}\n\n- NodeJS / NPM\n- 模板引擎(Template Engine)，比如EJS, Jade，Handlebars等等都可以\n- HTML / CSS / JavaScript\n- 阅读Hexo的[文档](https://hexo.io/docs/)\n- 阅读Hexo默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的源码\n\n以上正是一名Web前端人员需要了解和掌握的东西。\n**不过，不会前端也不要紧，我告诉你以下的东西就足够了。**\n\n## NodeJS / NPM\n首先，Hexo是由NodeJS来编写的。编写一个应用是需要第三方包(依赖/库)，这个就是我们的`package.json`文件的由来。这些package怎么下载的呢？答案就是通过[NPM](https://www.npmjs.com/)(Node Package Manager)，然后他们都会安装在`node_modules/`这个文件夹里面。\n\nOK，这就是我们需要知道的NodeJS和NPM的知识。\n\n## Hexo的Workflow\n**下面是重点。**\n\nHexo会读取根目录下的`_config.yml`里面的`theme`属性, 从而采用对应的主题。而主题都是放在`themes/`目录下面的，然后你会发现他里面有个`landscape`的目录，这个就是默认主题啦。\n\n{% asset_img hexo1.png theme workflow %}\n\n接着，我们查看`themes/landscape/`目录，以及根据文档[docs-themes](https://hexo.io/docs/themes.html)，我们很容易得出：一个主题其实由4部分组成。\n\n- `_config.yml`: 主题的配置文件\n- `source/`: 放我们的CSS文件以及图片\n- `layout/`: 模板文件\n- `scripts`: 放JavaScript文件，他们会自动加载\n\n然后，根据文档[docs-templates](https://hexo.io/docs/templates.html)，不难得出：\n\n每次当我们在浏览器访问时，Hexo都会去解析`sources`目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以`EJS`为例)\n\n无论URL是什么，Hexo先读取`layout.ejs`，然后里面的[body](https://github.com/hexojs/hexo-theme-landscape/blob/master/layout%2Flayout.ejs)变量会替换成以下内容：(*Fallback*的意思是如果访问`/archives`时，我们的`archives.ejs`不存在的话，就会返回`index.ejs`)\n\nURL   | Template  | Fallback\n---   | ----      | ---\n/     | index.ejs |\n/archives | archive.ejs | index.ejs\n文章  | post.ejs  | index.ejs\n\n\n如下图所示:\n{% asset_img hexo.png template workflow %}\n\n或者，可以先尝试一下没有`layout.ejs`的情况，因为比较简单。也就是，访问`/`，Hexo就返回`index.ejs`里面的东西给你。访问`/archives`就返回`archive.ejs`。\n\n## 模板文件\n那么，接下来就要编写我们的模板文件了。怎么写呢？\n比如我的根目录想显示所有的文章？我们就要使用Hexo提供的[变量](https://hexo.io/docs/variables.html)了。通过文档，我们可以得出`page.posts`这个变量就包含了所有的文章。\n\n```html\n<% page.posts.each(function(post){ %>\n  <article>\n    <h1> post.title </h1>\n    <div> post.content </div>\n  </article>\n<% }) %>\n```\n\n编写模板文件的时候，我们可能利用Hexo内置的一些[helper](https://hexo.io/docs/helpers.html)来方便开发，比如分页使用[paginator](https://hexo.io/docs/helpers.html#paginator)，路径处理使用[url_for](https://hexo.io/docs/helpers.html#url_for)等。\n\n## 样式\n我们的CSS文件是放在`source`里面的，然后要怎么加载呢？这个时候，我们就需要在模板文件里面引入，比如我们的首页需要`app.css`，那么就在`index.ejs`里面引用就行了。如果每个页面都用到的话，就放在`layout.ejs`。\n```html\n<%- css('path/to/app') %>\n```\n\n当然，你也可以使用预处理器来写样式，比如Sass，Stylus等等。此时，你就要下载对应的package来解释成CSS。比如，我使用的是Sass，那么我就要`npm i --save hexo-renderer-sass`来把`.scss`文件解释成`.css`文件。\n\n## 总结一下\n如果遇到问题的话，查看Hexo默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的源码以及[文档](https://hexo.io/docs/)就能解决了。\n最后卖下广告，这是我写的主题：[hexo-theme-again](https://github.com/DrakeLeung/hexo-theme-again)。\n","source":"_posts/从零开始编写一个Hexo主题.md","raw":"title: 从零开始编写一个Hexo主题\nauthor: Drake Leung\ntags: [hexo, theme]\ncategories: []\ndate: 2016-01-27 22:23:29\nforeword: 从零开始写一个主题的话，就意味着我们要了解Hexo的workflow。\n---\n\n之前我也不会写，但是当我了解以下东西的时候，就可以从零开始写一个Hexo主题了。\n{% asset_img hexo2.png %}\n\n- NodeJS / NPM\n- 模板引擎(Template Engine)，比如EJS, Jade，Handlebars等等都可以\n- HTML / CSS / JavaScript\n- 阅读Hexo的[文档](https://hexo.io/docs/)\n- 阅读Hexo默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的源码\n\n以上正是一名Web前端人员需要了解和掌握的东西。\n**不过，不会前端也不要紧，我告诉你以下的东西就足够了。**\n\n## NodeJS / NPM\n首先，Hexo是由NodeJS来编写的。编写一个应用是需要第三方包(依赖/库)，这个就是我们的`package.json`文件的由来。这些package怎么下载的呢？答案就是通过[NPM](https://www.npmjs.com/)(Node Package Manager)，然后他们都会安装在`node_modules/`这个文件夹里面。\n\nOK，这就是我们需要知道的NodeJS和NPM的知识。\n\n## Hexo的Workflow\n**下面是重点。**\n\nHexo会读取根目录下的`_config.yml`里面的`theme`属性, 从而采用对应的主题。而主题都是放在`themes/`目录下面的，然后你会发现他里面有个`landscape`的目录，这个就是默认主题啦。\n\n{% asset_img hexo1.png theme workflow %}\n\n接着，我们查看`themes/landscape/`目录，以及根据文档[docs-themes](https://hexo.io/docs/themes.html)，我们很容易得出：一个主题其实由4部分组成。\n\n- `_config.yml`: 主题的配置文件\n- `source/`: 放我们的CSS文件以及图片\n- `layout/`: 模板文件\n- `scripts`: 放JavaScript文件，他们会自动加载\n\n然后，根据文档[docs-templates](https://hexo.io/docs/templates.html)，不难得出：\n\n每次当我们在浏览器访问时，Hexo都会去解析`sources`目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以`EJS`为例)\n\n无论URL是什么，Hexo先读取`layout.ejs`，然后里面的[body](https://github.com/hexojs/hexo-theme-landscape/blob/master/layout%2Flayout.ejs)变量会替换成以下内容：(*Fallback*的意思是如果访问`/archives`时，我们的`archives.ejs`不存在的话，就会返回`index.ejs`)\n\nURL   | Template  | Fallback\n---   | ----      | ---\n/     | index.ejs |\n/archives | archive.ejs | index.ejs\n文章  | post.ejs  | index.ejs\n\n\n如下图所示:\n{% asset_img hexo.png template workflow %}\n\n或者，可以先尝试一下没有`layout.ejs`的情况，因为比较简单。也就是，访问`/`，Hexo就返回`index.ejs`里面的东西给你。访问`/archives`就返回`archive.ejs`。\n\n## 模板文件\n那么，接下来就要编写我们的模板文件了。怎么写呢？\n比如我的根目录想显示所有的文章？我们就要使用Hexo提供的[变量](https://hexo.io/docs/variables.html)了。通过文档，我们可以得出`page.posts`这个变量就包含了所有的文章。\n\n```html\n<% page.posts.each(function(post){ %>\n  <article>\n    <h1> post.title </h1>\n    <div> post.content </div>\n  </article>\n<% }) %>\n```\n\n编写模板文件的时候，我们可能利用Hexo内置的一些[helper](https://hexo.io/docs/helpers.html)来方便开发，比如分页使用[paginator](https://hexo.io/docs/helpers.html#paginator)，路径处理使用[url_for](https://hexo.io/docs/helpers.html#url_for)等。\n\n## 样式\n我们的CSS文件是放在`source`里面的，然后要怎么加载呢？这个时候，我们就需要在模板文件里面引入，比如我们的首页需要`app.css`，那么就在`index.ejs`里面引用就行了。如果每个页面都用到的话，就放在`layout.ejs`。\n```html\n<%- css('path/to/app') %>\n```\n\n当然，你也可以使用预处理器来写样式，比如Sass，Stylus等等。此时，你就要下载对应的package来解释成CSS。比如，我使用的是Sass，那么我就要`npm i --save hexo-renderer-sass`来把`.scss`文件解释成`.css`文件。\n\n## 总结一下\n如果遇到问题的话，查看Hexo默认主题[landscape](https://github.com/hexojs/hexo-theme-landscape)的源码以及[文档](https://hexo.io/docs/)就能解决了。\n最后卖下广告，这是我写的主题：[hexo-theme-again](https://github.com/DrakeLeung/hexo-theme-again)。\n","slug":"从零开始编写一个Hexo主题","published":1,"updated":"2016-01-27T17:00:04.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon5d0003qoreh5urhmpq"},{"title":"为你的JavaScript代码写测试","author":"Drake Leung","date":"2016-02-17T11:32:51.000Z","foreword":"我会把测试JavaScript代码的功力一一传授给你。","_content":"下面会讲解如何使用 karama, jasmine 以及 webpack，来为我们的 ES6 代码编写测试。\n（最后我写了一个可用的例子，请查看 [ES2015-Starter-Kit](https://github.com/DrakeLeung/ES2015-Starter-Kit/tree/master) ）\n\n## 艰难的抉择\n> 首先，我们要写测试，用什么写？自己写一个函数，还是使用某个测试框架？\n\n看起来，后者可观一点。\n\n> 然后，有哪些测试框架可以选择？选哪个？\n\n于是，我们 google 之，找到 stackoverflow 的一个问题 [JavaScript unit test tools for TDD](http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd)。\n\n看了问题回答，很纠结，太多了不知道选择哪个！最后，我决定选择 [Karma](https://karma-runner.github.io/0.13/index.html), [Jasmine](https://github.com/jasmine/jasmine) 和 [Mocha](http://mochajs.org/) 这三者之一，根据 Star 数量以及维护团队。\n\n{% asset_img 0.png %}\n\n> 那么，*Karma*, *Jasmine* 以及 *Mocha* 这三者之间哪个好，有什么不同？\n\n于是，我们不妨 google，找到了 [What are the differences between mocha, chai, karma, jasmine, should.js, etc. testing frameworks?](http://stackoverflow.com/questions/24391462/what-are-the-differences-between-mocha-chai-karma-jasmine-should-js-etc-te) 这个问题。\n\n从回答中我们可以知道：*Karma* 只是一个 test runner，他负责提供 environment。而 *Jasmine* 和 *Mocha* 是编写测试脚本的框架。也就是说，我们可以选择 *Karma + Jasmine*或者 *Karma + Mocha*。我们不妨先选择前者~\n\n综上所述，**我们要使用 *Karma + Jasmine* 组合来为我们的 JavaScript 代码写测试**。\n\n## 战斗的号角\n接下来，我们根据文档（[karma - Installation](https://karma-runner.github.io/0.13/intro/installation.html), [karma - Configuration](https://karma-runner.github.io/0.13/intro/configuration.html) 和 [Jasmine - introduction](http://jasmine.github.io/2.0/introduction.html)），很容易就能搞起来。\n\n在这里我想说的是：当编写多个测试脚本的时候，你也许可以使用 `beforeEach` 和 `afterEach`。他们分别会在每个测试（spec）的之前和之后执行一次。\n\n## 副本\n最后还有一个问题是*如何结合 [Webpack](http://webpack.github.io/)* 来为我们的ES6代码编写测试。\n\n我不得不承认，这是一个很不错的问题。然而，我也通过google找到了答案。\n\n详细教程请看 *VueJS* 的 [Testing](https://vuejs.github.io/vue-loader/workflow/testing.html) 文档。\n\n## 战斗的荣耀\n你可以为你的仓库弄一个亮晶晶的 [travis ci status image](https://docs.travis-ci.com/user/status-images/)：\n\n![](https://travis-ci.org/travis-ci/travis-web.svg?branch=master)\n\n详细设置请查看 [travis docs](https://docs.travis-ci.com/user/getting-started/)以及这篇教程 [Testing JavaScript with Jasmine, Travis, and Karma](http://www.sitepoint.com/testing-javascript-jasmine-travis-karma/)。\n\n最后，如果还是不懂的话，可以查看我写的一个例子：[ES2015-Starter-Kit](https://github.com/DrakeLeung/ES2015-Starter-Kit/tree/master)\n\n## Resources\n- [JavaScript unit test tools for TDD](http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd)\n- [What are the differences between mocha, chai, karma, jasmine, should.js, etc. testing frameworks?](http://stackoverflow.com/questions/24391462/what-are-the-differences-between-mocha-chai-karma-jasmine-should-js-etc-te)\n- [vuejs - Testing](https://vuejs.github.io/vue-loader/workflow/testing.html)\n- [Testing JavaScript with Jasmine, Travis, and Karma](http://www.sitepoint.com/testing-javascript-jasmine-travis-karma/)\n","source":"_posts/为你的JavaScript代码写测试.md","raw":"---\ntitle: 为你的JavaScript代码写测试\nauthor: Drake Leung\ntags: [JavaScript, test]\ncategories: []\ndate: 2016-02-17 19:32:51\nforeword: 我会把测试JavaScript代码的功力一一传授给你。\n---\n下面会讲解如何使用 karama, jasmine 以及 webpack，来为我们的 ES6 代码编写测试。\n（最后我写了一个可用的例子，请查看 [ES2015-Starter-Kit](https://github.com/DrakeLeung/ES2015-Starter-Kit/tree/master) ）\n\n## 艰难的抉择\n> 首先，我们要写测试，用什么写？自己写一个函数，还是使用某个测试框架？\n\n看起来，后者可观一点。\n\n> 然后，有哪些测试框架可以选择？选哪个？\n\n于是，我们 google 之，找到 stackoverflow 的一个问题 [JavaScript unit test tools for TDD](http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd)。\n\n看了问题回答，很纠结，太多了不知道选择哪个！最后，我决定选择 [Karma](https://karma-runner.github.io/0.13/index.html), [Jasmine](https://github.com/jasmine/jasmine) 和 [Mocha](http://mochajs.org/) 这三者之一，根据 Star 数量以及维护团队。\n\n{% asset_img 0.png %}\n\n> 那么，*Karma*, *Jasmine* 以及 *Mocha* 这三者之间哪个好，有什么不同？\n\n于是，我们不妨 google，找到了 [What are the differences between mocha, chai, karma, jasmine, should.js, etc. testing frameworks?](http://stackoverflow.com/questions/24391462/what-are-the-differences-between-mocha-chai-karma-jasmine-should-js-etc-te) 这个问题。\n\n从回答中我们可以知道：*Karma* 只是一个 test runner，他负责提供 environment。而 *Jasmine* 和 *Mocha* 是编写测试脚本的框架。也就是说，我们可以选择 *Karma + Jasmine*或者 *Karma + Mocha*。我们不妨先选择前者~\n\n综上所述，**我们要使用 *Karma + Jasmine* 组合来为我们的 JavaScript 代码写测试**。\n\n## 战斗的号角\n接下来，我们根据文档（[karma - Installation](https://karma-runner.github.io/0.13/intro/installation.html), [karma - Configuration](https://karma-runner.github.io/0.13/intro/configuration.html) 和 [Jasmine - introduction](http://jasmine.github.io/2.0/introduction.html)），很容易就能搞起来。\n\n在这里我想说的是：当编写多个测试脚本的时候，你也许可以使用 `beforeEach` 和 `afterEach`。他们分别会在每个测试（spec）的之前和之后执行一次。\n\n## 副本\n最后还有一个问题是*如何结合 [Webpack](http://webpack.github.io/)* 来为我们的ES6代码编写测试。\n\n我不得不承认，这是一个很不错的问题。然而，我也通过google找到了答案。\n\n详细教程请看 *VueJS* 的 [Testing](https://vuejs.github.io/vue-loader/workflow/testing.html) 文档。\n\n## 战斗的荣耀\n你可以为你的仓库弄一个亮晶晶的 [travis ci status image](https://docs.travis-ci.com/user/status-images/)：\n\n![](https://travis-ci.org/travis-ci/travis-web.svg?branch=master)\n\n详细设置请查看 [travis docs](https://docs.travis-ci.com/user/getting-started/)以及这篇教程 [Testing JavaScript with Jasmine, Travis, and Karma](http://www.sitepoint.com/testing-javascript-jasmine-travis-karma/)。\n\n最后，如果还是不懂的话，可以查看我写的一个例子：[ES2015-Starter-Kit](https://github.com/DrakeLeung/ES2015-Starter-Kit/tree/master)\n\n## Resources\n- [JavaScript unit test tools for TDD](http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd)\n- [What are the differences between mocha, chai, karma, jasmine, should.js, etc. testing frameworks?](http://stackoverflow.com/questions/24391462/what-are-the-differences-between-mocha-chai-karma-jasmine-should-js-etc-te)\n- [vuejs - Testing](https://vuejs.github.io/vue-loader/workflow/testing.html)\n- [Testing JavaScript with Jasmine, Travis, and Karma](http://www.sitepoint.com/testing-javascript-jasmine-travis-karma/)\n","slug":"为你的JavaScript代码写测试","published":1,"updated":"2016-02-17T17:29:50.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon670008qore94k4xfcf"},{"title":"gulp in practice","author":"Drake Leung","date":"2015-06-10T17:47:58.000Z","foreword":"通过研究generator-gulp-webapp这个例子, 来实践一下gulp的各种用途.","_content":"\n我们研究的例子是[generator-gulp-webapp](https://github.com/yeoman/generator-gulp-webapp/blob/master/app%2Ftemplates%2Fgulpfile.js)的gulp recipe.\n\n## Getting Start\n假设我正在开发一个项目。首先，我要用`jade`来写一个页面。那么，我们就需要[gulp-jade](https://www.npmjs.com/package/gulp-jade)来帮助把`jade`解析为`HTML`。\n```javascript\nvar gulp = require('gulp'),\n $ = require('gulp-load-plugins')();\n\ngulp.task('views', function() {\n  gulp.src('app/views/index.jade')\n    .pipe($.plumber())\n    .pipe($.jade({\n        pretty: true\n    }))\n    .pipe(gulp.dest('.tmp'));\n});\n```\n `require`是什么？他可以外部的一个模块，类似`java`的import。[详情请看]()\n\n因为我们使用了[gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins)，他会读取`package.json`里面的`devDependencies`或者`dependencies`的内容来加载plugins。比如，这是我的`package.json`:\n```json\n{\n  \"devDependencies\": {\n    \"gulp-jade\": \"^1.0.1\"\n  }\n}\n```\n所以，我可以通过这样来加载`gulp-jade`模块\n```javascript\n $ = require('gulp-load-plugins')();\n $.jade();\n```\n否则的话，我就需要这样：\n```javascript\nvar jade = require('gulp-jade');\n```\n上面这种方法，如果插件多起来的话，就要写很多变量名。\n```javascript\nvar jade = require('..'),\n  sass = require('..'),\n  // ....\n  //...\n```\n\n然后，关于`gulp-jade`可以传哪些参数，可以看[docs](https://www.npmjs.com/package/gulp-jade#options)。\n\n最后，`$.plumber`是用来捕捉并处理错误的。\n\n## Next\n现在我想把bower_components里面的东西都inject到我的`index.jade`里面来，这样就不需要我手动写了。这个时候，我们需要用到[wiredep](https://github.com/taptapship/wiredep#gulpjs)\n```javascript\ngulp.task('wiredep', function() {\n  gulp.src('app/views/index.jade')\n    pipe(wiredep({\n        // options\n    }))\n    .pipe(gulp.dest('app/views/index.jade'));\n});\n```\n如果像上面那样式不够的，因为wiredep根本不知道要把bower_compoents里面的东西插到`index.jade`的什么位置，因此我们要指定placeholder.\n```jade\ndoctype html\n  head\n    meta(charset='utf-8')\n\n    // bower:css\n    // endbower\n\n  body\n    p Goodbye world\n\n    // bower:js\n    // endbower\n```\n`wiredep`会默认会读取`bower.json`默认的`bower_compponets`路径，接着找到每个component里面的`bower.json`里的`main`property。\n\n如果`main`里面没有指定相关的文件，`wiredep`是无法自动添加依赖到placeholder的。[docs - what can go wrong](https://github.com/taptapship/wiredep#what-can-go-wrong)\n\n举个例子：`semantic-ui`下的`bower.json`里的`main`没有指定他的CSS文件。\n```json\n{\n  \"main\": [\n    \"src/semantic.less\",\n    \"dist/semantic.js\"\n  ]\n}\n```\n所以你如果按照前面写的placeholder，你可以加载到`semantic,js`，但是无法添加`semantic.css`。因为我们上面的代码写的placeholder是要求css：\n```jade\ndoctype html\nhtml\n  head\n    meta(charset='utf-8')\n    title(My blog)\n\n    // bower:css\n    // endbower\n\n  body\n    p Goodbye world\n\n    // bower:js\n    script(src='../../bower_components/jquery/dist/jquery.js')\n    script(src='../../bower_components/semantic-ui/dist/semantic.js')\n    // endbower\n```\n也就是说，我们要手动添加我们想要的文件到`main`property里面去，比如`dist/semantic.css`\n```\n{\n  \"main\": [\n    \"src/semantic.less\",\n    \"dist/semantic.js\",\n    \"dist/semantic.css\"\n  ]\n}\n```\n### Issue\n假设我们已经执行了`wiredep`任务，相关的依赖已经添加到了`index.jade`。接下来就要执行`views`任务，把jade解析成`HTML`到`.tmp`目录下。\n```html\n<!-- .tmp/index.html -->\n\n<!-- omit some tag here -->\n<body>\n  <script src=\"../../bower_components/semantic-ui/dist/semantic.js\"></script>\n</body>\n```\n如果你足够细心的话，你会发现引入的semantic的**路径是不对的**。因为`.tmp`是在根目录下面的，而本来`index.jade`实在`app/views`下面的。\n正确的应该是这样：\n```html\n<body>\n  <script src=\"/bower_components/semantic-ui/dist/semantic.js\"></script>\n</body>\n```\n所以我们要在`wiredep`的时候就要忽略掉`../..`这个字符串。\n```javascript\ngulp.task('wiredep', function() {\n  gulp.src('app/views/index.jade')\n    pipe(wiredep({\n      ignorePath: /^(\\.\\.\\/)*\\.\\./  // 去掉../..\n    }))\n    .pipe(gulp.dest('app/views/index.jade'));\n});\n```\n\n## More\n话说，你不觉得这样引入多外部文件会不好吗？这样HTTP请求就变多了。所以，我们应该要把这些依赖都concatenate在同一个文件里面去。\n\n[gulp-assets](https://www.npmjs.com/package/gulp-useref)会把HTML的build block的引用的文件concatenate在一起。\n\n```javascript\ngulp.task('html', ['views'], function() {\n  var assets = $.useref.assets({searchPath: ['.tmp', 'app', '.']});\n\n  gulp.src(['.tmp/*.html'])\n    .pipe(assets)\n    .pipe($.if('*.js', $.uglify()))\n    .pipe($.if('*.css', $.csso()))\n    .pipe(assets.restore())\n    .pipe($.useref())\n    .pipe(gulp.dest('dist'));\n});\n```\n\n## End\n利用[gulp-subtree](https://github.com/Snugug/gulp-subtree)，把指定的目录提交奥到指定分支上面去。默认的分支是: `gh-page`。\n\n所以，我们只需要把`dist`目录发布到`gh-page`分支上，我们就可以通过`username.github.io/repo-name`来访问了。\n\n```javascript\ngulp.task('deploy', ['build'], function() {\n  eturn gulp.src('dist')\n    .pipe($.subtree())\n    .pipe($.clean());\n});\n```\n\n## Append: gulpfile.js\nhttps://gist.github.com/DrakeLeung/bd9132aa68b45c3c6794\n","source":"_posts/gulp-in-practice.md","raw":"title: gulp in practice\nauthor: Drake Leung\ndate: 2015-06-11 01:47:58\n\ntags: gulp\ncategories: FrontEnd\nforeword:\n  通过研究generator-gulp-webapp这个例子, 来实践一下gulp的各种用途.\n---\n\n我们研究的例子是[generator-gulp-webapp](https://github.com/yeoman/generator-gulp-webapp/blob/master/app%2Ftemplates%2Fgulpfile.js)的gulp recipe.\n\n## Getting Start\n假设我正在开发一个项目。首先，我要用`jade`来写一个页面。那么，我们就需要[gulp-jade](https://www.npmjs.com/package/gulp-jade)来帮助把`jade`解析为`HTML`。\n```javascript\nvar gulp = require('gulp'),\n $ = require('gulp-load-plugins')();\n\ngulp.task('views', function() {\n  gulp.src('app/views/index.jade')\n    .pipe($.plumber())\n    .pipe($.jade({\n        pretty: true\n    }))\n    .pipe(gulp.dest('.tmp'));\n});\n```\n `require`是什么？他可以外部的一个模块，类似`java`的import。[详情请看]()\n\n因为我们使用了[gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins)，他会读取`package.json`里面的`devDependencies`或者`dependencies`的内容来加载plugins。比如，这是我的`package.json`:\n```json\n{\n  \"devDependencies\": {\n    \"gulp-jade\": \"^1.0.1\"\n  }\n}\n```\n所以，我可以通过这样来加载`gulp-jade`模块\n```javascript\n $ = require('gulp-load-plugins')();\n $.jade();\n```\n否则的话，我就需要这样：\n```javascript\nvar jade = require('gulp-jade');\n```\n上面这种方法，如果插件多起来的话，就要写很多变量名。\n```javascript\nvar jade = require('..'),\n  sass = require('..'),\n  // ....\n  //...\n```\n\n然后，关于`gulp-jade`可以传哪些参数，可以看[docs](https://www.npmjs.com/package/gulp-jade#options)。\n\n最后，`$.plumber`是用来捕捉并处理错误的。\n\n## Next\n现在我想把bower_components里面的东西都inject到我的`index.jade`里面来，这样就不需要我手动写了。这个时候，我们需要用到[wiredep](https://github.com/taptapship/wiredep#gulpjs)\n```javascript\ngulp.task('wiredep', function() {\n  gulp.src('app/views/index.jade')\n    pipe(wiredep({\n        // options\n    }))\n    .pipe(gulp.dest('app/views/index.jade'));\n});\n```\n如果像上面那样式不够的，因为wiredep根本不知道要把bower_compoents里面的东西插到`index.jade`的什么位置，因此我们要指定placeholder.\n```jade\ndoctype html\n  head\n    meta(charset='utf-8')\n\n    // bower:css\n    // endbower\n\n  body\n    p Goodbye world\n\n    // bower:js\n    // endbower\n```\n`wiredep`会默认会读取`bower.json`默认的`bower_compponets`路径，接着找到每个component里面的`bower.json`里的`main`property。\n\n如果`main`里面没有指定相关的文件，`wiredep`是无法自动添加依赖到placeholder的。[docs - what can go wrong](https://github.com/taptapship/wiredep#what-can-go-wrong)\n\n举个例子：`semantic-ui`下的`bower.json`里的`main`没有指定他的CSS文件。\n```json\n{\n  \"main\": [\n    \"src/semantic.less\",\n    \"dist/semantic.js\"\n  ]\n}\n```\n所以你如果按照前面写的placeholder，你可以加载到`semantic,js`，但是无法添加`semantic.css`。因为我们上面的代码写的placeholder是要求css：\n```jade\ndoctype html\nhtml\n  head\n    meta(charset='utf-8')\n    title(My blog)\n\n    // bower:css\n    // endbower\n\n  body\n    p Goodbye world\n\n    // bower:js\n    script(src='../../bower_components/jquery/dist/jquery.js')\n    script(src='../../bower_components/semantic-ui/dist/semantic.js')\n    // endbower\n```\n也就是说，我们要手动添加我们想要的文件到`main`property里面去，比如`dist/semantic.css`\n```\n{\n  \"main\": [\n    \"src/semantic.less\",\n    \"dist/semantic.js\",\n    \"dist/semantic.css\"\n  ]\n}\n```\n### Issue\n假设我们已经执行了`wiredep`任务，相关的依赖已经添加到了`index.jade`。接下来就要执行`views`任务，把jade解析成`HTML`到`.tmp`目录下。\n```html\n<!-- .tmp/index.html -->\n\n<!-- omit some tag here -->\n<body>\n  <script src=\"../../bower_components/semantic-ui/dist/semantic.js\"></script>\n</body>\n```\n如果你足够细心的话，你会发现引入的semantic的**路径是不对的**。因为`.tmp`是在根目录下面的，而本来`index.jade`实在`app/views`下面的。\n正确的应该是这样：\n```html\n<body>\n  <script src=\"/bower_components/semantic-ui/dist/semantic.js\"></script>\n</body>\n```\n所以我们要在`wiredep`的时候就要忽略掉`../..`这个字符串。\n```javascript\ngulp.task('wiredep', function() {\n  gulp.src('app/views/index.jade')\n    pipe(wiredep({\n      ignorePath: /^(\\.\\.\\/)*\\.\\./  // 去掉../..\n    }))\n    .pipe(gulp.dest('app/views/index.jade'));\n});\n```\n\n## More\n话说，你不觉得这样引入多外部文件会不好吗？这样HTTP请求就变多了。所以，我们应该要把这些依赖都concatenate在同一个文件里面去。\n\n[gulp-assets](https://www.npmjs.com/package/gulp-useref)会把HTML的build block的引用的文件concatenate在一起。\n\n```javascript\ngulp.task('html', ['views'], function() {\n  var assets = $.useref.assets({searchPath: ['.tmp', 'app', '.']});\n\n  gulp.src(['.tmp/*.html'])\n    .pipe(assets)\n    .pipe($.if('*.js', $.uglify()))\n    .pipe($.if('*.css', $.csso()))\n    .pipe(assets.restore())\n    .pipe($.useref())\n    .pipe(gulp.dest('dist'));\n});\n```\n\n## End\n利用[gulp-subtree](https://github.com/Snugug/gulp-subtree)，把指定的目录提交奥到指定分支上面去。默认的分支是: `gh-page`。\n\n所以，我们只需要把`dist`目录发布到`gh-page`分支上，我们就可以通过`username.github.io/repo-name`来访问了。\n\n```javascript\ngulp.task('deploy', ['build'], function() {\n  eturn gulp.src('dist')\n    .pipe($.subtree())\n    .pipe($.clean());\n});\n```\n\n## Append: gulpfile.js\nhttps://gist.github.com/DrakeLeung/bd9132aa68b45c3c6794\n","slug":"gulp-in-practice","published":1,"updated":"2016-01-27T06:22:44.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon6k000dqore9rxx02ca"},{"title":"google chrome Devtools Overview","author":"Drake Leung","date":"2015-07-15T17:29:29.000Z","foreword":"学习google chrome DevTools的４个部分. 分别为Console, Elements, Network以及Sources.","_content":"\n官方文档: [Chrome DevTools](https://developer.chrome.com/devtools)\n## Console\n### Basic Operation\n- 打开: `Ctrl + Shift + J`\n- `Shift + Enter`可以换行，当你要写多行代码的时候。\n- 删除console history: `Ctrl + L`\n- drawer: 假设你在其他tab里面，想要看到`Console`tab的东西，就可以可以按`Esc`来显示drawer\n    ![](http://ww3.sinaimg.cn/large/7f85b91egw1eu3hckqtijj20rg0c8dj9.jpg)\n\n### Console API\n在DevTools里面定义了一个全局对象`console`。他有许多有用的API\n\n- 打印日志: `console.log(arg1, arg2)`。`.log()`可以有多个参数，`console.log('loved?', true)`\n\n- 打印错误日志: `console.error()`以及打印警告日志: `console.warn()`\n\n- 用CSS来style你的日志: `%c`作为指示，第2个参数写CSS。\n    ```javascript\n    console.log(\"%cThis will be formatted with large, blue text\", \"color: blue; font-size: x-large\");\n\n    console.log('%cBlue! %cRed!', 'color: blue;', 'color: red;');\n    ```\n  这样就可以在console里面写一些漂亮的彩蛋了。\n\n- 把DOM元素格式化为JavaScript对象: `console.dir()`, 如`console.dir(document)`\n\n- 测量时间: 传一个`string`作为给`.time()`作为开始，这个string就是time marker。结束\n的话就`timeEnd(string)`。string和前面的一样。\n    ```javascript\n    console.time(\"Array initialize\");\n        var array= new Array(1000000);\n        for (var i = array.length - 1; i >= 0; i--) {\n            array[i] = new Object();\n        };\n    console.timeEnd(\"Array initialize\");\n    ```\n\n### Command Line API\n- 自动补全: 比如输入`doc`就会有提示。如果是单个提示时，可以使用`tab`来补全。而多个时，按`↑`\n和`↓`进行选择，然后按`→`补全当前。\n\n- 选择元素: `$()`是`querySelector()`的简写，而`$$()`是`querySelectorAll()`\n\n- `$0~$4`保存了你在**Element tab**里面选择过的5个元素。\n\n## Network\n![](http://ww2.sinaimg.cn/large/7f85b91egw1eu3ifwyikzj20ov08i77o.jpg)\n\n- 可以检查你的文件路径有没有写对。\n- 直播下载网易云音乐的歌曲。\n\n## Elements\n对着你想要审查的元素，鼠标右击 -> Inspect Element。或者`Ctrl + Shift + C`.\n可以随便修改删除一些标签啊，比如去掉广告浮窗，或者这样啊，\n![](http://ww1.sinaimg.cn/large/7f85b91egw1eu3g2gwgaij20dh0a4aaz.jpg)\n\n- color picker: 按`shift` + click可以切换颜色的表示方法。\n- adding new CSS rules\n- toggle element state\n    ![](http://ww4.sinaimg.cn/large/7f85b91egw1eu3gx9r0ppj20dc01r0sp.jpg)\n\n## Sources\nSources tab可以查看你的文件。\n![](http://ww3.sinaimg.cn/large/7f85b91egw1eu392veow8j20uk0rm0vv.jpg)\n\n### debugging JavaScript with breakpoints\n\n1. 按`Ctrl + P`就可以搜索我们的文件，此时会调到**Sources tab**。接着`Ctrl + Shift + O`搜索函数名, `Ctrl + G`可以跳到任意一行，或者`Ctrl + Shift + F`在所有文件中搜索文本。\n\n    ![](http://ww2.sinaimg.cn/large/7f85b91egw1eu3fzown0oj20lo08bwgi.jpg)\n\n2. 单击**line gutter**就可以在该行设置一个breakpoint。然后你可以在右边的面板的**BreakPoints**\n找到所有设置过的breakpoint\n\n    ![](http://ww2.sinaimg.cn/large/7f85b91egw1eu39fv8s2gj20le0cd400.jpg)\n\n3. Control\n    - **Continue**: 继续执行，直到下一个breakpoint\n    - **Step over**: 下一行\n    - **Step into**: 跳进函数里面去\n    - **Step over**: 从函数里面跳出来\n    - **Toggle breakpoints**: 激活/不激活breakpoints\n\n\n4. 查看\n然后，我们就可以在**Scope Vraibles**那里查看你想要的变量。如果你有一直想看的变量，\n可以把他添加到**Watch Expressions**\n\n### Saving changes with workspaces\n把文件夹添加到workspace之后，你在DevTools上面修改的东西就会同步到实际的文件\n当中去。\n![](http://ww2.sinaimg.cn/large/7f85b91egw1eu3d1b12tsj20ve0bl77g.jpg)\n\n这样一来，DevTools就相当于一个编辑器了。\n","source":"_posts/google-chrome-Devtools-Overview.md","raw":"title: google chrome Devtools Overview\nauthor: Drake Leung\ntags: [google chrome, devtools]\ncategories: [Tools]\ndate: 2015-07-16 01:29:29\nforeword: 学习google chrome DevTools的４个部分. 分别为Console, Elements, Network以及Sources.\n---\n\n官方文档: [Chrome DevTools](https://developer.chrome.com/devtools)\n## Console\n### Basic Operation\n- 打开: `Ctrl + Shift + J`\n- `Shift + Enter`可以换行，当你要写多行代码的时候。\n- 删除console history: `Ctrl + L`\n- drawer: 假设你在其他tab里面，想要看到`Console`tab的东西，就可以可以按`Esc`来显示drawer\n    ![](http://ww3.sinaimg.cn/large/7f85b91egw1eu3hckqtijj20rg0c8dj9.jpg)\n\n### Console API\n在DevTools里面定义了一个全局对象`console`。他有许多有用的API\n\n- 打印日志: `console.log(arg1, arg2)`。`.log()`可以有多个参数，`console.log('loved?', true)`\n\n- 打印错误日志: `console.error()`以及打印警告日志: `console.warn()`\n\n- 用CSS来style你的日志: `%c`作为指示，第2个参数写CSS。\n    ```javascript\n    console.log(\"%cThis will be formatted with large, blue text\", \"color: blue; font-size: x-large\");\n\n    console.log('%cBlue! %cRed!', 'color: blue;', 'color: red;');\n    ```\n  这样就可以在console里面写一些漂亮的彩蛋了。\n\n- 把DOM元素格式化为JavaScript对象: `console.dir()`, 如`console.dir(document)`\n\n- 测量时间: 传一个`string`作为给`.time()`作为开始，这个string就是time marker。结束\n的话就`timeEnd(string)`。string和前面的一样。\n    ```javascript\n    console.time(\"Array initialize\");\n        var array= new Array(1000000);\n        for (var i = array.length - 1; i >= 0; i--) {\n            array[i] = new Object();\n        };\n    console.timeEnd(\"Array initialize\");\n    ```\n\n### Command Line API\n- 自动补全: 比如输入`doc`就会有提示。如果是单个提示时，可以使用`tab`来补全。而多个时，按`↑`\n和`↓`进行选择，然后按`→`补全当前。\n\n- 选择元素: `$()`是`querySelector()`的简写，而`$$()`是`querySelectorAll()`\n\n- `$0~$4`保存了你在**Element tab**里面选择过的5个元素。\n\n## Network\n![](http://ww2.sinaimg.cn/large/7f85b91egw1eu3ifwyikzj20ov08i77o.jpg)\n\n- 可以检查你的文件路径有没有写对。\n- 直播下载网易云音乐的歌曲。\n\n## Elements\n对着你想要审查的元素，鼠标右击 -> Inspect Element。或者`Ctrl + Shift + C`.\n可以随便修改删除一些标签啊，比如去掉广告浮窗，或者这样啊，\n![](http://ww1.sinaimg.cn/large/7f85b91egw1eu3g2gwgaij20dh0a4aaz.jpg)\n\n- color picker: 按`shift` + click可以切换颜色的表示方法。\n- adding new CSS rules\n- toggle element state\n    ![](http://ww4.sinaimg.cn/large/7f85b91egw1eu3gx9r0ppj20dc01r0sp.jpg)\n\n## Sources\nSources tab可以查看你的文件。\n![](http://ww3.sinaimg.cn/large/7f85b91egw1eu392veow8j20uk0rm0vv.jpg)\n\n### debugging JavaScript with breakpoints\n\n1. 按`Ctrl + P`就可以搜索我们的文件，此时会调到**Sources tab**。接着`Ctrl + Shift + O`搜索函数名, `Ctrl + G`可以跳到任意一行，或者`Ctrl + Shift + F`在所有文件中搜索文本。\n\n    ![](http://ww2.sinaimg.cn/large/7f85b91egw1eu3fzown0oj20lo08bwgi.jpg)\n\n2. 单击**line gutter**就可以在该行设置一个breakpoint。然后你可以在右边的面板的**BreakPoints**\n找到所有设置过的breakpoint\n\n    ![](http://ww2.sinaimg.cn/large/7f85b91egw1eu39fv8s2gj20le0cd400.jpg)\n\n3. Control\n    - **Continue**: 继续执行，直到下一个breakpoint\n    - **Step over**: 下一行\n    - **Step into**: 跳进函数里面去\n    - **Step over**: 从函数里面跳出来\n    - **Toggle breakpoints**: 激活/不激活breakpoints\n\n\n4. 查看\n然后，我们就可以在**Scope Vraibles**那里查看你想要的变量。如果你有一直想看的变量，\n可以把他添加到**Watch Expressions**\n\n### Saving changes with workspaces\n把文件夹添加到workspace之后，你在DevTools上面修改的东西就会同步到实际的文件\n当中去。\n![](http://ww2.sinaimg.cn/large/7f85b91egw1eu3d1b12tsj20ve0bl77g.jpg)\n\n这样一来，DevTools就相当于一个编辑器了。\n","slug":"google-chrome-Devtools-Overview","published":1,"updated":"2016-01-27T06:26:55.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon6r000iqore4ahje6w8"},{"title":"迷之前端轮子 - 实现一个简单的 Virtual DOM","author":"Drake Leung","date":"2016-01-31T05:30:49.000Z","foreword":"然而我并没有实现React Diff算法，因为不会= =","_content":"\n最近实现了一个简单版的[Virtual DOM](https://github.com/DrakeLeung/little-virtual-DOM)。\n之所以简单，是因为并没有实现React的diff算法，不过我们还是可以了解一下Virtual DOM。\n\n## What\n*Virtual DOM* 其实就是用JS对象去表示DOM元素。\n{% asset_img vdom0.png %}\n\n## Why\n为什么要Virtual DOM呢？因为DOM的操作本身是很慢的。但更慢的是批量操作时的不当。\n\n比如，我们要添加5个`<li>`：\n```javascript\nconst appendElement =\n  type =>\n    () =>\n      document.body.appendChild(document.createElement(type))\n\nArray.from(Array(5)).forEach(appendElement('li'))\n```\n上面每次生成一个`li`就插入，这样是很慢的。正确的做法应该是先生成5个`li`，然后再一次性把这个5个`li`插入。这个过程，我们就可以使用Virtual DOM来实现。\n\n## How\n总共分4个步骤，如下图所示：\n{% asset_img vdom2.png %}\n\n### VNode\n`VNode`这个函数是用JavaScript对象来表示DOM元素，比如：\n\n```html\n<li id=\"item1\">Call Me Item 1</li>\n```\n\n可以表示为:\n\n```javascript\n{\n  type: 'li',\n  props: {\n    id: 'item1'\n  },\n  children: ['item1']\n}\n```\n\n当然，`props`可以是数组，`children` 也可以放在`props`里面。\n\n### toHTML\n这个就是把`VNode`转化成真正的DOM元素。\n\n```javascript\n//\n// 大体分3步\n//\n\n// Step 1: createElement\nconst node = document.createElement(type)\n\n// Step 2: set props\nObject.keys(props).forEach(prop => {\n  node.setAttribute(prop, props[prop])\n})\n\n// Step 3: set children\nchildren.forEach(VChild => {\n  let childNode\n\n  // if text\n  if (typeof VChild === 'string') {  // #0\n    childNode = document.createTextNode(VChild)\n  } else {\n    childNode = createNode(VChild)\n  }\n\n  node.appendChild(childNode)\n})\n\nreturn node\n```\n在`#0`中，如果当前node是`string`的话，就表明是`text`。否则进行递归。\n\n### Diff\n`diff`需要把新的Virtual DOM和旧的进行比较，从而得到变化的地方。\n这个过程最难的了。我没用实现React的diff算法，只是对同级元素进行了比较而已。\n\n主要有不同的4种情况:\n```javascript\nexport const TEXT = 'TEXT'\nexport const PROPS = 'PROPS'\nexport const REPLACE = 'REPLACE'\nexport const ADD_CHILD = 'ADD_CHILD'\n```\n\n- `TEXT`: 替换旧的`text`\n- `PROPS`: 表明`props`可能是增加，删除或修改\n- `REPLACE`: 替换旧的节点，包括删除的\n- `ADD_CHILD`: 表示需要增加child\n\n实现过程不讲述，详细看源代码([diff](https://github.com/DrakeLeung/little-virtual-DOM/blob/master/src%2Fdiff.js))\n\n### Patch\n这个过程把上个步骤得到的`diff`来给当前的DOM节点进行操作。这个过程就是我们优化DOM操作的地方。\n\n```javascript\nconst applyPatch = (node, currentPatch) => {\n  switch (currentPatch.type) {\n    case patchType.TEXT:\n      node.nodeValue = currentPatch.content\n      break\n\n    case patchType.PROPS:\n      setProps(node, currentPatch.props)\n      break\n\n    case patchType.REPLACE:\n      if (isExist(currentPatch.node)) {\n        node.parentNode.replaceChild(toHTML(currentPatch.node), node)\n      } else {\n        node.parentNode.removeChild(node)\n      }\n      break\n\n    case patchType.ADD_CHILD:\n      node.appendChild(toHTML(currentPatch.node))\n      break\n\n    default:\n  }\n}\n```\n\n## Wrap up\n从实现这个简单的Virtual DOM，思路确实是打开了不少。\n\n- 用JavaScript对象来表示DOM元素。之前只会直接操作DOM，没有想到可以这样玩。\n- 怎么比较2棵树的不同？只需要比较同级的元素。虽然还是不会比较children\n- 复习了DOM的一些知识。\n\n所以**多尝试**不同的东西，思路会扩展不少~\n\n## Resource\n- [React (Virtual) DOM Terminology](https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589)\n- [Understanding-react-and-reimplementing-it-from-scratch-part-1](https://gcanti.github.io/2014/10/29/understanding-react-and-reimplementing-it-from-scratch-part-1.html)\n- [怎么更好地理解虚拟DOM](https://www.zhihu.com/question/29504639)\n- [如何实现一个Virtual DOM算法](https://github.com/livoras/blog/issues/13)\n","source":"_posts/Virtual-DOM.md","raw":"---\ntitle: 迷之前端轮子 - 实现一个简单的 Virtual DOM\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-01-31 13:30:49\nforeword: 然而我并没有实现React Diff算法，因为不会= =\n---\n\n最近实现了一个简单版的[Virtual DOM](https://github.com/DrakeLeung/little-virtual-DOM)。\n之所以简单，是因为并没有实现React的diff算法，不过我们还是可以了解一下Virtual DOM。\n\n## What\n*Virtual DOM* 其实就是用JS对象去表示DOM元素。\n{% asset_img vdom0.png %}\n\n## Why\n为什么要Virtual DOM呢？因为DOM的操作本身是很慢的。但更慢的是批量操作时的不当。\n\n比如，我们要添加5个`<li>`：\n```javascript\nconst appendElement =\n  type =>\n    () =>\n      document.body.appendChild(document.createElement(type))\n\nArray.from(Array(5)).forEach(appendElement('li'))\n```\n上面每次生成一个`li`就插入，这样是很慢的。正确的做法应该是先生成5个`li`，然后再一次性把这个5个`li`插入。这个过程，我们就可以使用Virtual DOM来实现。\n\n## How\n总共分4个步骤，如下图所示：\n{% asset_img vdom2.png %}\n\n### VNode\n`VNode`这个函数是用JavaScript对象来表示DOM元素，比如：\n\n```html\n<li id=\"item1\">Call Me Item 1</li>\n```\n\n可以表示为:\n\n```javascript\n{\n  type: 'li',\n  props: {\n    id: 'item1'\n  },\n  children: ['item1']\n}\n```\n\n当然，`props`可以是数组，`children` 也可以放在`props`里面。\n\n### toHTML\n这个就是把`VNode`转化成真正的DOM元素。\n\n```javascript\n//\n// 大体分3步\n//\n\n// Step 1: createElement\nconst node = document.createElement(type)\n\n// Step 2: set props\nObject.keys(props).forEach(prop => {\n  node.setAttribute(prop, props[prop])\n})\n\n// Step 3: set children\nchildren.forEach(VChild => {\n  let childNode\n\n  // if text\n  if (typeof VChild === 'string') {  // #0\n    childNode = document.createTextNode(VChild)\n  } else {\n    childNode = createNode(VChild)\n  }\n\n  node.appendChild(childNode)\n})\n\nreturn node\n```\n在`#0`中，如果当前node是`string`的话，就表明是`text`。否则进行递归。\n\n### Diff\n`diff`需要把新的Virtual DOM和旧的进行比较，从而得到变化的地方。\n这个过程最难的了。我没用实现React的diff算法，只是对同级元素进行了比较而已。\n\n主要有不同的4种情况:\n```javascript\nexport const TEXT = 'TEXT'\nexport const PROPS = 'PROPS'\nexport const REPLACE = 'REPLACE'\nexport const ADD_CHILD = 'ADD_CHILD'\n```\n\n- `TEXT`: 替换旧的`text`\n- `PROPS`: 表明`props`可能是增加，删除或修改\n- `REPLACE`: 替换旧的节点，包括删除的\n- `ADD_CHILD`: 表示需要增加child\n\n实现过程不讲述，详细看源代码([diff](https://github.com/DrakeLeung/little-virtual-DOM/blob/master/src%2Fdiff.js))\n\n### Patch\n这个过程把上个步骤得到的`diff`来给当前的DOM节点进行操作。这个过程就是我们优化DOM操作的地方。\n\n```javascript\nconst applyPatch = (node, currentPatch) => {\n  switch (currentPatch.type) {\n    case patchType.TEXT:\n      node.nodeValue = currentPatch.content\n      break\n\n    case patchType.PROPS:\n      setProps(node, currentPatch.props)\n      break\n\n    case patchType.REPLACE:\n      if (isExist(currentPatch.node)) {\n        node.parentNode.replaceChild(toHTML(currentPatch.node), node)\n      } else {\n        node.parentNode.removeChild(node)\n      }\n      break\n\n    case patchType.ADD_CHILD:\n      node.appendChild(toHTML(currentPatch.node))\n      break\n\n    default:\n  }\n}\n```\n\n## Wrap up\n从实现这个简单的Virtual DOM，思路确实是打开了不少。\n\n- 用JavaScript对象来表示DOM元素。之前只会直接操作DOM，没有想到可以这样玩。\n- 怎么比较2棵树的不同？只需要比较同级的元素。虽然还是不会比较children\n- 复习了DOM的一些知识。\n\n所以**多尝试**不同的东西，思路会扩展不少~\n\n## Resource\n- [React (Virtual) DOM Terminology](https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589)\n- [Understanding-react-and-reimplementing-it-from-scratch-part-1](https://gcanti.github.io/2014/10/29/understanding-react-and-reimplementing-it-from-scratch-part-1.html)\n- [怎么更好地理解虚拟DOM](https://www.zhihu.com/question/29504639)\n- [如何实现一个Virtual DOM算法](https://github.com/livoras/blog/issues/13)\n","slug":"Virtual-DOM","published":1,"updated":"2016-02-06T12:59:54.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon6y000pqorezebn9lz8"},{"title":"Scope(3)-What Is Closure","author":"Drake Leung","date":"2015-07-18T17:58:31.000Z","foreword":"闭包其实很简单，只要你想通了lexical scope就迎刃而解了。","_content":"\n## What is Closure\n什么是闭包呢？我们来下个定义吧。\n\n> 闭包就是函数可以访问他的lexical scope，即使他是在他的lexical scope外面执行的。\n\n先看个例子压压惊。\n\n```javascript\nfunction foo() {\n    var x = 42;\n\n    function bar () {\n      console.log(x);\n    }\n    bar();\n}\n\nfoo(); // 42\n```\n很自然而然地，上面例子输出的结果就是`42`。为什么呢？这其实就是作用域链的问题而已。\n`bar`函数要引用到`x`这个变量的值。于是就在自己的作用域找，找不到。于是向上找，然后在`foo`函数的作用域就找到了。\n\n很显然，上面的例子是符合我们对闭包定义的前半部分，**但是后半部分是不符合的**。因为`bar`的lexical scope就是`foo`的作用域，而`bar`就是在`foo`的作用域里面被调用的。\n\n## How it Works\n\n既然这样，我们就想办法让`bar`在`foo`的作用域外面执行。比如使用`return`.\n```javascript\nfunction foo() {\n  var x = 42;\n\n  function bar() {\n    console.log(x);\n  }\n\n  return bar;\n}\n\nvar baz = foo();\nbaz();\n```\n在上面的例子中，其实`baz`就是`bar`，只是名字换了而已，内容还是没有改变的。那么好，现在，`bar`(也就是`baz`)并不是在他的lexical scope(`foo`'s scope)被调用，而是在global scope。并且，`bar`还可以访问他的lexical scope里面的`x`。所以，你可以说，**这就是闭包**。\n\n我们再来看1个例子:\n```javascript\nfunction baz(fn) {\n  fn();\n}\n\nfunction foo() {\n  var x = 42;\n  function bar() {\n    console.log(x);\n  }\n\n  baz(bar);\n}\n\nfoo();\n```\n同样地，上面的例子中，`bar`并没有在他的lexical scope(`foo`'s scope)中执行，而在是`baz`里面执行。并且，`bar`还是可以访问他的lexical scope。因此，这个也是闭包！\n\n## More Examples\n其实，闭包到处都是~\n\n比如，一个定时器。\n```javascript\nfunction wait(msg) {\n  setTimeout(function timer() {\n    console.log(msg);\n  }, 2 * 1000);\n}\nwait('I am also a closure example');\n```\n2秒钟之后，浏览器引擎就会在全局中调用`timer`函数。也就是说，`timer`并没有在他的lexical scope(`wait`'s scope)里面执行，但是他仍然可以访问`msg`。所以，这个也是一个闭包。\n\n再比如，一个Event Handler.\n```javascript\nfunction submit() {\n  var username = 'Drake',\n    submitBtn = document.querySelector('button[type=submit]');\n\n  submitBtn.addEventListener('click', function(event) {\n    console.log(username);\n  }, false);\n}\n```\n## Loops and Closure\n当闭包出现在循环中的时候，就会很容易出现问题。举个例子，\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function timer() {\n    console.log(i);\n  }, 1000);\n}\n```\n上面例子中，很出乎意料地输出了5个`5`。为什么呢？原因在于:\n\n1. 在第一个`timer`函数执行之前，已经有5个`timer`函数定义好了。\n2. 当第一个`timer`执行时，他需要引用到`i`。\n3. 首先他在自己的作用域找，找不到。\n4. 于是向上找，因为JavaScript并没有block scope。所以向上的话就是global scope.\n5. 在global scope里面找到了`i`。此时`i`为`5`（因为已经循环了5次)\n\n是不是觉得少了点什么？如果`timer`在自己的作用域就可以找到`i`的话就好咯。或者，在中间加多一层作用域，而不用去到`global scope`里面找（因为他的`i`一定是为`5`的)\n\n### Solution\n第一种，`timer`在自己的作用域就可以找到`i`。可以利用`forEach`等循环方法。\n```javascript\nvar aArray = ['a', 'b', 'c', 'd', 'e'];\n\naArray.forEach(function(item, index, array) {\n  setTimeout(function timer() {\n    console.log(index);\n  });\n});\n```\n\n第二种，在中间新增一层作用域。常用的pattern就是使用IIFE。\n```javascript\nfor (var i = 0; i < 5; i++) {\n  (function(j) {\n    setTimeout(function timer() {\n      console.log(j);\n    });\n  })(i);\n}\n```\n由于IIFE是立即调用的，所以每次调用的时候都传进了不同的实参。\n\n1. 当`timer`要引用`i`的时候，现在自己的作用域里面找。找不到。\n2. 然后向上找，在IIFE里面找到了，也就是形参`j`。\n\n\n第三种利用`let`来创建block scope.\n```javascript\nfor (let i = 0; i < 5; i++) {\n  setTimeout(function timer() {\n    console.log(i);\n  });\n}\n```\n`let`劫持了`for`的作用域。每次循环，都会初始化一个新的`i`。\n\n`timer`在自己的作用域找不到`i`,向上找，在`for`里面找，哈，找到了。\n","source":"_posts/Scope-3-What-Is-Closure.md","raw":"title: Scope(3)-What Is Closure\nauthor: Drake Leung\ntags: [scope, closure]\ncategories: [JavaScript]\ndate: 2015-07-19 01:58:31\nforeword: 闭包其实很简单，只要你想通了lexical scope就迎刃而解了。\n---\n\n## What is Closure\n什么是闭包呢？我们来下个定义吧。\n\n> 闭包就是函数可以访问他的lexical scope，即使他是在他的lexical scope外面执行的。\n\n先看个例子压压惊。\n\n```javascript\nfunction foo() {\n    var x = 42;\n\n    function bar () {\n      console.log(x);\n    }\n    bar();\n}\n\nfoo(); // 42\n```\n很自然而然地，上面例子输出的结果就是`42`。为什么呢？这其实就是作用域链的问题而已。\n`bar`函数要引用到`x`这个变量的值。于是就在自己的作用域找，找不到。于是向上找，然后在`foo`函数的作用域就找到了。\n\n很显然，上面的例子是符合我们对闭包定义的前半部分，**但是后半部分是不符合的**。因为`bar`的lexical scope就是`foo`的作用域，而`bar`就是在`foo`的作用域里面被调用的。\n\n## How it Works\n\n既然这样，我们就想办法让`bar`在`foo`的作用域外面执行。比如使用`return`.\n```javascript\nfunction foo() {\n  var x = 42;\n\n  function bar() {\n    console.log(x);\n  }\n\n  return bar;\n}\n\nvar baz = foo();\nbaz();\n```\n在上面的例子中，其实`baz`就是`bar`，只是名字换了而已，内容还是没有改变的。那么好，现在，`bar`(也就是`baz`)并不是在他的lexical scope(`foo`'s scope)被调用，而是在global scope。并且，`bar`还可以访问他的lexical scope里面的`x`。所以，你可以说，**这就是闭包**。\n\n我们再来看1个例子:\n```javascript\nfunction baz(fn) {\n  fn();\n}\n\nfunction foo() {\n  var x = 42;\n  function bar() {\n    console.log(x);\n  }\n\n  baz(bar);\n}\n\nfoo();\n```\n同样地，上面的例子中，`bar`并没有在他的lexical scope(`foo`'s scope)中执行，而在是`baz`里面执行。并且，`bar`还是可以访问他的lexical scope。因此，这个也是闭包！\n\n## More Examples\n其实，闭包到处都是~\n\n比如，一个定时器。\n```javascript\nfunction wait(msg) {\n  setTimeout(function timer() {\n    console.log(msg);\n  }, 2 * 1000);\n}\nwait('I am also a closure example');\n```\n2秒钟之后，浏览器引擎就会在全局中调用`timer`函数。也就是说，`timer`并没有在他的lexical scope(`wait`'s scope)里面执行，但是他仍然可以访问`msg`。所以，这个也是一个闭包。\n\n再比如，一个Event Handler.\n```javascript\nfunction submit() {\n  var username = 'Drake',\n    submitBtn = document.querySelector('button[type=submit]');\n\n  submitBtn.addEventListener('click', function(event) {\n    console.log(username);\n  }, false);\n}\n```\n## Loops and Closure\n当闭包出现在循环中的时候，就会很容易出现问题。举个例子，\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function timer() {\n    console.log(i);\n  }, 1000);\n}\n```\n上面例子中，很出乎意料地输出了5个`5`。为什么呢？原因在于:\n\n1. 在第一个`timer`函数执行之前，已经有5个`timer`函数定义好了。\n2. 当第一个`timer`执行时，他需要引用到`i`。\n3. 首先他在自己的作用域找，找不到。\n4. 于是向上找，因为JavaScript并没有block scope。所以向上的话就是global scope.\n5. 在global scope里面找到了`i`。此时`i`为`5`（因为已经循环了5次)\n\n是不是觉得少了点什么？如果`timer`在自己的作用域就可以找到`i`的话就好咯。或者，在中间加多一层作用域，而不用去到`global scope`里面找（因为他的`i`一定是为`5`的)\n\n### Solution\n第一种，`timer`在自己的作用域就可以找到`i`。可以利用`forEach`等循环方法。\n```javascript\nvar aArray = ['a', 'b', 'c', 'd', 'e'];\n\naArray.forEach(function(item, index, array) {\n  setTimeout(function timer() {\n    console.log(index);\n  });\n});\n```\n\n第二种，在中间新增一层作用域。常用的pattern就是使用IIFE。\n```javascript\nfor (var i = 0; i < 5; i++) {\n  (function(j) {\n    setTimeout(function timer() {\n      console.log(j);\n    });\n  })(i);\n}\n```\n由于IIFE是立即调用的，所以每次调用的时候都传进了不同的实参。\n\n1. 当`timer`要引用`i`的时候，现在自己的作用域里面找。找不到。\n2. 然后向上找，在IIFE里面找到了，也就是形参`j`。\n\n\n第三种利用`let`来创建block scope.\n```javascript\nfor (let i = 0; i < 5; i++) {\n  setTimeout(function timer() {\n    console.log(i);\n  });\n}\n```\n`let`劫持了`for`的作用域。每次循环，都会初始化一个新的`i`。\n\n`timer`在自己的作用域找不到`i`,向上找，在`for`里面找，哈，找到了。\n","slug":"Scope-3-What-Is-Closure","published":1,"updated":"2016-01-27T06:27:20.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon7g000qqoref9yq1qtz"},{"title":"Scope(2)-Lexical Scope & Dynamical Scope","author":"Drake Leung","date":"2015-07-18T15:52:57.000Z","foreword":"通过Lexical scope(静态作用域)以及Dynamical socpe(动态)做比较，了解JavaScript的作用域。","_content":"\n我们先来看一个例子:\n\n```javascript\nfunction foo() {\n  var x = 42;\n\n  function bar() {\n     console.log(x);\n  }\n  bar();\n}\n\nfoo(); // 42\n```\n结果并没有出乎我们的意料，就是`42`。为什么呢？`bar`函数执行的时候，要引用到`baz`的值，那么去哪里找？首先在自己的作用域里面找。噢，一下就找到了，原来是`42`。\n\n上面这种就是**lexical scope**(或者**static scope**)。\n\n## What is Lexical Scope\n**lexical scope取决于函数是在哪里被定义的**.\n\n在上面的例子中，`bar`被定义在`foo`里面，所以`foo`的作用域就是`bar`的lexical scope. 然后，`foo`是被定义在global里面的，所以他的lexical scope就是*global scope*.\n\n所以在lexical scope中，查找`x`的过程如下，\n\n1. 我们要执行`bar`函数，他要引用`x`的值。\n2. 那么去哪里找`x`呢？肯定是先去自己(`bar`)的作用域找。但找不到:(\n3. 接着去他的lexical scope找（也就是`foo`的作用域), 找到了，`x`是42.\n\n是不是有点是懂非懂的样子，我们再来看看dynamical scope，做一下比较就知道了。\n\n## What is Dynamical Scope\n**dynamical Scope是取决于函数是在哪里被调用的**。\n\n看一个例子:\n\n```javascript\nvar x = 0;\n\nfunction bar() {\n  console.log(x);\n}\n\nfunction foo() {\n  var x = 42;\n  bar();\n}\n\nfoo(); // 42\n```\n\n在上面的例子中，由于`bar`是在`foo`里面被调用的，所以`bar`的dynamical socpe就是`foo`的作用域。而`foo`是在global socpe里面被调用的，所以global scope是`foo`的dynamical scope.\n\n所以在dynamical scope中，`x`的查找过程是:\n\n1. `bar`被调用，他要引用`x`的值。\n2. 那么去哪里找`x`呢？首先，肯定是在自己的作用域里面找，但是找不到:(\n3. 看看是谁调用`bar`的，就去那里找。OK, 是`foo`。那么，我们就去`foo`的作用域找。\n4. 噢，找到了。`x`是`42`.\n\n## Summary\n总的来说，lexical scope是取决于函数是在哪里被定义的。而dynamical scope是取决于函数是哪里被调用的。\n\n而JavaScript的**name resolution**(查找变量或者函数的过程)是采用lexical scope的。但是JavaScript的`this`的值却跟dynamical scope很像。我们以后会再讲`this`。\n\n## Resources\n- [Dynamical Scope](http://c2.com/cgi/wiki?DynamicScoping)前面的解释部分。\n","source":"_posts/Scope-2-Lexical-Scope-Dynamical-Scope.md","raw":"title: 'Scope(2)-Lexical Scope & Dynamical Scope'\nauthor: Drake Leung\ntags: [scope]\ncategories: [JavaScript]\ndate: 2015-07-18 23:52:57\nforeword: 通过Lexical scope(静态作用域)以及Dynamical socpe(动态)做比较，了解JavaScript的作用域。\n---\n\n我们先来看一个例子:\n\n```javascript\nfunction foo() {\n  var x = 42;\n\n  function bar() {\n     console.log(x);\n  }\n  bar();\n}\n\nfoo(); // 42\n```\n结果并没有出乎我们的意料，就是`42`。为什么呢？`bar`函数执行的时候，要引用到`baz`的值，那么去哪里找？首先在自己的作用域里面找。噢，一下就找到了，原来是`42`。\n\n上面这种就是**lexical scope**(或者**static scope**)。\n\n## What is Lexical Scope\n**lexical scope取决于函数是在哪里被定义的**.\n\n在上面的例子中，`bar`被定义在`foo`里面，所以`foo`的作用域就是`bar`的lexical scope. 然后，`foo`是被定义在global里面的，所以他的lexical scope就是*global scope*.\n\n所以在lexical scope中，查找`x`的过程如下，\n\n1. 我们要执行`bar`函数，他要引用`x`的值。\n2. 那么去哪里找`x`呢？肯定是先去自己(`bar`)的作用域找。但找不到:(\n3. 接着去他的lexical scope找（也就是`foo`的作用域), 找到了，`x`是42.\n\n是不是有点是懂非懂的样子，我们再来看看dynamical scope，做一下比较就知道了。\n\n## What is Dynamical Scope\n**dynamical Scope是取决于函数是在哪里被调用的**。\n\n看一个例子:\n\n```javascript\nvar x = 0;\n\nfunction bar() {\n  console.log(x);\n}\n\nfunction foo() {\n  var x = 42;\n  bar();\n}\n\nfoo(); // 42\n```\n\n在上面的例子中，由于`bar`是在`foo`里面被调用的，所以`bar`的dynamical socpe就是`foo`的作用域。而`foo`是在global socpe里面被调用的，所以global scope是`foo`的dynamical scope.\n\n所以在dynamical scope中，`x`的查找过程是:\n\n1. `bar`被调用，他要引用`x`的值。\n2. 那么去哪里找`x`呢？首先，肯定是在自己的作用域里面找，但是找不到:(\n3. 看看是谁调用`bar`的，就去那里找。OK, 是`foo`。那么，我们就去`foo`的作用域找。\n4. 噢，找到了。`x`是`42`.\n\n## Summary\n总的来说，lexical scope是取决于函数是在哪里被定义的。而dynamical scope是取决于函数是哪里被调用的。\n\n而JavaScript的**name resolution**(查找变量或者函数的过程)是采用lexical scope的。但是JavaScript的`this`的值却跟dynamical scope很像。我们以后会再讲`this`。\n\n## Resources\n- [Dynamical Scope](http://c2.com/cgi/wiki?DynamicScoping)前面的解释部分。\n","slug":"Scope-2-Lexical-Scope-Dynamical-Scope","published":1,"updated":"2016-01-27T06:27:56.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon7q000xqoreq0bo6t6k"},{"title":"Scope(1) - Nested Scope","author":"Drake Leung","date":"2015-07-09T10:24:19.000Z","foreword":"scope系列的第2篇, 主题是嵌套作用域, 有block scope, function scope等等.","thumbnail":"images/js.png","_content":"\n## What\n*nested scope*就是所谓的嵌套作用域, 顾名思义就是作用域之间具有嵌套的关系.  \n那么, 为什么我们需要的nested scope呢?\n\n## Why\n我们做出一下的假设:\n\n> 从头到尾只有一个socpe, 没有什么多个, 也没有什么嵌套关系.\n\n这样的话, 我们所有的变量声明, 函数声明都会放到这个**唯一的scope**里面去. 那么, 当数量变大的时候, 程序的性能就会降低. 比如我们要在茫茫变量中找出一个小小的变量, 这性能不就降低了吗?\n\n为了改进他, 我们又做出了以下的假设:\n\n> 其实不止一个socpe, 可以有多个scope. 但是scope之间美柚嵌套关系.\n\n很容易看出, 这次的假设比第一次的好多了. 但是问题又来了, 如果2个scope所存放的变量有很多是相同的, 既然是相同的, 那么我们很容易就想到要**复用**他们. 怎么复用呢? 这个时候, 我们就给这些需要复用的scope加上一次嵌套关系:\n\n> 外部的scope嵌套着内部的scope, 内部的scope可以使用外部的scope的变量, 但反之不行!\n\n这样以来, 我们就可以不同scope之间就可以共用相同的变量. 这是极好的~  \n但是, 我们要怎样才可以创建出多个scope呢?\n\n## How\n在JavaScript中, 有3种不同的scope. 分别是**global scope**, **block scope**以及**function scope**.\n\n### Global Scope\nglobal scope(全局作用域)是不需要创建的, 只要你执行JavaScript文件的话, 他就被自动创建.\n\n他是最外层的scope. 也就是说, 他可以嵌套其他作用域, 不可以被其他scope嵌套.\n\n在浏览器环境下, global scope可以看做为`window`这个对象.\n\n### Block Scope\nblock scope(块级作用域)指的是用`{}`(大括号)创建一个scope. 也就是说, `{}`内的变量定义和声明都是属于这个`{}`所创建的scope.\n\n在ES6中, 我们可以使用`let`这个keyword来实现\n\n```javascript\n{\n  let foo = 2;\n  console.log(foo); // 2\n}\nconsole.log(foo); // Reference Error\n```\n\n但是, 在ES6之前呢? 我们要怎样才能创建一个block scope呢? 一个trick就是使用`try-catch`.\n```javascript\ntry {\n  throw 2;\n} catch (foo) {\n  console.log(foo); // 2\n}\nconsole.log(foo);  // Error\n```\n在上面的例子中, `foo`这个keyword只能在`catch`块里面使用. 但是, 这种写法也太丑了. 因此, 在ES6之前可以说是没有block scope的.\n\n## Function Scope\n当执行一个函数的时候, 就会创建一个属于这个函数的作用域. 当执行完这个函数之后, 理论上这个作用域是会被垃圾回收器回收的.\n\n```javascript\nfunction foo () {\n  var a = 42;\n\n  function bar () {\n    console.log(a);\n  }\n}\n```\n在上面的例子中, 一个有3个scope. 分别是global scope > foo > bar(`>`表示嵌套关系).  \nEngine和各个scope之间的对话.\n\nEngine: 你好`bar scope`, 我想要一个`a`的RHS, 请问你有吗?  \nbar scope: 不好意思, 我没有. 你可以去问问我的外层作用域foo scope.  \nEngine: 你好`foo scope`, 请问你有见过`a`吗?  \nfoo scope: 当然! 这就给你.\nEngine: 那太好了. 既然找到的话, 我就不需要再向上层的作用域找了.  \n\n从上面的对话中, 我们可以很容易知道: 当要查找一个变量的时候, 首先会在当前所在的作用域寻找, 如果没有找到的话, 就向上找, 直到global scope. 这个过程其实就叫做**identifier resolution**(或者identifier look-up).\n\n接下来, 我们再来优化一下上面的例子. 例子中的`bar`函数只是为了打印一个`a`, 我们以后再也不会引用到`bar`这个变量名. 但这个变量却污染了foo scope. 有没有办法既可以打印`a`又可以不创建一个变量名呢? 答案就是利用**IIFE**(Immediately invoked function express).\n```javascript\nfunction foo () {\n  var a = 42;\n\n  (function () {\n    console.log(a);\n  })();\n}\n```\n首先, 用`()`包住整个function body就表明了这个是一个expression, 接着用`()`来调用这个function expression.\n对于IIFE还有其他写法, 你可以选择自己喜欢的口味~\n\nIIFE是很常见的, 因为他在调用一个函数的同时也**避免了作用域的污染**. 这是非常值得我们学习的.\n\n## Summary\n总的来说, nested scope是为了可以共用作用域而产生的, 也就是说内部的scope可以访问外部scope. 而JavaScript有3种作用域global scope, block scope以及function scope. 其中, function scope是最主要的, 并且要懂得其中的IIFE.\n","source":"_posts/Scope-1-Nested-Scope.md","raw":"title: Scope(1) - Nested Scope\nauthor: Drake Leung\ndate: 2015-07-09 18:24:19\ntags: [scope, 作用域]\ncategories: JavaScript\nforeword:\n  scope系列的第2篇, 主题是嵌套作用域, 有block scope, function scope等等.\nthumbnail: images/js.png\n---\n\n## What\n*nested scope*就是所谓的嵌套作用域, 顾名思义就是作用域之间具有嵌套的关系.  \n那么, 为什么我们需要的nested scope呢?\n\n## Why\n我们做出一下的假设:\n\n> 从头到尾只有一个socpe, 没有什么多个, 也没有什么嵌套关系.\n\n这样的话, 我们所有的变量声明, 函数声明都会放到这个**唯一的scope**里面去. 那么, 当数量变大的时候, 程序的性能就会降低. 比如我们要在茫茫变量中找出一个小小的变量, 这性能不就降低了吗?\n\n为了改进他, 我们又做出了以下的假设:\n\n> 其实不止一个socpe, 可以有多个scope. 但是scope之间美柚嵌套关系.\n\n很容易看出, 这次的假设比第一次的好多了. 但是问题又来了, 如果2个scope所存放的变量有很多是相同的, 既然是相同的, 那么我们很容易就想到要**复用**他们. 怎么复用呢? 这个时候, 我们就给这些需要复用的scope加上一次嵌套关系:\n\n> 外部的scope嵌套着内部的scope, 内部的scope可以使用外部的scope的变量, 但反之不行!\n\n这样以来, 我们就可以不同scope之间就可以共用相同的变量. 这是极好的~  \n但是, 我们要怎样才可以创建出多个scope呢?\n\n## How\n在JavaScript中, 有3种不同的scope. 分别是**global scope**, **block scope**以及**function scope**.\n\n### Global Scope\nglobal scope(全局作用域)是不需要创建的, 只要你执行JavaScript文件的话, 他就被自动创建.\n\n他是最外层的scope. 也就是说, 他可以嵌套其他作用域, 不可以被其他scope嵌套.\n\n在浏览器环境下, global scope可以看做为`window`这个对象.\n\n### Block Scope\nblock scope(块级作用域)指的是用`{}`(大括号)创建一个scope. 也就是说, `{}`内的变量定义和声明都是属于这个`{}`所创建的scope.\n\n在ES6中, 我们可以使用`let`这个keyword来实现\n\n```javascript\n{\n  let foo = 2;\n  console.log(foo); // 2\n}\nconsole.log(foo); // Reference Error\n```\n\n但是, 在ES6之前呢? 我们要怎样才能创建一个block scope呢? 一个trick就是使用`try-catch`.\n```javascript\ntry {\n  throw 2;\n} catch (foo) {\n  console.log(foo); // 2\n}\nconsole.log(foo);  // Error\n```\n在上面的例子中, `foo`这个keyword只能在`catch`块里面使用. 但是, 这种写法也太丑了. 因此, 在ES6之前可以说是没有block scope的.\n\n## Function Scope\n当执行一个函数的时候, 就会创建一个属于这个函数的作用域. 当执行完这个函数之后, 理论上这个作用域是会被垃圾回收器回收的.\n\n```javascript\nfunction foo () {\n  var a = 42;\n\n  function bar () {\n    console.log(a);\n  }\n}\n```\n在上面的例子中, 一个有3个scope. 分别是global scope > foo > bar(`>`表示嵌套关系).  \nEngine和各个scope之间的对话.\n\nEngine: 你好`bar scope`, 我想要一个`a`的RHS, 请问你有吗?  \nbar scope: 不好意思, 我没有. 你可以去问问我的外层作用域foo scope.  \nEngine: 你好`foo scope`, 请问你有见过`a`吗?  \nfoo scope: 当然! 这就给你.\nEngine: 那太好了. 既然找到的话, 我就不需要再向上层的作用域找了.  \n\n从上面的对话中, 我们可以很容易知道: 当要查找一个变量的时候, 首先会在当前所在的作用域寻找, 如果没有找到的话, 就向上找, 直到global scope. 这个过程其实就叫做**identifier resolution**(或者identifier look-up).\n\n接下来, 我们再来优化一下上面的例子. 例子中的`bar`函数只是为了打印一个`a`, 我们以后再也不会引用到`bar`这个变量名. 但这个变量却污染了foo scope. 有没有办法既可以打印`a`又可以不创建一个变量名呢? 答案就是利用**IIFE**(Immediately invoked function express).\n```javascript\nfunction foo () {\n  var a = 42;\n\n  (function () {\n    console.log(a);\n  })();\n}\n```\n首先, 用`()`包住整个function body就表明了这个是一个expression, 接着用`()`来调用这个function expression.\n对于IIFE还有其他写法, 你可以选择自己喜欢的口味~\n\nIIFE是很常见的, 因为他在调用一个函数的同时也**避免了作用域的污染**. 这是非常值得我们学习的.\n\n## Summary\n总的来说, nested scope是为了可以共用作用域而产生的, 也就是说内部的scope可以访问外部scope. 而JavaScript有3种作用域global scope, block scope以及function scope. 其中, function scope是最主要的, 并且要懂得其中的IIFE.\n","slug":"Scope-1-Nested-Scope","published":1,"updated":"2016-01-27T06:27:09.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon7x0010qore0srm2ek3"},{"title":"Scope(0) - What Is Scope","author":"Drake Leung","date":"2015-07-06T06:51:18.000Z","foreword":"scope系列的第1篇, 主题是从编译理论知识来讲解为什么需要scope, scope又是什么, 有什么作用.","_content":"\n下面我们会学习JavaScript的scope，也就是作用域．其实很简单~  \n在讲什么是scope之前，我们先讲讲为什么会有scope的存在．\n\n## Why\n我们都知道，一个程序最基本的功能就是对数据的基本操作，比如增删查改．\n\n这个时候，我们就要用到**变量(variable)**了．那么，我们怎么知道变量是存储在哪里的，我们又是怎样获取他的\n值，并且修改呢？\n\n这个时候，我们就需要一个*特殊的地方*来存放变量，然后我们可以在这个地方\n找到我们所需要的变量了．这个＊特殊的地方*就是scope．\n\n## What\n知道了为什么会有scope的存在，我们就很容易知道什么叫做scope了．个人认为的话，\n\n> scope就是一个地方，用来存放变量的．因此，你可以通过scope来获取变量的值，\n从而对这些变量进行基本的操作．\n\n## How It Works\n我们先来了解一些编译(compile)理论知识．\n\n首先，**compile**主要分成３个步骤．\n\n1. Lexing(Takenizing): 把一个要编译的语句分成一些有意义的taken.\n    比如`var bar = 2;`会被分成`var`, `bar`, `=` `2`．\n\n2. Parsing: 把所有的taken弄成一棵*AST*(abstract syntax tree, 抽象语法树)\n\n3. Code Generation: 生成可执行代码\n\n**我们需要明确的一点是: JavaScript的代码是\"从上到下\",\"一句一句\"的编译然后就立马执行的.**\n(注意我使用了双引号)\n\n接下来,介绍3位好机油.分别是浏览器的Engine, Compiler, Scope.\n\n- Engine: 负责分配任务,以及执行代码.\n- Compiler: 接受Engine传递的任务,编译可执行的代码返回给Engine\n- Scope: 存放变量,函数声明等.\n\n那么,让我们通过一个例子,来看看他们是如何合作的.\n\n```javascript\n// Engine will split this statement into 2 parts:\n// `var bar` and `bar = 10`.\n\nvar bar = 10;\n```\nEngine: 先把`var bar`交给Compiler.  \nCompiler: 问问Scope有没有声明过`bar`这个变量.没有的话不管他,否则让Scope声明`bar`变量.\nScope: 我这里没有`bar`, 那我就声明吧.  \n\nEngine: 我要开始执行`bar = 10`啦.Scope你好,请问你那里有没有`bar`这个变量?\nScope: 当然!刚才Compiler叫我声明了.\nEngine: 既然你`bar`的话,那我就把`10`赋值给他咯.\n\n\n## Do It\n通过Scope来查找变量,函数声明等等的过程叫做`identifier looking up`.\n\n下面，我们通过一个例子，来看看怎么一回事．\n\n```javascript\nvar bar;\nbar = 42;\n\nconsole.log(bar);\n```\n\n在第２行代码中，我们引用了`bar`这个变量，并给他赋值了`２`.\n此时，这种引用就叫做**LHS**(left hand side),也就是等号的右边．\n\n在第３行中，我们引用了`bar`这个变量的值．此时，这个引用叫做**RHS**(right hand side)，\n也就是等号的右边，准确来说是等号的非左边．\n\n那么，LHS和RHS有什么不同呢？\n\nLHS只是获取变量,不在乎这个变量对应的值是什么.例子中,我们只想把`42`赋值给`bar`.\n还有一种情况也是`LHS`: 函数的参数.\n\nRHS是为了获取变量的值!例子中,我们想要的就是把`bar`这个变量对应的值打印出来.\n\nRHS如果在scope中找不到这个变量,那么就会报错: `Reference Error`.而LHS则会给`window`\n这个全局变量添加一个属性,如果在没有使用`use strict`的情况下.比如:\n```javascript\n// 'use strict;'\nfoo = 10;\nconsole.log(foo);\n```\n在上面的例子中,很明显在scope中是找不到`foo`这个变量的.\n又由于他是LHS,所有就会有`window.foo = 10;`我们可以通过`console.log(window.hasOwnProperty('foo'))`来测试一下.\n","source":"_posts/Scope-0-What-Is-Scope.md","raw":"title: Scope(0) - What Is Scope\nauthor: Drake Leung\ndate: 2015-07-06 14:51:18\ntags: scope\ncategories: JavaScript\nforeword:\n  scope系列的第1篇, 主题是从编译理论知识来讲解为什么需要scope, scope又是什么, 有什么作用.\n---\n\n下面我们会学习JavaScript的scope，也就是作用域．其实很简单~  \n在讲什么是scope之前，我们先讲讲为什么会有scope的存在．\n\n## Why\n我们都知道，一个程序最基本的功能就是对数据的基本操作，比如增删查改．\n\n这个时候，我们就要用到**变量(variable)**了．那么，我们怎么知道变量是存储在哪里的，我们又是怎样获取他的\n值，并且修改呢？\n\n这个时候，我们就需要一个*特殊的地方*来存放变量，然后我们可以在这个地方\n找到我们所需要的变量了．这个＊特殊的地方*就是scope．\n\n## What\n知道了为什么会有scope的存在，我们就很容易知道什么叫做scope了．个人认为的话，\n\n> scope就是一个地方，用来存放变量的．因此，你可以通过scope来获取变量的值，\n从而对这些变量进行基本的操作．\n\n## How It Works\n我们先来了解一些编译(compile)理论知识．\n\n首先，**compile**主要分成３个步骤．\n\n1. Lexing(Takenizing): 把一个要编译的语句分成一些有意义的taken.\n    比如`var bar = 2;`会被分成`var`, `bar`, `=` `2`．\n\n2. Parsing: 把所有的taken弄成一棵*AST*(abstract syntax tree, 抽象语法树)\n\n3. Code Generation: 生成可执行代码\n\n**我们需要明确的一点是: JavaScript的代码是\"从上到下\",\"一句一句\"的编译然后就立马执行的.**\n(注意我使用了双引号)\n\n接下来,介绍3位好机油.分别是浏览器的Engine, Compiler, Scope.\n\n- Engine: 负责分配任务,以及执行代码.\n- Compiler: 接受Engine传递的任务,编译可执行的代码返回给Engine\n- Scope: 存放变量,函数声明等.\n\n那么,让我们通过一个例子,来看看他们是如何合作的.\n\n```javascript\n// Engine will split this statement into 2 parts:\n// `var bar` and `bar = 10`.\n\nvar bar = 10;\n```\nEngine: 先把`var bar`交给Compiler.  \nCompiler: 问问Scope有没有声明过`bar`这个变量.没有的话不管他,否则让Scope声明`bar`变量.\nScope: 我这里没有`bar`, 那我就声明吧.  \n\nEngine: 我要开始执行`bar = 10`啦.Scope你好,请问你那里有没有`bar`这个变量?\nScope: 当然!刚才Compiler叫我声明了.\nEngine: 既然你`bar`的话,那我就把`10`赋值给他咯.\n\n\n## Do It\n通过Scope来查找变量,函数声明等等的过程叫做`identifier looking up`.\n\n下面，我们通过一个例子，来看看怎么一回事．\n\n```javascript\nvar bar;\nbar = 42;\n\nconsole.log(bar);\n```\n\n在第２行代码中，我们引用了`bar`这个变量，并给他赋值了`２`.\n此时，这种引用就叫做**LHS**(left hand side),也就是等号的右边．\n\n在第３行中，我们引用了`bar`这个变量的值．此时，这个引用叫做**RHS**(right hand side)，\n也就是等号的右边，准确来说是等号的非左边．\n\n那么，LHS和RHS有什么不同呢？\n\nLHS只是获取变量,不在乎这个变量对应的值是什么.例子中,我们只想把`42`赋值给`bar`.\n还有一种情况也是`LHS`: 函数的参数.\n\nRHS是为了获取变量的值!例子中,我们想要的就是把`bar`这个变量对应的值打印出来.\n\nRHS如果在scope中找不到这个变量,那么就会报错: `Reference Error`.而LHS则会给`window`\n这个全局变量添加一个属性,如果在没有使用`use strict`的情况下.比如:\n```javascript\n// 'use strict;'\nfoo = 10;\nconsole.log(foo);\n```\n在上面的例子中,很明显在scope中是找不到`foo`这个变量的.\n又由于他是LHS,所有就会有`window.foo = 10;`我们可以通过`console.log(window.hasOwnProperty('foo'))`来测试一下.\n","slug":"Scope-0-What-Is-Scope","published":1,"updated":"2016-01-27T06:26:27.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon840015qoreyr91jv41"},{"title":"迷之前端轮子 - 实现 ES2015 Promise","author":"Drake Leung","date":"2016-02-06T09:59:59.000Z","foreword":"为了更好地学习ES2015的Promise，我们不妨来从零开始实现它。","_content":"\n(所有代码请查看[GitHub tiny-promise](https://github.com/DrakeLeung/tiny-promise))\n\n## Why\n在此之前，我一直不明白 *promise* 的workflow是怎样子的。所以在使用的时候，一直很迷惑。比如，\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('success'), 1000)\n})\n\np1.then(msg => console.log(msg))\n```\n\n对于上面的代码，之前的我只知道`resolve`的参数`success`会传给`then`的`msg`。但是为什么呢？而且，我更没想过到底是`then`先执行呢还是`resolve`先执行？这有什么影响？\n\n## How\n那么，就让我们从零开始实现一个promise吧。\n\n\n### Promise Constructor\n根据[docs](http://devdocs.io/javascript/global_objects/promise)，`Promise`这个构造函数只接受一个参数，且这个参数是一个`function`。他有2个参数，分别是`resolve`和`reject`。\n我们要在构造函数里面执行`executor`函数，并且传2个参数给他。\n\n并且，我们构造函数还有一些property，比如他的状态，数据等\n\n```javascript\nfunction TinyPromise (executor) {\n  this.state = promiseState.PENDING\n  this.msg = void 0\n  this.chains = [] // 在`then()`时再讲\n\n  executor(resolve, reject)\n}\n```\n\n接着，定义`resolve`和`reject`这2个传给`executor`的参数\n\n```javascript\nconst resolve = function (value) {\n  let self = this\n\n  if (self.state !== promiseState.FULLFILLED) { // #0\n    self.state = promiseState.FULLFILLED\n    self.msg = value\n  }\n\n  notify(self) // 下面再讲\n}\n```\n\n`#0`为什么要加上`if`判断呢？因为有可能`resolve`并不是异步执行的，所以在调用`then()`的时候，promise的状态已经为`fullfilled`了，所以这个时候`value`是`undefined`的。你可以自己试试。\n\n到底`chains`是什么呢？\n\n### Then\n当调用`then`的时候，他会返回一个promise。重复之，便形成了链(chain)。因此，我们每次都把这个promise放进`this.chains`里面。\n\n```javascript\nthis['then'] = (onFullfilled, onRejected) => {\n  let o = {\n    onFullfilled,\n    onRejected\n  }\n\n  o.promise = new this.constructor((resolve, reject) => {\n    o = Object.assign(o, {resolve, reject})\n  })\n\n  this.chains = [...this.chains, o]\n\n  // doesn't call resolve or reject in executor async-ly\n  if (this.state === promiseState.FULLFILLED) // #0\n    resolve.call(this)\n  else if (this.state === promiseState.REJECTED)\n    reject.call(this)\n\n  return o.promise\n}\n```\n在`#0`，我们为什么需要做这个判断呢？因为在调用`then`时，promise的状态已经不是`pending`了。为什么？看看文本前面的*Why*部分。\n\n注意到，我们把`then`的2个参数，以及`executor`的2个参数都放进了`this.chains`里面。\n\n### Notify\n`notify`函数的作用就是把`then`返回的结果传递到下一个`then`里面去。\n\n```javascript\nconst handleFullfill = (chain, self) => {\n  // 上一个then()的success handler的返回值\n  const result = chain.onFullfilled(self.msg)\n  // 传给下一个then()\n  chain.resolve(result)\n}\n\nexport const notify = self => {\n  self.chains.forEach(chain => {\n    switch (self.state) {\n      case promiseState.FULLFILLED:\n        handleFullfill(chain, self)\n        break\n\n      case promiseState.REJECTED:\n        handleReject(chain, self)\n        break\n    }\n  })\n}\n```\n\n### Promise.resolve\n这个方法`resolve`其实就是`Promise`构造函数的一个property。\n\n```javascript\ndefineProp(TinyPromise, 'resolve', msg =>\n  new TinyPromise((resolve, reject) => {\n    resolve(msg)\n  })\n)\n\nconst defineProp = (\n  obj = {},\n  prop,\n  value\n) => {\n  try {\n    return Object.defineProperties(obj, prop, {\n      value,\n      writable: true,\n      configurable: true,\n      enumerate: true\n    })\n  } catch (e) {\n    obj[prop] = value\n    return obj\n  }\n}\n```\n\n## Wrap up\n实现完以上，你就可以解决本文前面部分*Why*的问题了。\n\n`then`首先会执行，因为`resolve`是异步的(`setTimeout`里面)。这时，我们把`then`的参数放在一个对象数组里面。等到`resolve`调用的时候，我们再去遍历这个数组，调用`then`的参数，并且把返回值传给下一个promise。\n\n如果`resolve`不是异步的话，那么`resolve`比`then`先执行。在`then`执行的时候，状态已经为`fullfilled`了。因此只需要直接调用`notify`函数。\n\nCool~\n","source":"_posts/Promise.md","raw":"---\ntitle: 迷之前端轮子 - 实现 ES2015 Promise\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-02-06 17:59:59\nforeword: 为了更好地学习ES2015的Promise，我们不妨来从零开始实现它。\n---\n\n(所有代码请查看[GitHub tiny-promise](https://github.com/DrakeLeung/tiny-promise))\n\n## Why\n在此之前，我一直不明白 *promise* 的workflow是怎样子的。所以在使用的时候，一直很迷惑。比如，\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('success'), 1000)\n})\n\np1.then(msg => console.log(msg))\n```\n\n对于上面的代码，之前的我只知道`resolve`的参数`success`会传给`then`的`msg`。但是为什么呢？而且，我更没想过到底是`then`先执行呢还是`resolve`先执行？这有什么影响？\n\n## How\n那么，就让我们从零开始实现一个promise吧。\n\n\n### Promise Constructor\n根据[docs](http://devdocs.io/javascript/global_objects/promise)，`Promise`这个构造函数只接受一个参数，且这个参数是一个`function`。他有2个参数，分别是`resolve`和`reject`。\n我们要在构造函数里面执行`executor`函数，并且传2个参数给他。\n\n并且，我们构造函数还有一些property，比如他的状态，数据等\n\n```javascript\nfunction TinyPromise (executor) {\n  this.state = promiseState.PENDING\n  this.msg = void 0\n  this.chains = [] // 在`then()`时再讲\n\n  executor(resolve, reject)\n}\n```\n\n接着，定义`resolve`和`reject`这2个传给`executor`的参数\n\n```javascript\nconst resolve = function (value) {\n  let self = this\n\n  if (self.state !== promiseState.FULLFILLED) { // #0\n    self.state = promiseState.FULLFILLED\n    self.msg = value\n  }\n\n  notify(self) // 下面再讲\n}\n```\n\n`#0`为什么要加上`if`判断呢？因为有可能`resolve`并不是异步执行的，所以在调用`then()`的时候，promise的状态已经为`fullfilled`了，所以这个时候`value`是`undefined`的。你可以自己试试。\n\n到底`chains`是什么呢？\n\n### Then\n当调用`then`的时候，他会返回一个promise。重复之，便形成了链(chain)。因此，我们每次都把这个promise放进`this.chains`里面。\n\n```javascript\nthis['then'] = (onFullfilled, onRejected) => {\n  let o = {\n    onFullfilled,\n    onRejected\n  }\n\n  o.promise = new this.constructor((resolve, reject) => {\n    o = Object.assign(o, {resolve, reject})\n  })\n\n  this.chains = [...this.chains, o]\n\n  // doesn't call resolve or reject in executor async-ly\n  if (this.state === promiseState.FULLFILLED) // #0\n    resolve.call(this)\n  else if (this.state === promiseState.REJECTED)\n    reject.call(this)\n\n  return o.promise\n}\n```\n在`#0`，我们为什么需要做这个判断呢？因为在调用`then`时，promise的状态已经不是`pending`了。为什么？看看文本前面的*Why*部分。\n\n注意到，我们把`then`的2个参数，以及`executor`的2个参数都放进了`this.chains`里面。\n\n### Notify\n`notify`函数的作用就是把`then`返回的结果传递到下一个`then`里面去。\n\n```javascript\nconst handleFullfill = (chain, self) => {\n  // 上一个then()的success handler的返回值\n  const result = chain.onFullfilled(self.msg)\n  // 传给下一个then()\n  chain.resolve(result)\n}\n\nexport const notify = self => {\n  self.chains.forEach(chain => {\n    switch (self.state) {\n      case promiseState.FULLFILLED:\n        handleFullfill(chain, self)\n        break\n\n      case promiseState.REJECTED:\n        handleReject(chain, self)\n        break\n    }\n  })\n}\n```\n\n### Promise.resolve\n这个方法`resolve`其实就是`Promise`构造函数的一个property。\n\n```javascript\ndefineProp(TinyPromise, 'resolve', msg =>\n  new TinyPromise((resolve, reject) => {\n    resolve(msg)\n  })\n)\n\nconst defineProp = (\n  obj = {},\n  prop,\n  value\n) => {\n  try {\n    return Object.defineProperties(obj, prop, {\n      value,\n      writable: true,\n      configurable: true,\n      enumerate: true\n    })\n  } catch (e) {\n    obj[prop] = value\n    return obj\n  }\n}\n```\n\n## Wrap up\n实现完以上，你就可以解决本文前面部分*Why*的问题了。\n\n`then`首先会执行，因为`resolve`是异步的(`setTimeout`里面)。这时，我们把`then`的参数放在一个对象数组里面。等到`resolve`调用的时候，我们再去遍历这个数组，调用`then`的参数，并且把返回值传给下一个promise。\n\n如果`resolve`不是异步的话，那么`resolve`比`then`先执行。在`then`执行的时候，状态已经为`fullfilled`了。因此只需要直接调用`notify`函数。\n\nCool~\n","slug":"Promise","published":1,"updated":"2016-02-06T12:58:36.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon870018qorecnw9ham6"},{"title":"「译」JavaScript Modules Part2: Module Bundling","author":"Drake Leung","date":"2016-02-08T07:57:07.000Z","foreword":"JavaScript 模块化 Part2 - 主要讲述 module bundling。","_content":"\n**(原文：[JavaScript Modules Part 2: Module Bundling](https://medium.freecodecamp.com/javascript-modules-part-2-module-bundling-5020383cf306#.m5o3ar7dt))**\n\n\n\n在Part 1，我讲解了什么是 *module* ，为什么要使用他们，以及合并 module 的各种方法。在Part 2，我会讲解什么是 *bundle modules* : 为什么要，不同方法的实现，以及 module 在今后web开发的情况。\n\n\n\n## 什么是 module bundling?\n\n简单来说，*module bundling* 其实就是把一组 module (以及他们的依赖)，按照正确的顺序，打包(bundle)到一个单独的文件(或者一组文件)里面。但是对于web开发来说，细节才是魔鬼 :)\n\n\n\n## 为什么把所有的 module 都打包在一起？\n\n当你把程序分成多个 module 的时候，你很可能会把他们组织在不同的文件和文件夹中。偶尔你会有第三方 module ，比如`Underscore`或者`React`。\n\n\n\n那么，当用户浏览你的页面时，这些文件都会通过 `<script>` 标签引入到你的 HTML 文件。每个文件就需要一个 `<script>` 标签，就意味着，浏览器需要单独地加载每个文件，一个...接着...一个。\n\n\n\n...然而这对于页面的加载时间是很不友好的。\n\n\n\n为了解决这个问题，我们 *bundle*，或者 *concatenate* 所有的文件到一个大文件里面(或者一组文件，根据情况)，这样就可以减少请求的数量。这个就是你听别的开发人员所说的「build step」或者「build process」。\n\n\n\n另一个加速 bundling 操作的的方法是「minify」(压缩)代码。*minification* 就是从源代码中去除不必要的字符(比如，空格，注释，换行符等)。这样一来，不仅减少了代码的大小，而且不影响其本身的功能。\n\n\n\n更少的数据就意味着浏览器处理的时间更少，因为减少了下载文件的时间。如果你曾经见过文件名有后缀`min`，比如`underscore.min.js`，其实就是相对于完整版的一个不具可读性，压缩过的版本。\n\n\n\n像 *gulp* 或者 *Grunt* 这样的 Task runners，对开发者来说，是很容易进行`concatenations`和`minification`。这样一来，保证了代码对开发者的可读性的同时，也保证了对浏览器的优化。\n\n\n\n## 实现bundle module的各种方法\n\n当你使用标准的 module pattern (前面讲解的)的其中一种来定义 module 的时候，*concatenating* 和 *minifying* 你的文件是极好的，你所需要做的就是把你的一堆JavaScript代码打包在一起。\n\n\n\n但是，当你使用浏览器不能解析的非原生模块系统时，比如 CommonJS，AMD。你需要一种特殊的工具来把你的代码转换成浏览器可以解析的。这就是为什么 *Browserify*，*RequireJS*，*Webpack*，和其他「module bundlers」又或者「module loaders」会出现。\n\n\n\n为了 bundling 或者 loading 你的代码，module bundlers 提供了好多额外的 feature。比如当你修改代码时自动重编译，还有提供调试时所需要的 source maps。\n\n\n\n现在让我们来看看 module bundling 的几种方法:\n\n\n\n### Bundling CommonJS\n\n从 Part1 可知，CommonJS 是同步加载 module 的，这是很好的除了对浏览器不适用之外。我提到过有解决方法——其中一种就是使用 *Browserify* 。Browserify 可以给浏览器编译 CommonJS 的 module。\n\n\n\n举个例子，我们有一个 `main.js` 文件，他 *import* 了一个可以计算数组平均值的 module:\n\n\n\n``` javascript\nvar myDependency = require(‘myDependency’);\nvar myGrades = [93, 95, 88, 0, 91];\nvar myAverageGrade = myDependency.average(myGrades);\n```\n\n\n\n在这个例子中，我们有一个依赖(`myDependency`)。使用下面的命令，*Browserify* 会递归地把`main.js`前面所有需要的module打包到一个单独的文件里(`bundle.js`)：\n\n\n\n``` javascript\n\tbrowserify main.js -o bundle.js\n```\n\n\n\n*Browserify* 的实现方法：为了遍历你整个项目的依赖，他会把每个 `require` 解析成 [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)。当他计算出你项目的依赖关系时，他就会按照正确的顺序把他们都打包在一个单独的文件里面。因此，你只需要把一个单独的，带上`bundle.js`的`<script>`标签放在你的 HTML 文件里面。这样一来，只要一个 HTTP 请求，就可以加载所有的modules。豪爽~\n\n\n\n相似地，如果你有多个文件且有多个依赖，你只需要简单地告诉 *Browserify* 你的 `entry file`，然后坐下，*Browserify* 就会开始施魔法。\n\n\n\n最后：准备好你打包好的文件，然后使用像 *Minify-JS* 这样的工具来压缩的你的代码。\n\n\n\n### Bundling AMD\n\n如果你使用AMD，也许你会使用一个像`RequireJS`或者`Curl`这样的AMD加载器。一个module loader(vs. a bundler)会动态地加载module，当你程序需要的时候。\n\n\n\n提醒一下，AMD与CommonJS不同的地方之一是，前者是动态加载模块的。也就是说，有了AMD，你实际上不需要*build step*(打包你所有的module到一个单独文件)，因为你是动态加载module——也就是只有当你需要module的时候才去下载文件，而不是当用户第一次浏览的时候，就把所有的module都下载。\n\n\n\n但在实际生产中，用户每次行为就需要请求下载对应的module是没有意义的。因此很多web开发者为了额外的性能，都会使用工具去打包和压缩他们的AMD modules，比如*RequireJS optimizer*，*r.js*。\n\n\n\n总的来说，AMD和CommonJS关于bundling的区别是：前者可以不需要build step。除非，你想*push the code live*，这时你可以使用像`r.js`这样的优化器。\n\n\n\n更多关于CommonJS和AMD的讨论，请查看这篇文章[Tom Dale’s blog](http://tomdale.net/2012/01/amd-is-not-the-answer/) :)\n\n\n\n### Webpack\n\n就目前的bundlers来说，*Webpack*是锋芒初现的。他可以识别任意一种模块系统，比如CommonJS，AMD或者ES6。\n\n\n\n你也许会这样想到：既然我们已经有了Browserify和RequireJS这样的工具，为什么还需要Webpack。其实，Webpack提供了很有用的feature像**code splitting**—把你的代码拆分成动态加载的「chuncks」。\n\n\n\n比如说，如果你的web应用有一块代码是在特定情况下才加载的，那么把所有的代码打包在一个单独的很大的文件里面就不是很适合了。在这种情况下，你可以使用*code splitting*提取代码到按需加载的*chunks*里面，这样就避免了用户首次访问时需要加载体积很大的`bundle.js`。\n\n\n\n*Code splitting*是Webpack提供的feature之一。网上有很多讨论Webpack和Browserify的文章，不妨看下面的链接：\n\n\n\n- [https://gist.github.com/substack/68f8d502be42d5cd4942](https://gist.github.com/substack/68f8d502be42d5cd4942)\n- [http://mattdesl.svbtle.com/browserify-vs-webpack](http://mattdesl.svbtle.com/browserify-vs-webpack)\n- [http://blog.namangoel.com/browserify-vs-webpack-js-drama](http://blog.namangoel.com/browserify-vs-webpack-js-drama)\n\n\n\n## ES6 Modules\n\n接下来我会讨论ES6 modules，他也许在未来让以上的bundlers的使用变少(等一下你就会明白我在讲什么)。首先，让我们来理解ES6 modules是如何加载的。\n\n\n\nES6 modules与AMD，CMD最大的不同之处在于，前者设计时考虑到了静态分析(static analysis)。这就意味着，当你`import` 模块时，这个`import`动作在编译的时候就完成了。也就是，在执行脚本之前，可以让我们移除掉不需要的`exports`。移除掉不必要的`exports`不但可以减少空间，还能减轻浏览器的压力。\n\n\n\n那么问题来了：这个和*dead code elimination*(如使用UglifyJS去压缩代码)有什么不同？答案是：**看情况**。\n\n\n\n(注意：*Dead code elimination*其实是移除掉不必要的代码和变量。不妨这样想：他是把你**打包后**的程序的多余的代码和变量移除掉。\n\n\n\n有时候，*dead code elimination*在ES6 module和UglifyJS中是一样的，但有时候又不是。如果你想了解更多你可以查看在[Rollup’s wiki](https://github.com/rollup/rollup)的一个很棒的例子。\n\n\n\nES6不同的地方在于实现dead code elimination的方法，叫**tree shaking**。Tree shaking实际上与dead code elimination的理念是相反的。他只打包了你所必需的代码，而不是把不需要的代码移除掉。让我们来看一下tree shaking的一个例子：\n\n\n\n假设我们有一个`util.js`文件 ，他有多个函数，我们用ES6的语法来导出他们。\n\n\n\n``` javascript\nexport function each(collection, iterator) {\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } else {\n    for (var key in collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n}\n\nexport function filter(collection, test) {\n  var filtered = [];\n  each(collection, function(item) {\n    if (test(item)) {\n      filtered.push(item);\n    }\n  });\n  return filtered;\n}\n\nexport function map(collection, iterator) {\n  var mapped = [];\n  each(collection, function(value, key, collection) {\n    mapped.push(iterator(value));\n  });\n  return mapped;\n}\n\nexport function reduce(collection, iterator, accumulator) {\n  var startingValueMissing = accumulator === undefined;\n  each(collection, function(item) {\n    if (startingValueMissing) {\n      accumulator = item;\n      startingValueMissing = false;\n    } else {\n      accumulator = iterator(accumulator, item);\n    }\n  });\n  return accumulator;\n}\n```\n\n\n\n接下来，我们假设我们并不知道我们需要`util.js`的哪一个函数，所以，在`main.js`中我们这样引入他：\n\n\n\n``` javascript\nimport * as Utils from ‘./utils.js’;\n```\n\n\n\n然后，我们开始使用其中的一个函数：\n\n\n\n``` javascript\nimport * as Utils from ‘./utils.js’;\n\nUtils.each([1, 2, 3], function(x) { console.log(x) });\n```\n\n\n\n而，`main.js`被*tree shaking*编译之后，是长这样的：\n\n\n\n``` javascript\nfunction each(collection, iterator) {\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } else {\n    for (var key in collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n};\n\neach([1, 2, 3], function(x) {\n  console.log(x)\n});\n```\n\n\n\n注意到，只有我们使用的`each`被引入了，而不是`util.js`里所有的函数。\n\n\n\n那么，如果我们使用`filter`函数而不是`each`的话，我们的`main.js`:\n\n\n\n``` javascript\nimport * as Utils from ‘./utils.js’;\nUtils.filter([1, 2, 3], function(x) { return x === 2 });\n```\n\n\n\ntree shaking 编译后，`main.js`变成了这样：\n\n\n\n``` javascript\nfunction each(collection, iterator) {\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } else {\n    for (var key in collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n};\n\nfunction filter(collection, test) {\n  var filtered = [];\n  each(collection, function(item) {\n    if (test(item)) {\n      filtered.push(item);\n    }\n  });\n  return filtered;\n};\n\nfilter([1, 2, 3], function(x) {\n  return x === 2\n});\n```\n\n\n\n注意到这个时候,`each`和`filter`都被引入了，这是因为`filter`函数是依赖于`each`的。\n\n\n\n很cool，对不对？\n\n\n\n我建议你通过*Rollup.js*的 [live demo and editor](http://rollupjs.org/) ，去玩玩和了解一下tree shaking。\t\t\n\n\n\n## 构建ES6 modules\n\n好的，现在我们知道了ES6 modules的加载很其他module format是不同的，但是我们还没讲怎么构建ES6 modules。\n\n\n\n不幸的是，ES6 modules 还需要额外的工作，因为浏览器还没有实现原生的ES6 module加载。\n\n\n\n下面有两种方法来构建/转换 ES6 modules，使得在浏览器中可以使用。其中，第一种是当前最常见的：\n\n\n\n1. 使用转换器(比如，Babel或者Traceur)，把你ES6代码转换成CommonJS，AMD或者UMD格式的ES5代码。然后把转换好的代码送到一个module bundler里去，比如Browserify或者Webpack，这样就创建了一个或多个打包好的文件。\n2. 使用[Rollup.js](http://rollupjs.org/)：这种方法和前面的很相似，除了在打包之前会使用ES6 module的静态分析。他利用**tree shaking**把最少的代码量打包。总体来说，Rollup.js比Webpack或者Browserify最大的好处是，当你使用ES6 module时，可以使你的代码的体积更小。需要注意的是，Rollup提供了多种格式来打包你的代码，包括ES6，CommonJS，AMD，CMD，UMD或者IIFE。IIFE和UMD可以适用于你的浏览器，但如果你选择了AMD，CommonJS或者ES6的话，你需要找其他方法把你的代码转成浏览器可以识别的，比如使用Browserify，Webpack，RequireJS等等。\n\n\n\n## Jumping through hoops\n\n作为web开发者，我们需要跳过这些繁文缛节。因为把ES6 modules代码转换成浏览器可以解释的ES5不是一件易事。\n\n\n\n问题就是：我们可以直接在浏览器使用ES6 module，且不用弄上面说到的两种方法吗？\n\n\n\n答案是：很快。\n\n\n\nECMAScript现在已经有解决方案的规范了，叫做[ECMAScript 6 module loader API](https://github.com/ModuleLoader/es6-module-loader)。简单介绍，他是一种可编程的，基于Promise的API，可以动态加载你的modules，并且cache他们，使得随后的`import`不需要加载另外一份新版本的module。\n\n\n\n他大概是这样子的：\n\n\n\n``` javascript\n// myModule.js\n\nexport class myModule {\n  constructor() {\n    console.log('Hello, I am a module');\n  }\n  hello() {\n    console.log('hello!');\n  }\n  goodbye() {\n    console.log('goodbye!');\n  }\n}\n```\n\n\n\n``` javascript\n// main.js\n\nSystem.import(‘myModule’).then(function(myModule) {\n  new myModule.hello();\n});\n// ‘hello!’\n```\n\n\n\n另外一种方法是，你可以直接在`script`标签里，直接注明`type=module`来定义modules。\n\n\n\n``` javascript\n< script type = \"module\" >\n  // loads the 'myModule' export from 'mymodule.js'\n  import {\n    hello\n  } from 'mymodule';\nnew Hello(); // 'Hello, I am a module!'\n< /script>\n```\n\n\n\n如果你还没有看过module loader API的polyfill，我强烈建议你至少去[看一看](https://github.com/ModuleLoader/es6-module-loader)。\n\n\n\n如果你想要测试一下这种方法的话，你可以试试[SystemJS](https://github.com/systemjs/systemjs)。他是基于[ES6 Module Loader polyfill](https://github.com/ModuleLoader/es6-module-loader)创建的。他可以在浏览器和Node环境中，动态地加载任何格式的modules(ES6 modules，AMD，CommonJS以及全局的scripts)。他会跟踪所有已经加载到「module registry」的modules，避免了重新加载已经加载过的modules。值得提醒的是，他也可以自动地转换ES6 modules(如果你开启这个option的话)，还可以从任何一种模块格式中加载任何一种格式的模块。太棒了。\n\n\n\n## 既然我们已经有了ES6 modules，还需要bundlers吗？\n\nES6 modules的逐渐流行，产生了一些有趣的问题：\n\n\n\n### HTTP/2会使module bundlers过时吗？\n\n对于HTTP/1，我们的每个TCP连接只允许一个请求。这就是为什么加载多个资源需要多个请求。有了HTTP/2，一切都变了。HTTP/2是*fully multiplexed*，这就意味着多个请求和多个响应可以并行。这样一来，我们可以在一个TCP连接中，进行多个请求。\n\n\n\n既然每个HTTP/2请求的开销已经比HTTP/1小得多，那么长远来看，加载一堆的modules并不会降低很多的性能。于是有些人就认为，module bundling已经不需要了。这其实是有可能的，但是我们还要视情况而定。\n\n\n\n比如说，module bundling提供了HTTP/2没有提供的优点，像移除掉不需要的`exports`从而减少空间。如果你搭建的网页是每个微小的`bit`都会影响性能的话，那么bundling就给了你巨大的好处。另一方面，如果你对性能要求不是很高的话，你可以跳过构建过程，从而节省了一些时间。\n\n\n\n总起来说，我们现在离享受HTTP/2带来的好处还很远。我个人猜测build process还会持续一段时间。\n\n\n\n### CommonJS，AMD和UMD还过时吗？\n\n一旦ES6变成了标准，那么我们真的还需要非原生的module feature吗？\n\n\n\n我表示怀疑。\n\n\n\n如果只遵循单一的语法去加载和引入module，并且不需要中间步骤，这对于web开发者来说很棒的。但到达这一步还需要多久呢？\n\n\n\n机会是有的，但需要一段时间。\n\n\n\n并且，每个人都可以根据自己的口味去选择，因此「one truthful approach」并不会成为现实。\n\n\n\n## 结论\n\n当开发者讨论modules和module bundling的时候，我希望这两篇文章可以帮助他们厘清这些术语。如果你有疑问的话，你回头看看[part I](https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.y8hs0nsne) 。\n\n\n\n同样地，可以在评论中和我讨论，同时随时欢迎你提问题。\n\n\n\nHappy bundling :)\n\n\n**(原文：[JavaScript Modules Part 2: Module Bundling](https://medium.freecodecamp.com/javascript-modules-part-2-module-bundling-5020383cf306#.m5o3ar7dt))**\n","source":"_posts/JavaScript-Modules-Part-2.md","raw":"---\ntitle: '「译」JavaScript Modules Part2: Module Bundling'\nauthor: Drake Leung\ntags: []\ncategories: [翻译]\ndate: 2016-02-08 15:57:07\nforeword: JavaScript 模块化 Part2 - 主要讲述 module bundling。\n---\n\n**(原文：[JavaScript Modules Part 2: Module Bundling](https://medium.freecodecamp.com/javascript-modules-part-2-module-bundling-5020383cf306#.m5o3ar7dt))**\n\n\n\n在Part 1，我讲解了什么是 *module* ，为什么要使用他们，以及合并 module 的各种方法。在Part 2，我会讲解什么是 *bundle modules* : 为什么要，不同方法的实现，以及 module 在今后web开发的情况。\n\n\n\n## 什么是 module bundling?\n\n简单来说，*module bundling* 其实就是把一组 module (以及他们的依赖)，按照正确的顺序，打包(bundle)到一个单独的文件(或者一组文件)里面。但是对于web开发来说，细节才是魔鬼 :)\n\n\n\n## 为什么把所有的 module 都打包在一起？\n\n当你把程序分成多个 module 的时候，你很可能会把他们组织在不同的文件和文件夹中。偶尔你会有第三方 module ，比如`Underscore`或者`React`。\n\n\n\n那么，当用户浏览你的页面时，这些文件都会通过 `<script>` 标签引入到你的 HTML 文件。每个文件就需要一个 `<script>` 标签，就意味着，浏览器需要单独地加载每个文件，一个...接着...一个。\n\n\n\n...然而这对于页面的加载时间是很不友好的。\n\n\n\n为了解决这个问题，我们 *bundle*，或者 *concatenate* 所有的文件到一个大文件里面(或者一组文件，根据情况)，这样就可以减少请求的数量。这个就是你听别的开发人员所说的「build step」或者「build process」。\n\n\n\n另一个加速 bundling 操作的的方法是「minify」(压缩)代码。*minification* 就是从源代码中去除不必要的字符(比如，空格，注释，换行符等)。这样一来，不仅减少了代码的大小，而且不影响其本身的功能。\n\n\n\n更少的数据就意味着浏览器处理的时间更少，因为减少了下载文件的时间。如果你曾经见过文件名有后缀`min`，比如`underscore.min.js`，其实就是相对于完整版的一个不具可读性，压缩过的版本。\n\n\n\n像 *gulp* 或者 *Grunt* 这样的 Task runners，对开发者来说，是很容易进行`concatenations`和`minification`。这样一来，保证了代码对开发者的可读性的同时，也保证了对浏览器的优化。\n\n\n\n## 实现bundle module的各种方法\n\n当你使用标准的 module pattern (前面讲解的)的其中一种来定义 module 的时候，*concatenating* 和 *minifying* 你的文件是极好的，你所需要做的就是把你的一堆JavaScript代码打包在一起。\n\n\n\n但是，当你使用浏览器不能解析的非原生模块系统时，比如 CommonJS，AMD。你需要一种特殊的工具来把你的代码转换成浏览器可以解析的。这就是为什么 *Browserify*，*RequireJS*，*Webpack*，和其他「module bundlers」又或者「module loaders」会出现。\n\n\n\n为了 bundling 或者 loading 你的代码，module bundlers 提供了好多额外的 feature。比如当你修改代码时自动重编译，还有提供调试时所需要的 source maps。\n\n\n\n现在让我们来看看 module bundling 的几种方法:\n\n\n\n### Bundling CommonJS\n\n从 Part1 可知，CommonJS 是同步加载 module 的，这是很好的除了对浏览器不适用之外。我提到过有解决方法——其中一种就是使用 *Browserify* 。Browserify 可以给浏览器编译 CommonJS 的 module。\n\n\n\n举个例子，我们有一个 `main.js` 文件，他 *import* 了一个可以计算数组平均值的 module:\n\n\n\n``` javascript\nvar myDependency = require(‘myDependency’);\nvar myGrades = [93, 95, 88, 0, 91];\nvar myAverageGrade = myDependency.average(myGrades);\n```\n\n\n\n在这个例子中，我们有一个依赖(`myDependency`)。使用下面的命令，*Browserify* 会递归地把`main.js`前面所有需要的module打包到一个单独的文件里(`bundle.js`)：\n\n\n\n``` javascript\n\tbrowserify main.js -o bundle.js\n```\n\n\n\n*Browserify* 的实现方法：为了遍历你整个项目的依赖，他会把每个 `require` 解析成 [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)。当他计算出你项目的依赖关系时，他就会按照正确的顺序把他们都打包在一个单独的文件里面。因此，你只需要把一个单独的，带上`bundle.js`的`<script>`标签放在你的 HTML 文件里面。这样一来，只要一个 HTTP 请求，就可以加载所有的modules。豪爽~\n\n\n\n相似地，如果你有多个文件且有多个依赖，你只需要简单地告诉 *Browserify* 你的 `entry file`，然后坐下，*Browserify* 就会开始施魔法。\n\n\n\n最后：准备好你打包好的文件，然后使用像 *Minify-JS* 这样的工具来压缩的你的代码。\n\n\n\n### Bundling AMD\n\n如果你使用AMD，也许你会使用一个像`RequireJS`或者`Curl`这样的AMD加载器。一个module loader(vs. a bundler)会动态地加载module，当你程序需要的时候。\n\n\n\n提醒一下，AMD与CommonJS不同的地方之一是，前者是动态加载模块的。也就是说，有了AMD，你实际上不需要*build step*(打包你所有的module到一个单独文件)，因为你是动态加载module——也就是只有当你需要module的时候才去下载文件，而不是当用户第一次浏览的时候，就把所有的module都下载。\n\n\n\n但在实际生产中，用户每次行为就需要请求下载对应的module是没有意义的。因此很多web开发者为了额外的性能，都会使用工具去打包和压缩他们的AMD modules，比如*RequireJS optimizer*，*r.js*。\n\n\n\n总的来说，AMD和CommonJS关于bundling的区别是：前者可以不需要build step。除非，你想*push the code live*，这时你可以使用像`r.js`这样的优化器。\n\n\n\n更多关于CommonJS和AMD的讨论，请查看这篇文章[Tom Dale’s blog](http://tomdale.net/2012/01/amd-is-not-the-answer/) :)\n\n\n\n### Webpack\n\n就目前的bundlers来说，*Webpack*是锋芒初现的。他可以识别任意一种模块系统，比如CommonJS，AMD或者ES6。\n\n\n\n你也许会这样想到：既然我们已经有了Browserify和RequireJS这样的工具，为什么还需要Webpack。其实，Webpack提供了很有用的feature像**code splitting**—把你的代码拆分成动态加载的「chuncks」。\n\n\n\n比如说，如果你的web应用有一块代码是在特定情况下才加载的，那么把所有的代码打包在一个单独的很大的文件里面就不是很适合了。在这种情况下，你可以使用*code splitting*提取代码到按需加载的*chunks*里面，这样就避免了用户首次访问时需要加载体积很大的`bundle.js`。\n\n\n\n*Code splitting*是Webpack提供的feature之一。网上有很多讨论Webpack和Browserify的文章，不妨看下面的链接：\n\n\n\n- [https://gist.github.com/substack/68f8d502be42d5cd4942](https://gist.github.com/substack/68f8d502be42d5cd4942)\n- [http://mattdesl.svbtle.com/browserify-vs-webpack](http://mattdesl.svbtle.com/browserify-vs-webpack)\n- [http://blog.namangoel.com/browserify-vs-webpack-js-drama](http://blog.namangoel.com/browserify-vs-webpack-js-drama)\n\n\n\n## ES6 Modules\n\n接下来我会讨论ES6 modules，他也许在未来让以上的bundlers的使用变少(等一下你就会明白我在讲什么)。首先，让我们来理解ES6 modules是如何加载的。\n\n\n\nES6 modules与AMD，CMD最大的不同之处在于，前者设计时考虑到了静态分析(static analysis)。这就意味着，当你`import` 模块时，这个`import`动作在编译的时候就完成了。也就是，在执行脚本之前，可以让我们移除掉不需要的`exports`。移除掉不必要的`exports`不但可以减少空间，还能减轻浏览器的压力。\n\n\n\n那么问题来了：这个和*dead code elimination*(如使用UglifyJS去压缩代码)有什么不同？答案是：**看情况**。\n\n\n\n(注意：*Dead code elimination*其实是移除掉不必要的代码和变量。不妨这样想：他是把你**打包后**的程序的多余的代码和变量移除掉。\n\n\n\n有时候，*dead code elimination*在ES6 module和UglifyJS中是一样的，但有时候又不是。如果你想了解更多你可以查看在[Rollup’s wiki](https://github.com/rollup/rollup)的一个很棒的例子。\n\n\n\nES6不同的地方在于实现dead code elimination的方法，叫**tree shaking**。Tree shaking实际上与dead code elimination的理念是相反的。他只打包了你所必需的代码，而不是把不需要的代码移除掉。让我们来看一下tree shaking的一个例子：\n\n\n\n假设我们有一个`util.js`文件 ，他有多个函数，我们用ES6的语法来导出他们。\n\n\n\n``` javascript\nexport function each(collection, iterator) {\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } else {\n    for (var key in collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n}\n\nexport function filter(collection, test) {\n  var filtered = [];\n  each(collection, function(item) {\n    if (test(item)) {\n      filtered.push(item);\n    }\n  });\n  return filtered;\n}\n\nexport function map(collection, iterator) {\n  var mapped = [];\n  each(collection, function(value, key, collection) {\n    mapped.push(iterator(value));\n  });\n  return mapped;\n}\n\nexport function reduce(collection, iterator, accumulator) {\n  var startingValueMissing = accumulator === undefined;\n  each(collection, function(item) {\n    if (startingValueMissing) {\n      accumulator = item;\n      startingValueMissing = false;\n    } else {\n      accumulator = iterator(accumulator, item);\n    }\n  });\n  return accumulator;\n}\n```\n\n\n\n接下来，我们假设我们并不知道我们需要`util.js`的哪一个函数，所以，在`main.js`中我们这样引入他：\n\n\n\n``` javascript\nimport * as Utils from ‘./utils.js’;\n```\n\n\n\n然后，我们开始使用其中的一个函数：\n\n\n\n``` javascript\nimport * as Utils from ‘./utils.js’;\n\nUtils.each([1, 2, 3], function(x) { console.log(x) });\n```\n\n\n\n而，`main.js`被*tree shaking*编译之后，是长这样的：\n\n\n\n``` javascript\nfunction each(collection, iterator) {\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } else {\n    for (var key in collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n};\n\neach([1, 2, 3], function(x) {\n  console.log(x)\n});\n```\n\n\n\n注意到，只有我们使用的`each`被引入了，而不是`util.js`里所有的函数。\n\n\n\n那么，如果我们使用`filter`函数而不是`each`的话，我们的`main.js`:\n\n\n\n``` javascript\nimport * as Utils from ‘./utils.js’;\nUtils.filter([1, 2, 3], function(x) { return x === 2 });\n```\n\n\n\ntree shaking 编译后，`main.js`变成了这样：\n\n\n\n``` javascript\nfunction each(collection, iterator) {\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } else {\n    for (var key in collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n};\n\nfunction filter(collection, test) {\n  var filtered = [];\n  each(collection, function(item) {\n    if (test(item)) {\n      filtered.push(item);\n    }\n  });\n  return filtered;\n};\n\nfilter([1, 2, 3], function(x) {\n  return x === 2\n});\n```\n\n\n\n注意到这个时候,`each`和`filter`都被引入了，这是因为`filter`函数是依赖于`each`的。\n\n\n\n很cool，对不对？\n\n\n\n我建议你通过*Rollup.js*的 [live demo and editor](http://rollupjs.org/) ，去玩玩和了解一下tree shaking。\t\t\n\n\n\n## 构建ES6 modules\n\n好的，现在我们知道了ES6 modules的加载很其他module format是不同的，但是我们还没讲怎么构建ES6 modules。\n\n\n\n不幸的是，ES6 modules 还需要额外的工作，因为浏览器还没有实现原生的ES6 module加载。\n\n\n\n下面有两种方法来构建/转换 ES6 modules，使得在浏览器中可以使用。其中，第一种是当前最常见的：\n\n\n\n1. 使用转换器(比如，Babel或者Traceur)，把你ES6代码转换成CommonJS，AMD或者UMD格式的ES5代码。然后把转换好的代码送到一个module bundler里去，比如Browserify或者Webpack，这样就创建了一个或多个打包好的文件。\n2. 使用[Rollup.js](http://rollupjs.org/)：这种方法和前面的很相似，除了在打包之前会使用ES6 module的静态分析。他利用**tree shaking**把最少的代码量打包。总体来说，Rollup.js比Webpack或者Browserify最大的好处是，当你使用ES6 module时，可以使你的代码的体积更小。需要注意的是，Rollup提供了多种格式来打包你的代码，包括ES6，CommonJS，AMD，CMD，UMD或者IIFE。IIFE和UMD可以适用于你的浏览器，但如果你选择了AMD，CommonJS或者ES6的话，你需要找其他方法把你的代码转成浏览器可以识别的，比如使用Browserify，Webpack，RequireJS等等。\n\n\n\n## Jumping through hoops\n\n作为web开发者，我们需要跳过这些繁文缛节。因为把ES6 modules代码转换成浏览器可以解释的ES5不是一件易事。\n\n\n\n问题就是：我们可以直接在浏览器使用ES6 module，且不用弄上面说到的两种方法吗？\n\n\n\n答案是：很快。\n\n\n\nECMAScript现在已经有解决方案的规范了，叫做[ECMAScript 6 module loader API](https://github.com/ModuleLoader/es6-module-loader)。简单介绍，他是一种可编程的，基于Promise的API，可以动态加载你的modules，并且cache他们，使得随后的`import`不需要加载另外一份新版本的module。\n\n\n\n他大概是这样子的：\n\n\n\n``` javascript\n// myModule.js\n\nexport class myModule {\n  constructor() {\n    console.log('Hello, I am a module');\n  }\n  hello() {\n    console.log('hello!');\n  }\n  goodbye() {\n    console.log('goodbye!');\n  }\n}\n```\n\n\n\n``` javascript\n// main.js\n\nSystem.import(‘myModule’).then(function(myModule) {\n  new myModule.hello();\n});\n// ‘hello!’\n```\n\n\n\n另外一种方法是，你可以直接在`script`标签里，直接注明`type=module`来定义modules。\n\n\n\n``` javascript\n< script type = \"module\" >\n  // loads the 'myModule' export from 'mymodule.js'\n  import {\n    hello\n  } from 'mymodule';\nnew Hello(); // 'Hello, I am a module!'\n< /script>\n```\n\n\n\n如果你还没有看过module loader API的polyfill，我强烈建议你至少去[看一看](https://github.com/ModuleLoader/es6-module-loader)。\n\n\n\n如果你想要测试一下这种方法的话，你可以试试[SystemJS](https://github.com/systemjs/systemjs)。他是基于[ES6 Module Loader polyfill](https://github.com/ModuleLoader/es6-module-loader)创建的。他可以在浏览器和Node环境中，动态地加载任何格式的modules(ES6 modules，AMD，CommonJS以及全局的scripts)。他会跟踪所有已经加载到「module registry」的modules，避免了重新加载已经加载过的modules。值得提醒的是，他也可以自动地转换ES6 modules(如果你开启这个option的话)，还可以从任何一种模块格式中加载任何一种格式的模块。太棒了。\n\n\n\n## 既然我们已经有了ES6 modules，还需要bundlers吗？\n\nES6 modules的逐渐流行，产生了一些有趣的问题：\n\n\n\n### HTTP/2会使module bundlers过时吗？\n\n对于HTTP/1，我们的每个TCP连接只允许一个请求。这就是为什么加载多个资源需要多个请求。有了HTTP/2，一切都变了。HTTP/2是*fully multiplexed*，这就意味着多个请求和多个响应可以并行。这样一来，我们可以在一个TCP连接中，进行多个请求。\n\n\n\n既然每个HTTP/2请求的开销已经比HTTP/1小得多，那么长远来看，加载一堆的modules并不会降低很多的性能。于是有些人就认为，module bundling已经不需要了。这其实是有可能的，但是我们还要视情况而定。\n\n\n\n比如说，module bundling提供了HTTP/2没有提供的优点，像移除掉不需要的`exports`从而减少空间。如果你搭建的网页是每个微小的`bit`都会影响性能的话，那么bundling就给了你巨大的好处。另一方面，如果你对性能要求不是很高的话，你可以跳过构建过程，从而节省了一些时间。\n\n\n\n总起来说，我们现在离享受HTTP/2带来的好处还很远。我个人猜测build process还会持续一段时间。\n\n\n\n### CommonJS，AMD和UMD还过时吗？\n\n一旦ES6变成了标准，那么我们真的还需要非原生的module feature吗？\n\n\n\n我表示怀疑。\n\n\n\n如果只遵循单一的语法去加载和引入module，并且不需要中间步骤，这对于web开发者来说很棒的。但到达这一步还需要多久呢？\n\n\n\n机会是有的，但需要一段时间。\n\n\n\n并且，每个人都可以根据自己的口味去选择，因此「one truthful approach」并不会成为现实。\n\n\n\n## 结论\n\n当开发者讨论modules和module bundling的时候，我希望这两篇文章可以帮助他们厘清这些术语。如果你有疑问的话，你回头看看[part I](https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.y8hs0nsne) 。\n\n\n\n同样地，可以在评论中和我讨论，同时随时欢迎你提问题。\n\n\n\nHappy bundling :)\n\n\n**(原文：[JavaScript Modules Part 2: Module Bundling](https://medium.freecodecamp.com/javascript-modules-part-2-module-bundling-5020383cf306#.m5o3ar7dt))**\n","slug":"JavaScript-Modules-Part-2","published":1,"updated":"2016-02-08T08:12:23.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon8b0019qoreuiuq84v4"},{"title":"「译」JavaScript Modules Part1: A Beginner Guide","author":"Drake Leung","date":"2016-02-07T13:50:52.000Z","foreword":"超级详细地介绍了 JavaScript 模块化的进化历史。","_content":"\n**(原文：[JavaScript Modules: A Beginner's Guide - Preethi Kasireddy](https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.4ufizwkud))**\n\n\n如果你是刚接触 JavaScript 的话，像「module bundler vs. module loaders」， 「Webpack vs. Browserify」 以及「AMD vs. CommonJS」这些术语可以一下子把你搞晕。\n\nJavaScript的模块系统(module system)也许是很吓人的，但是对于web开发者来说，理解他是很重要的。\n\n在本文，我会使用通俗易懂的话(以及一些代码)来解释这些术语。我希望能帮助到你。\n\n注意：为了简单起见，我会分成2部分来说：Part 1 会解释什么是 *module* 以及为什么要使用他们。Part 2 (在下周发表)会接着解释什么是 *bundle modules* 以及其实现方法。\n\n\n## Part 1: 有谁可以再解释解释什么是 module 吗？\n\n好的作者会把他们的书籍分成多个章节；好的程序员也会把他们的程序分成多个模块。\n\n就像书的章节一样，module 只是单词(在这里，即是 code )的集合。\n\n但是，好的模块是高度包含自己独立的功能。这让他们可以根据需求更改，删除，增加，而不扰乱整个系统。\n\n## 为什么使用 module ？\n\n使用modules对于大型，相互依赖的代码库来说是很多好处的。在我看来，最重要的是：\n\n**1) 可维护性：**根据定义，module 是独立的。一个设计良好的 module 是尽可能多地减少代码的耦合，从而他能够独立地开发和改进。当一个 module 的耦合度低的时候，更新他是很容易一件事情。\n\n回到我们书籍的例子，当你因为更新了一个章节，从而需要调整剩余章节的话，这简直是噩耗。相反，你更愿意编写章节的时候，不影响其他章节。\n\n**2) 命名空间(namespacing)：**在 JavaScript 中，在 top-level 函数的作用域的外面的变量就是 *global* (全局)变量，全局变量即是每个人都可以 access 他们。因为这样，就很容易造成\"命名空间污染”，也就是无相关的代码共享全局变量。\n\n在毫无相关的代码中共享全局变量在开发中 [is a big no no](http://c2.com/cgi/wiki?GlobalVariablesAreBad)。\n\n在本文的下面，我们会解释 module 可以让我们避免命名空间污染，通过为我们的变量创建私有空间。\n\n**3) 可重用性：**我们不妨老实承认，我们过去是把一个项目的代码copy到另一个项目中。比方说，你copy了你之前项目的一些util方法到当前的项目中。\n\n这是很浪费时间的。但是慢着，如果使用 module ，一个我们可以不断复用的 module ，这不是很好吗？\n\n## 你是如何合并模块(incorporate modules)?\n\n有很多方法可以在你的程序中合并模块。我们现在就来讲解他们的其中一些：\n\n### Module Pattern\n\n*Module pattern* 其实就是模仿 *class* 的概念(因为 JavaScript 并不真正地支持 class )，因此我们可以把公有方法，私有方法以及变量都保存在一个对象里面——这个就有点类似于 class 在其他编程语言(如 Java 或者 Python )中的使用。这可以让我们给公有方法创建 API ，然后暴露出去；并且同时可以把私有的变量和方法都封装在一个闭包作用域(closure scope)中。\n\n有几个方法可以实现 module pattern。在第一个例子中。我会使用 *anonymous closure*。他会把我们所有的代码都放进一个匿名函数里面。(记住：在 JavaScript 中，`function` 是创建作用域的唯一方法？)\n\n**例子一：Anonymous closure**\n\n``` javascript\n(function () {\n  // We keep these variables private inside this closure scope\n\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  var average = function() {\n    var total = myGrades.reduce(function(accumulator, item) {\n      return accumulator + item}, 0);\n\n      return 'Your average grade is ' + total / myGrades.length + '.';\n  }\n\n  var failing = function(){\n    var failingGrades = myGrades.filter(function(item) {\n      return item < 70;});\n\n    return 'You failed ' + failingGrades.length + ' times.';\n  }\n\n  console.log(failing());\n\n}());\n\n// ‘You failed 2 times.’\n```\n\n有了这个，我们的匿名函数就有了它自己的求值环境(evaluation environment)或者\"closure\"，并且我们可以立马对他求值(evaluate)。这可以让我们从 parent namespace(global) 中隐藏变量。\n\n这种方法的好处就是，你可以在匿名函数中使用局部变量而不会 overwrite(覆盖) 已经存在的全局变量，但与此同时，你还可以 access 全局变量，就像这样：\n\n``` javascript\nvar global = 'Hello, I am a global variable :)';\n\n(function () {\n  // We keep these variables private inside this closure scope\n\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  var average = function() {\n    var total = myGrades.reduce(function(accumulator, item) {\n      return accumulator + item}, 0);\n\n    return 'Your average grade is ' + total / myGrades.length + '.';\n  }\n\n  var failing = function(){\n    var failingGrades = myGrades.filter(function(item) {\n      return item < 70;});\n\n    return 'You failed ' + failingGrades.length + ' times.';\n  }\n\n  console.log(failing());\n  console.log(global);\n}());\n\n// 'You failed 2 times.'\n// 'Hello, I am a global variable :)'\n```\n\n注意到在匿名函数2旁的括号是必须的，因为以关键字`function`开头的语句会被认为是 *function declaration* (记住，在 JavaScript 中，你是不能定义没有名字的function declaration。) 因此，这对括号就创建一个 *function expression*。如果不明白的话，你可以[阅读这里](http://stackoverflow.com/questions/1634268/explain-javascripts-encapsulated-anonymous-function-syntax)。\n\n**例子二：Global import**\n\n另一个较流行的方法是 *global import* ，就像 jQuery 一样。他有点类似于上面的　*anonymous closure*，只是现在我们把全局变量作为参数传进了匿名函数中。\n\n``` javascript\n(function (globalVariable) {\n\n  // Keep this variables private inside this closure scope\n  var privateFunction = function() {\n    console.log('Shhhh, this is private!');\n  }\n\n  // Expose the below methods via the globalVariable interface while\n  // hiding the implementation of the method within the\n  // function() block\n\n  globalVariable.each = function(collection, iterator) {\n    if (Array.isArray(collection)) {\n      for (var i = 0; i < collection.length; i++) {\n        iterator(collection[i], i, collection);\n      }\n    } else {\n      for (var key in collection) {\n        iterator(collection[key], key, collection);\n      }\n    }\n  };\n\n  globalVariable.filter = function(collection, test) {\n    var filtered = [];\n    globalVariable.each(collection, function(item) {\n      if (test(item)) {\n        filtered.push(item);\n      }\n    });\n    return filtered;\n  };\n\n  globalVariable.map = function(collection, iterator) {\n    var mapped = [];\n    globalUtils.each(collection, function(value, key, collection) {\n      mapped.push(iterator(value));\n    });\n    return mapped;\n  };\n\n  globalVariable.reduce = function(collection, iterator, accumulator) {\n    var startingValueMissing = accumulator === undefined;\n\n    globalVariable.each(collection, function(item) {\n      if(startingValueMissing) {\n        accumulator = item;\n        startingValueMissing = false;\n      } else {\n        accumulator = iterator(accumulator, item);\n      }\n    });\n\n    return accumulator;\n\n  };\n\n }(globalVariable));\n```\n\n在这个例子中，`globalVariable` 在全局中唯一的一个变量。这个方法比前一个方法好的地方在于：你可以在前面就定义全局变量，这样就方便别人阅读你的代码。\n\n**例子三：Object interface**\n\n创建 module 的例子还有一个就是使用独立的 *object interface*，就像这样：\n\n``` javascript\nvar myGradesCalculate = (function () {\n\n  // Keep this variable private inside this closure scope\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  // Expose these functions via an interface while hiding\n  // the implementation of the module within the function() block\n\n  return {\n    average: function() {\n      var total = myGrades.reduce(function(accumulator, item) {\n        return accumulator + item;\n        }, 0);\n\n      return'Your average grade is ' + total / myGrades.length + '.';\n    },\n\n    failing: function() {\n      var failingGrades = myGrades.filter(function(item) {\n          return item < 70;\n        });\n\n      return 'You failed ' + failingGrades.length + ' times.';\n    }\n  }\n})();\n\nmyGradesCalculate.failing(); // 'You failed 2 times.'\nmyGradesCalculate.average(); // 'Your average grade is 70.33333333333333.'\n```\n\n显而易见，这种方法可以让我们自己定义哪些变量/方法是私有的(例如，`myGrads`)，以及哪些变量/方法是我们想要暴露给他们的，通过 `return` 语句(比如，`average` & `failing`)。\n\n**例子四：Revealing module pattern**\n\n这个跟上面的方法是很相似的，除了他保证所有的变量和方法都是私有的，直到我们显式地暴露出去：\n\n``` javascript\nvar myGradesCalculate = (function () {\n\n  // Keep this variable private inside this closure scope\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  var average = function() {\n    var total = myGrades.reduce(function(accumulator, item) {\n      return accumulator + item;\n      }, 0);\n\n    return'Your average grade is ' + total / myGrades.length + '.';\n  };\n\n  var failing = function() {\n    var failingGrades = myGrades.filter(function(item) {\n        return item < 70;\n      });\n\n    return 'You failed ' + failingGrades.length + ' times.';\n  };\n\n  // Explicitly reveal public pointers to the private functions\n  // that we want to reveal publicly\n\n  return {\n    average: average,\n    failing: failing\n  }\n})();\n\nmyGradesCalculate.failing(); // 'You failed 2 times.'\nmyGradesCalculate.average(); // 'Your average grade is 70.33333333333333.'\n```\n\n上面好像讲了好多东西，其实对于 module pattern 来说，只是冰山一角。下面是一些我认为比较有用的资源：\n\n- [Learn JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript) - by *Addy Osmani*\n- [Adequately Good by Ben Cherry](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html) - 通过例子讲述module pattern的高级使用\n- [Blog of Carl Danley](https://carldanley.com/js-module-pattern/) - module pattern的概述以及其他 JavaScript pattern 的资源\n\n## CommonJS and AMD\n\n上面讲到的所有方法都有一个共同点：使用全局变量将其所有代码都封装在一个函数里面，从而使用 *closure scope* 为他自己创建出了一个私有的命名空间。\n\n他们各自有各自的优点，但是他们也有他们的弊端。\n\n其中一个，作为一名开发者，为了加载你的文件，你需要知道正确的依赖顺序。比如，你要在项目中使用 `Backbone`，那么你需要通过 `script` 标签来加载他的源文件。\n\n但是，因为 `Backbone` 是依赖 `Underscore.js`，那么加载 `Backbone` 的 `script` 标签就不能在 `Underscore` 的前面。\n\n作为一名开发者，维护依赖以及让他们的顺序都正确的话，有时是一件很头疼的事情。\n\n另一个弊端就是他们仍然会产生命名空间冲突。比如，你的两个 module 具有相同的名字。又或者，你的一个模块有两个版本，并且你同时需要他们。\n\n因此，你也会这样想到：能不能设计一种方法，既可以访问 module 的接口，但同时又不污染全局作用域。\n\n其实有两种已经实现好的方法：即是 CommonJS 和 AMD 。\n\n### CommonJS\n\nCommonJS是一个自愿的工作小组，设计和实现 JavaScript 模块系统的 API。\n\n一个 CommonJS 模块其实就是 `exports` 了具体对象的 JavaScript 代码块，使得他们能够被程序中的其他模块 `require` 。如果你写过 `Node.js` 的话，你应该对他很熟悉。\n\n有了 CommonJS，每个 JavaScript 文件在他们各自唯一的 module context (就像封装在一个闭包中)保存了模块。在这个作用域里面，我们使用 `module.exports` 对象来暴露模块，使用`require`来加载他们。\n\n当你定义了一个 CommonJS 文件，也许他就长这样子的：\n\n``` javascript\nfunction myModule() {\n  this.hello = function() {\n    return 'hello!';\n  }\n\n  this.goodbye = function() {\n    return 'goodbye!';\n  }\n}\n\nmodule.exports = myModule;\n```\n\n我们使用特殊的对象`module`，然后把我们函数的引用赋给`module.exports`。这个让CommonJS的模块系统知道我们想要暴露哪些，从而让别的文件引用。\n\n然后，如果别人想使用我的`myModule`，他们可以引用它到文件中，像这样：\n\n``` javascript\nvar myModule = require('myModule');\n\nvar myModuleInstance = new myModule();\nmyModuleInstance.hello(); // 'hello!'\nmyModuleInstance.goodbye(); // 'goodbye!'\n```\n\n这个方法比前面所讲的 *module pattern* 有2个明显的优点：\n\n1. 避免全局命名空间的污染\n2. 让我们的依赖更加清晰\n\n而且，语法很简洁，我很喜欢。\n\n还有一个注意的是，CommonJS是针对server实现的，并且**同步加载modules**。这是很重要的，因为如果我们有3个module需要引入，那么他会一个接着一个加载。\n\n现在，CommonJS对于server端很极好的。但是不幸的是，他不适用于浏览器。因为在web读取一个module比在磁盘中读取慢得多。如果开始加载module，就会阻塞浏览器直到modules全部加载完毕。(我会在 Part 2 讲述解决方法)。\n\n### AMD\n\nCommonJS是很好，但是如果我们想要异步加载modules呢？答案就是*Asynchronous Module Definition*，即*AMD*。\n\n使用AMD加载module就像这样：\n\n``` javascript\ndefine(['myModule', 'myOtherModule'], function(myModule, myOtherModule) {\n  console.log(myModule.hello());\n});\n```\n\n`define`函数的第一个参数是一个数组，他包含了所需的依赖。这些依赖会在背后加载(不会阻塞)，而且一旦加载完毕，`define`就会调用传给他的callback函数。\n\n接着，callback函数就会把加载好的依赖作为他的参数——在上面例子中，即是`myModule`和`myOtherModule`。最后，这些依赖他们自己必须通过关键字`define`来定义。\n\n比如，`myModule`也许是这样子的：\n\n``` javascript\ndefine([], function() {\n\n  return {\n    hello: function() {\n      console.log('hello');\n    },\n    goodbye: function() {\n      console.log('goodbye');\n    }\n  };\n});\n```\n\n不像CommonJS，AMD是以浏览器为核心来实现异步加载module的。(注意到，有很多人强烈地认为动态加载文件是不好的，这个我们在Part 2会讲到)。\n\n除了异步之外，AMD的另一个优点是，你的module可以是对象，函数，构造函数，字符串，JSON以及其他类型。而CommonJS只支持对象作为module。\n\n总的来说，AMD并不兼容io，文件系统，以及其他面向server的feature，并且，封装的语法比`require`较复杂一点。\n\n### UMD\n\n对于需要你同时支持AMD和CommonJS的项目，你可以选择*Universal Module Definition (UMD)*。\n\nUMD本质上创建了一个方式，支持他们其中的一种，也支持全局变量的定义。因此，UMD module可以同时在client和server端使用。\n\n让我们来看看UMD是怎样子的：\n\n``` javascript\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n      // AMD\n    define(['myModule', 'myOtherModule'], factory);\n  } else if (typeof exports === 'object') {\n      // CommonJS\n    module.exports = factory(require('myModule'), require('myOtherModule'));\n  } else {\n    // Browser globals (Note: root is window)\n    root.returnExports = factory(root.myModule, root.myOtherModule);\n  }\n}(this, function (myModule, myOtherModule) {\n  // Methods\n  function notHelloOrGoodbye(){}; // A private method\n  function hello(){}; // A public method because it's returned (see below)\n  function goodbye(){}; // A public method because it's returned (see below)\n\n  // Exposed public methods\n  return {\n      hello: hello,\n      goodbye: goodbye\n  }\n}));\n```\n\n更多关于UMD的例子，请查看 [enlightening repo](https://github.com/umdjs/umd)。\n\n## Native JS\n\n哈！你居然能看到这里，看来我没有搞晕你。太棒了。因为在结束之前，我们还有一个定义module的方法。\n\n如你所见，上面的方法没有一种是原生JavaScript支持的。相反，我们使用了各种各样的方式去模拟一个模块系统。\n\n幸运的是，在TC39工作的人(设计ECMAScript的语法和语义)在ES6实现了内置的模块系统。\n\n下面的资源很好地讲解了ES6的模块系统：\n\n- [jsmodules.io](http://jsmodules.io/cjs.html)\n- [exploringjs.com](http://exploringjs.com/es6/ch_modules.html)\n\nES6的module结合了CommonJS和AMD的优点，比如简洁的语法和异步加载。还有优点是，比如支持循环依赖。\n\n我最喜欢的ES6 modules的feature是，*imports*是*exports*的**live read-only views**(而CommonJS的import只是exports的一份copy而已，并且不是即时)。\n\n下面例子会讲述live read-only view是怎样子的：\n\n``` javascript\n// lib/counter.js\n\nvar counter = 1;\n\nfunction increment() {\n  counter++;\n}\n\nfunction decrement() {\n  counter--;\n}\n\nmodule.exports = {\n  counter: counter,\n  increment: increment,\n  decrement: decrement\n};\n\n\n// src/main.js\n\nvar counter = require('../../lib/counter');\n\ncounter.increment();\nconsole.log(counter.counter); // 1\n```\n\n在这个例子中，我们创建了module的**2份copy**：一个是当我们`export`他，另一个是当我们`require`他。\n\n并且，在`main.js`的那份copy已经和原本的失去连接了。这就是为什么当我们给`counter`增加时他还是`1`——因为我们`import`的`counter`已经和原来的失去联系。\n\n因为，增加`counter`会在原来的module可以实现，但是在你copy的那份就实现不了。如果想要后者实现的话，只能手动地操作了：\n\n``` javascript\ncounter.counter++;\nconsole.log(counter.counter); // 2\n```\n\n在另一个方面，ES6对于我们`import`的module创建了一个**live read-only view**。\n\n``` javascript\n// lib/counter.js\nexport let counter = 1;\n\nexport function increment() {\n  counter++;\n}\n\nexport function decrement() {\n  counter--;\n}\n\n\n// src/main.js\nimport * as counter from '../../counter';\n\nconsole.log(counter.counter); // 1\ncounter.increment();\nconsole.log(counter.counter); // 2\n```\n\n很cool，对吧。\n\n## 向前看：bunding modules\n\n哇。时间过得真快。我真的希望能够帮助你更好地理解JavaScript的modules。\n\n在下一部分，我会讲**module bundling**，涉及到几个核心的主题：\n\n- 为什么我们需要*module bundling*\n- 不同方法实现*bundling*\n- ECMAScript的模块加载器API\n- ...更多...\n\n注意：为了简单起见，我跳过了许多细节(比如，循环依赖)。如果我留下了很重要或者很棒的东西，请留言让我知道！\n\n\n**(原文：[JavaScript Modules: A Beginner’s Guide - Preethi Kasireddy](https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.4ufizwkud))**\n","source":"_posts/JavaScript-Module-A-Beginner-Guide.md","raw":"---\ntitle: '「译」JavaScript Modules Part1: A Beginner Guide'\nauthor: Drake Leung\ntags: []\ncategories: [翻译]\ndate: 2016-02-07 21:50:52\nforeword: 超级详细地介绍了 JavaScript 模块化的进化历史。\n---\n\n**(原文：[JavaScript Modules: A Beginner's Guide - Preethi Kasireddy](https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.4ufizwkud))**\n\n\n如果你是刚接触 JavaScript 的话，像「module bundler vs. module loaders」， 「Webpack vs. Browserify」 以及「AMD vs. CommonJS」这些术语可以一下子把你搞晕。\n\nJavaScript的模块系统(module system)也许是很吓人的，但是对于web开发者来说，理解他是很重要的。\n\n在本文，我会使用通俗易懂的话(以及一些代码)来解释这些术语。我希望能帮助到你。\n\n注意：为了简单起见，我会分成2部分来说：Part 1 会解释什么是 *module* 以及为什么要使用他们。Part 2 (在下周发表)会接着解释什么是 *bundle modules* 以及其实现方法。\n\n\n## Part 1: 有谁可以再解释解释什么是 module 吗？\n\n好的作者会把他们的书籍分成多个章节；好的程序员也会把他们的程序分成多个模块。\n\n就像书的章节一样，module 只是单词(在这里，即是 code )的集合。\n\n但是，好的模块是高度包含自己独立的功能。这让他们可以根据需求更改，删除，增加，而不扰乱整个系统。\n\n## 为什么使用 module ？\n\n使用modules对于大型，相互依赖的代码库来说是很多好处的。在我看来，最重要的是：\n\n**1) 可维护性：**根据定义，module 是独立的。一个设计良好的 module 是尽可能多地减少代码的耦合，从而他能够独立地开发和改进。当一个 module 的耦合度低的时候，更新他是很容易一件事情。\n\n回到我们书籍的例子，当你因为更新了一个章节，从而需要调整剩余章节的话，这简直是噩耗。相反，你更愿意编写章节的时候，不影响其他章节。\n\n**2) 命名空间(namespacing)：**在 JavaScript 中，在 top-level 函数的作用域的外面的变量就是 *global* (全局)变量，全局变量即是每个人都可以 access 他们。因为这样，就很容易造成\"命名空间污染”，也就是无相关的代码共享全局变量。\n\n在毫无相关的代码中共享全局变量在开发中 [is a big no no](http://c2.com/cgi/wiki?GlobalVariablesAreBad)。\n\n在本文的下面，我们会解释 module 可以让我们避免命名空间污染，通过为我们的变量创建私有空间。\n\n**3) 可重用性：**我们不妨老实承认，我们过去是把一个项目的代码copy到另一个项目中。比方说，你copy了你之前项目的一些util方法到当前的项目中。\n\n这是很浪费时间的。但是慢着，如果使用 module ，一个我们可以不断复用的 module ，这不是很好吗？\n\n## 你是如何合并模块(incorporate modules)?\n\n有很多方法可以在你的程序中合并模块。我们现在就来讲解他们的其中一些：\n\n### Module Pattern\n\n*Module pattern* 其实就是模仿 *class* 的概念(因为 JavaScript 并不真正地支持 class )，因此我们可以把公有方法，私有方法以及变量都保存在一个对象里面——这个就有点类似于 class 在其他编程语言(如 Java 或者 Python )中的使用。这可以让我们给公有方法创建 API ，然后暴露出去；并且同时可以把私有的变量和方法都封装在一个闭包作用域(closure scope)中。\n\n有几个方法可以实现 module pattern。在第一个例子中。我会使用 *anonymous closure*。他会把我们所有的代码都放进一个匿名函数里面。(记住：在 JavaScript 中，`function` 是创建作用域的唯一方法？)\n\n**例子一：Anonymous closure**\n\n``` javascript\n(function () {\n  // We keep these variables private inside this closure scope\n\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  var average = function() {\n    var total = myGrades.reduce(function(accumulator, item) {\n      return accumulator + item}, 0);\n\n      return 'Your average grade is ' + total / myGrades.length + '.';\n  }\n\n  var failing = function(){\n    var failingGrades = myGrades.filter(function(item) {\n      return item < 70;});\n\n    return 'You failed ' + failingGrades.length + ' times.';\n  }\n\n  console.log(failing());\n\n}());\n\n// ‘You failed 2 times.’\n```\n\n有了这个，我们的匿名函数就有了它自己的求值环境(evaluation environment)或者\"closure\"，并且我们可以立马对他求值(evaluate)。这可以让我们从 parent namespace(global) 中隐藏变量。\n\n这种方法的好处就是，你可以在匿名函数中使用局部变量而不会 overwrite(覆盖) 已经存在的全局变量，但与此同时，你还可以 access 全局变量，就像这样：\n\n``` javascript\nvar global = 'Hello, I am a global variable :)';\n\n(function () {\n  // We keep these variables private inside this closure scope\n\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  var average = function() {\n    var total = myGrades.reduce(function(accumulator, item) {\n      return accumulator + item}, 0);\n\n    return 'Your average grade is ' + total / myGrades.length + '.';\n  }\n\n  var failing = function(){\n    var failingGrades = myGrades.filter(function(item) {\n      return item < 70;});\n\n    return 'You failed ' + failingGrades.length + ' times.';\n  }\n\n  console.log(failing());\n  console.log(global);\n}());\n\n// 'You failed 2 times.'\n// 'Hello, I am a global variable :)'\n```\n\n注意到在匿名函数2旁的括号是必须的，因为以关键字`function`开头的语句会被认为是 *function declaration* (记住，在 JavaScript 中，你是不能定义没有名字的function declaration。) 因此，这对括号就创建一个 *function expression*。如果不明白的话，你可以[阅读这里](http://stackoverflow.com/questions/1634268/explain-javascripts-encapsulated-anonymous-function-syntax)。\n\n**例子二：Global import**\n\n另一个较流行的方法是 *global import* ，就像 jQuery 一样。他有点类似于上面的　*anonymous closure*，只是现在我们把全局变量作为参数传进了匿名函数中。\n\n``` javascript\n(function (globalVariable) {\n\n  // Keep this variables private inside this closure scope\n  var privateFunction = function() {\n    console.log('Shhhh, this is private!');\n  }\n\n  // Expose the below methods via the globalVariable interface while\n  // hiding the implementation of the method within the\n  // function() block\n\n  globalVariable.each = function(collection, iterator) {\n    if (Array.isArray(collection)) {\n      for (var i = 0; i < collection.length; i++) {\n        iterator(collection[i], i, collection);\n      }\n    } else {\n      for (var key in collection) {\n        iterator(collection[key], key, collection);\n      }\n    }\n  };\n\n  globalVariable.filter = function(collection, test) {\n    var filtered = [];\n    globalVariable.each(collection, function(item) {\n      if (test(item)) {\n        filtered.push(item);\n      }\n    });\n    return filtered;\n  };\n\n  globalVariable.map = function(collection, iterator) {\n    var mapped = [];\n    globalUtils.each(collection, function(value, key, collection) {\n      mapped.push(iterator(value));\n    });\n    return mapped;\n  };\n\n  globalVariable.reduce = function(collection, iterator, accumulator) {\n    var startingValueMissing = accumulator === undefined;\n\n    globalVariable.each(collection, function(item) {\n      if(startingValueMissing) {\n        accumulator = item;\n        startingValueMissing = false;\n      } else {\n        accumulator = iterator(accumulator, item);\n      }\n    });\n\n    return accumulator;\n\n  };\n\n }(globalVariable));\n```\n\n在这个例子中，`globalVariable` 在全局中唯一的一个变量。这个方法比前一个方法好的地方在于：你可以在前面就定义全局变量，这样就方便别人阅读你的代码。\n\n**例子三：Object interface**\n\n创建 module 的例子还有一个就是使用独立的 *object interface*，就像这样：\n\n``` javascript\nvar myGradesCalculate = (function () {\n\n  // Keep this variable private inside this closure scope\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  // Expose these functions via an interface while hiding\n  // the implementation of the module within the function() block\n\n  return {\n    average: function() {\n      var total = myGrades.reduce(function(accumulator, item) {\n        return accumulator + item;\n        }, 0);\n\n      return'Your average grade is ' + total / myGrades.length + '.';\n    },\n\n    failing: function() {\n      var failingGrades = myGrades.filter(function(item) {\n          return item < 70;\n        });\n\n      return 'You failed ' + failingGrades.length + ' times.';\n    }\n  }\n})();\n\nmyGradesCalculate.failing(); // 'You failed 2 times.'\nmyGradesCalculate.average(); // 'Your average grade is 70.33333333333333.'\n```\n\n显而易见，这种方法可以让我们自己定义哪些变量/方法是私有的(例如，`myGrads`)，以及哪些变量/方法是我们想要暴露给他们的，通过 `return` 语句(比如，`average` & `failing`)。\n\n**例子四：Revealing module pattern**\n\n这个跟上面的方法是很相似的，除了他保证所有的变量和方法都是私有的，直到我们显式地暴露出去：\n\n``` javascript\nvar myGradesCalculate = (function () {\n\n  // Keep this variable private inside this closure scope\n  var myGrades = [93, 95, 88, 0, 55, 91];\n\n  var average = function() {\n    var total = myGrades.reduce(function(accumulator, item) {\n      return accumulator + item;\n      }, 0);\n\n    return'Your average grade is ' + total / myGrades.length + '.';\n  };\n\n  var failing = function() {\n    var failingGrades = myGrades.filter(function(item) {\n        return item < 70;\n      });\n\n    return 'You failed ' + failingGrades.length + ' times.';\n  };\n\n  // Explicitly reveal public pointers to the private functions\n  // that we want to reveal publicly\n\n  return {\n    average: average,\n    failing: failing\n  }\n})();\n\nmyGradesCalculate.failing(); // 'You failed 2 times.'\nmyGradesCalculate.average(); // 'Your average grade is 70.33333333333333.'\n```\n\n上面好像讲了好多东西，其实对于 module pattern 来说，只是冰山一角。下面是一些我认为比较有用的资源：\n\n- [Learn JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript) - by *Addy Osmani*\n- [Adequately Good by Ben Cherry](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html) - 通过例子讲述module pattern的高级使用\n- [Blog of Carl Danley](https://carldanley.com/js-module-pattern/) - module pattern的概述以及其他 JavaScript pattern 的资源\n\n## CommonJS and AMD\n\n上面讲到的所有方法都有一个共同点：使用全局变量将其所有代码都封装在一个函数里面，从而使用 *closure scope* 为他自己创建出了一个私有的命名空间。\n\n他们各自有各自的优点，但是他们也有他们的弊端。\n\n其中一个，作为一名开发者，为了加载你的文件，你需要知道正确的依赖顺序。比如，你要在项目中使用 `Backbone`，那么你需要通过 `script` 标签来加载他的源文件。\n\n但是，因为 `Backbone` 是依赖 `Underscore.js`，那么加载 `Backbone` 的 `script` 标签就不能在 `Underscore` 的前面。\n\n作为一名开发者，维护依赖以及让他们的顺序都正确的话，有时是一件很头疼的事情。\n\n另一个弊端就是他们仍然会产生命名空间冲突。比如，你的两个 module 具有相同的名字。又或者，你的一个模块有两个版本，并且你同时需要他们。\n\n因此，你也会这样想到：能不能设计一种方法，既可以访问 module 的接口，但同时又不污染全局作用域。\n\n其实有两种已经实现好的方法：即是 CommonJS 和 AMD 。\n\n### CommonJS\n\nCommonJS是一个自愿的工作小组，设计和实现 JavaScript 模块系统的 API。\n\n一个 CommonJS 模块其实就是 `exports` 了具体对象的 JavaScript 代码块，使得他们能够被程序中的其他模块 `require` 。如果你写过 `Node.js` 的话，你应该对他很熟悉。\n\n有了 CommonJS，每个 JavaScript 文件在他们各自唯一的 module context (就像封装在一个闭包中)保存了模块。在这个作用域里面，我们使用 `module.exports` 对象来暴露模块，使用`require`来加载他们。\n\n当你定义了一个 CommonJS 文件，也许他就长这样子的：\n\n``` javascript\nfunction myModule() {\n  this.hello = function() {\n    return 'hello!';\n  }\n\n  this.goodbye = function() {\n    return 'goodbye!';\n  }\n}\n\nmodule.exports = myModule;\n```\n\n我们使用特殊的对象`module`，然后把我们函数的引用赋给`module.exports`。这个让CommonJS的模块系统知道我们想要暴露哪些，从而让别的文件引用。\n\n然后，如果别人想使用我的`myModule`，他们可以引用它到文件中，像这样：\n\n``` javascript\nvar myModule = require('myModule');\n\nvar myModuleInstance = new myModule();\nmyModuleInstance.hello(); // 'hello!'\nmyModuleInstance.goodbye(); // 'goodbye!'\n```\n\n这个方法比前面所讲的 *module pattern* 有2个明显的优点：\n\n1. 避免全局命名空间的污染\n2. 让我们的依赖更加清晰\n\n而且，语法很简洁，我很喜欢。\n\n还有一个注意的是，CommonJS是针对server实现的，并且**同步加载modules**。这是很重要的，因为如果我们有3个module需要引入，那么他会一个接着一个加载。\n\n现在，CommonJS对于server端很极好的。但是不幸的是，他不适用于浏览器。因为在web读取一个module比在磁盘中读取慢得多。如果开始加载module，就会阻塞浏览器直到modules全部加载完毕。(我会在 Part 2 讲述解决方法)。\n\n### AMD\n\nCommonJS是很好，但是如果我们想要异步加载modules呢？答案就是*Asynchronous Module Definition*，即*AMD*。\n\n使用AMD加载module就像这样：\n\n``` javascript\ndefine(['myModule', 'myOtherModule'], function(myModule, myOtherModule) {\n  console.log(myModule.hello());\n});\n```\n\n`define`函数的第一个参数是一个数组，他包含了所需的依赖。这些依赖会在背后加载(不会阻塞)，而且一旦加载完毕，`define`就会调用传给他的callback函数。\n\n接着，callback函数就会把加载好的依赖作为他的参数——在上面例子中，即是`myModule`和`myOtherModule`。最后，这些依赖他们自己必须通过关键字`define`来定义。\n\n比如，`myModule`也许是这样子的：\n\n``` javascript\ndefine([], function() {\n\n  return {\n    hello: function() {\n      console.log('hello');\n    },\n    goodbye: function() {\n      console.log('goodbye');\n    }\n  };\n});\n```\n\n不像CommonJS，AMD是以浏览器为核心来实现异步加载module的。(注意到，有很多人强烈地认为动态加载文件是不好的，这个我们在Part 2会讲到)。\n\n除了异步之外，AMD的另一个优点是，你的module可以是对象，函数，构造函数，字符串，JSON以及其他类型。而CommonJS只支持对象作为module。\n\n总的来说，AMD并不兼容io，文件系统，以及其他面向server的feature，并且，封装的语法比`require`较复杂一点。\n\n### UMD\n\n对于需要你同时支持AMD和CommonJS的项目，你可以选择*Universal Module Definition (UMD)*。\n\nUMD本质上创建了一个方式，支持他们其中的一种，也支持全局变量的定义。因此，UMD module可以同时在client和server端使用。\n\n让我们来看看UMD是怎样子的：\n\n``` javascript\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n      // AMD\n    define(['myModule', 'myOtherModule'], factory);\n  } else if (typeof exports === 'object') {\n      // CommonJS\n    module.exports = factory(require('myModule'), require('myOtherModule'));\n  } else {\n    // Browser globals (Note: root is window)\n    root.returnExports = factory(root.myModule, root.myOtherModule);\n  }\n}(this, function (myModule, myOtherModule) {\n  // Methods\n  function notHelloOrGoodbye(){}; // A private method\n  function hello(){}; // A public method because it's returned (see below)\n  function goodbye(){}; // A public method because it's returned (see below)\n\n  // Exposed public methods\n  return {\n      hello: hello,\n      goodbye: goodbye\n  }\n}));\n```\n\n更多关于UMD的例子，请查看 [enlightening repo](https://github.com/umdjs/umd)。\n\n## Native JS\n\n哈！你居然能看到这里，看来我没有搞晕你。太棒了。因为在结束之前，我们还有一个定义module的方法。\n\n如你所见，上面的方法没有一种是原生JavaScript支持的。相反，我们使用了各种各样的方式去模拟一个模块系统。\n\n幸运的是，在TC39工作的人(设计ECMAScript的语法和语义)在ES6实现了内置的模块系统。\n\n下面的资源很好地讲解了ES6的模块系统：\n\n- [jsmodules.io](http://jsmodules.io/cjs.html)\n- [exploringjs.com](http://exploringjs.com/es6/ch_modules.html)\n\nES6的module结合了CommonJS和AMD的优点，比如简洁的语法和异步加载。还有优点是，比如支持循环依赖。\n\n我最喜欢的ES6 modules的feature是，*imports*是*exports*的**live read-only views**(而CommonJS的import只是exports的一份copy而已，并且不是即时)。\n\n下面例子会讲述live read-only view是怎样子的：\n\n``` javascript\n// lib/counter.js\n\nvar counter = 1;\n\nfunction increment() {\n  counter++;\n}\n\nfunction decrement() {\n  counter--;\n}\n\nmodule.exports = {\n  counter: counter,\n  increment: increment,\n  decrement: decrement\n};\n\n\n// src/main.js\n\nvar counter = require('../../lib/counter');\n\ncounter.increment();\nconsole.log(counter.counter); // 1\n```\n\n在这个例子中，我们创建了module的**2份copy**：一个是当我们`export`他，另一个是当我们`require`他。\n\n并且，在`main.js`的那份copy已经和原本的失去连接了。这就是为什么当我们给`counter`增加时他还是`1`——因为我们`import`的`counter`已经和原来的失去联系。\n\n因为，增加`counter`会在原来的module可以实现，但是在你copy的那份就实现不了。如果想要后者实现的话，只能手动地操作了：\n\n``` javascript\ncounter.counter++;\nconsole.log(counter.counter); // 2\n```\n\n在另一个方面，ES6对于我们`import`的module创建了一个**live read-only view**。\n\n``` javascript\n// lib/counter.js\nexport let counter = 1;\n\nexport function increment() {\n  counter++;\n}\n\nexport function decrement() {\n  counter--;\n}\n\n\n// src/main.js\nimport * as counter from '../../counter';\n\nconsole.log(counter.counter); // 1\ncounter.increment();\nconsole.log(counter.counter); // 2\n```\n\n很cool，对吧。\n\n## 向前看：bunding modules\n\n哇。时间过得真快。我真的希望能够帮助你更好地理解JavaScript的modules。\n\n在下一部分，我会讲**module bundling**，涉及到几个核心的主题：\n\n- 为什么我们需要*module bundling*\n- 不同方法实现*bundling*\n- ECMAScript的模块加载器API\n- ...更多...\n\n注意：为了简单起见，我跳过了许多细节(比如，循环依赖)。如果我留下了很重要或者很棒的东西，请留言让我知道！\n\n\n**(原文：[JavaScript Modules: A Beginner’s Guide - Preethi Kasireddy](https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.4ufizwkud))**\n","slug":"JavaScript-Module-A-Beginner-Guide","published":1,"updated":"2016-02-08T08:13:16.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon8h001cqoreaypk9d12"},{"title":"笨方法学 JavaScript - This 关键字","date":"2015-06-09T07:09:05.000Z","author":"Drake Leung","foreword":"this系列第一篇, 主要讲解了this在5种模式下的不同取值.","_content":"\n## 2 个常见的误解\n第一个普遍错误就是认为`this`是指向这个`function`本身。举个例子:\n```javascript\nfunction foo() {\n  this.count++;\n}\n\nfoo.count = 0;\nfor (var i = 0; i < 5; i++) {\n  foo();\n}\n\nconsole.log(foo.count); // not 5 but 0\n```\n\n这样的话，有没有其他办法可以解决呢？如果不用`this`的话，我们可以新创建一个对象。\n```javascript\nfunction foo() {\n  data.count++;\n}\nvar data = {\n  count: 0;\n};\n\n// same to the example above\n```\n还有一个解决方法,直接用`foo`他本身。\n```javascript\nfunction foo() {\n  foo.count++;\n}\n```\n虽然上面２种方法都解决了问题，但是他们都逃避了`this`。这不是我们想要的。　　\n再来看下面的解决方法: 使用`call`。\n```javascript\nfor (var i = 0; i < 5; i++) {\n  foo.call(foo);\n}\n```\n\n### Its Scope\n还有一个误解就是认为`this`指向这个函数的作用域。\n```javascript\nfunction foo() {\n  var loved = true;\n  bar();\n}\n\nfunction bar() {\n  console.log(this.loved);\n}\n\nfoo(); // ReferenceError: loved is not defined\n```\n\n## What is this\n事实上`this`并不是在函数定义的就绑定好的(**author-time binding**)，而是在函数调用的时候才绑定好(**runtime binding**)\n\n也就是说，`this`的值跟函数的定义一毛钱的关系都没有，而是取决于函数是在哪里被调用的(**call-site**)\n```javascript\nfunction foo() {\n  bar() // call-site for bar\n}\n\nfoo()  // call-site for 'foo'\n```\n\n## 4 Rules\n上面说了`this`的值取决与函数的call-site。因此，我们总结了４种**invoke pattern**(not define pattern)\n\n### Default Binding\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar loved = true;\n\nfoo(); // true\n```\n从上面的例子可以看出，`this`是指向`global object`(or `window`)。也就是说，当一个函数以**函数名加括号**(`foo()`)的这个形式被调用的话，他的`this`就指向`globol object`。\n\nP.S.如果在严格模式下, `this`的值会是`undefined`而不是`global object`。\n\n### Implicit Binding\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar ex = {\n  loved: true,\n  foo: foo\n};\n\nex.foo();  // true\n```\n如果是调用一个对象的方法的话，`this`就隐式地指向这个对象本身。所以上面的`this`指向`ex`对象。并且是指向离他最近的对象，就近原则。所以下面的例子`this`是指向`next`而不是`ex`。\n```javascript\nvar ex = {\n  loved: true,\n  next: {\n    loved: false,\n    foo: foo\n  }\n};\n\nex.next.foo(); // not true but false\n```\n**但，这个隐式绑定有可能会出现意外**。尤其是传给一个callback function的时候。\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar ex = {\n  loved: true,\n  foo: foo\n};\n\nwindow.loved = false;\nsetTimeout(ex.foo, 100); // false\n```\n其实`setTiemout`的函数是这样的:\n```javascript\nfunction setTimeout(fn, delay) {\n  // something\n  fn();  // call-site !!!\n}\n```\n由于`fn()`这种invoke pattern属于第一种，所以他是绑定到`global object`。\n\n虽然`this`的值是符合我们所讲的，但是这并不是我想要的东西，因为我想打印出就是`ex.loved`这个field，而不是`global object`。\n\n### Explicit Binding\n我们将会使用到`call`, `apply`和`bind`。\n\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar ex = {\n  loved: true\n}\n\nfoo.call(ex); // true\n```\n\n那么，我们要怎样解决上面那个问题呢？我们需要**hard binding**。  \n我们需要用另外一个函数来作为wrapper，\n```javascript\nfunction bar() {\n  foo.call(ex);\n}\n\nbar(); // true\nsetTimeout(bar, 100); // true\nbar.call(window); // true\n```\n\n因为*hard binding*经常用，所以ES5提供了一个方法: `bind()`。因此，我们可以这样:\n```javascript\nvar bar = foo.bind(ex);\nsetTimeout(bar, 100); // true\n```\n### New Binding\n当一个函数在调用的时候前面有个`new` keyword，`this`就被绑定到这个constructed object。\n```javascript\nfunction Ex() {\n  this.loved = true;\n}\nvar ex = new Ex();\nconsole.log(ex.loved);\n```\n既然`this`怎么麻烦，为什么就不能简单一点啊？\n\n## Arrow function\n在`=>`中，`this`是绑定在**lexical scope**，也就是`this`取决于函数在哪里定义，而不是函数在哪里调用。并且，`this`一旦决定是不会改变的，也就是说`call`, `bind`这些方法都不起作用了。\n```javascript\nvar ex = {\n  loved: true,\n\n  foo() {\n    setTimeout(() => {\n      console.log(this.loved);\n    }, 10.24);\n  }\n}\n\nex.foo(); // true\n```\n\n## Reference\n[You dont know JavaScript - This](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes) chapter\n","source":"_posts/JavaScript-For-Kids-This.md","raw":"---\ntitle: 笨方法学 JavaScript - This 关键字\ndate: 2015-06-09 15:09:05\n\nauthor: Drake Leung\ntags: This\ncategories: JavaScript\nforeword:\n  this系列第一篇, 主要讲解了this在5种模式下的不同取值.\n---\n\n## 2 个常见的误解\n第一个普遍错误就是认为`this`是指向这个`function`本身。举个例子:\n```javascript\nfunction foo() {\n  this.count++;\n}\n\nfoo.count = 0;\nfor (var i = 0; i < 5; i++) {\n  foo();\n}\n\nconsole.log(foo.count); // not 5 but 0\n```\n\n这样的话，有没有其他办法可以解决呢？如果不用`this`的话，我们可以新创建一个对象。\n```javascript\nfunction foo() {\n  data.count++;\n}\nvar data = {\n  count: 0;\n};\n\n// same to the example above\n```\n还有一个解决方法,直接用`foo`他本身。\n```javascript\nfunction foo() {\n  foo.count++;\n}\n```\n虽然上面２种方法都解决了问题，但是他们都逃避了`this`。这不是我们想要的。　　\n再来看下面的解决方法: 使用`call`。\n```javascript\nfor (var i = 0; i < 5; i++) {\n  foo.call(foo);\n}\n```\n\n### Its Scope\n还有一个误解就是认为`this`指向这个函数的作用域。\n```javascript\nfunction foo() {\n  var loved = true;\n  bar();\n}\n\nfunction bar() {\n  console.log(this.loved);\n}\n\nfoo(); // ReferenceError: loved is not defined\n```\n\n## What is this\n事实上`this`并不是在函数定义的就绑定好的(**author-time binding**)，而是在函数调用的时候才绑定好(**runtime binding**)\n\n也就是说，`this`的值跟函数的定义一毛钱的关系都没有，而是取决于函数是在哪里被调用的(**call-site**)\n```javascript\nfunction foo() {\n  bar() // call-site for bar\n}\n\nfoo()  // call-site for 'foo'\n```\n\n## 4 Rules\n上面说了`this`的值取决与函数的call-site。因此，我们总结了４种**invoke pattern**(not define pattern)\n\n### Default Binding\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar loved = true;\n\nfoo(); // true\n```\n从上面的例子可以看出，`this`是指向`global object`(or `window`)。也就是说，当一个函数以**函数名加括号**(`foo()`)的这个形式被调用的话，他的`this`就指向`globol object`。\n\nP.S.如果在严格模式下, `this`的值会是`undefined`而不是`global object`。\n\n### Implicit Binding\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar ex = {\n  loved: true,\n  foo: foo\n};\n\nex.foo();  // true\n```\n如果是调用一个对象的方法的话，`this`就隐式地指向这个对象本身。所以上面的`this`指向`ex`对象。并且是指向离他最近的对象，就近原则。所以下面的例子`this`是指向`next`而不是`ex`。\n```javascript\nvar ex = {\n  loved: true,\n  next: {\n    loved: false,\n    foo: foo\n  }\n};\n\nex.next.foo(); // not true but false\n```\n**但，这个隐式绑定有可能会出现意外**。尤其是传给一个callback function的时候。\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar ex = {\n  loved: true,\n  foo: foo\n};\n\nwindow.loved = false;\nsetTimeout(ex.foo, 100); // false\n```\n其实`setTiemout`的函数是这样的:\n```javascript\nfunction setTimeout(fn, delay) {\n  // something\n  fn();  // call-site !!!\n}\n```\n由于`fn()`这种invoke pattern属于第一种，所以他是绑定到`global object`。\n\n虽然`this`的值是符合我们所讲的，但是这并不是我想要的东西，因为我想打印出就是`ex.loved`这个field，而不是`global object`。\n\n### Explicit Binding\n我们将会使用到`call`, `apply`和`bind`。\n\n```javascript\nfunction foo() {\n  console.log(this.loved);\n}\n\nvar ex = {\n  loved: true\n}\n\nfoo.call(ex); // true\n```\n\n那么，我们要怎样解决上面那个问题呢？我们需要**hard binding**。  \n我们需要用另外一个函数来作为wrapper，\n```javascript\nfunction bar() {\n  foo.call(ex);\n}\n\nbar(); // true\nsetTimeout(bar, 100); // true\nbar.call(window); // true\n```\n\n因为*hard binding*经常用，所以ES5提供了一个方法: `bind()`。因此，我们可以这样:\n```javascript\nvar bar = foo.bind(ex);\nsetTimeout(bar, 100); // true\n```\n### New Binding\n当一个函数在调用的时候前面有个`new` keyword，`this`就被绑定到这个constructed object。\n```javascript\nfunction Ex() {\n  this.loved = true;\n}\nvar ex = new Ex();\nconsole.log(ex.loved);\n```\n既然`this`怎么麻烦，为什么就不能简单一点啊？\n\n## Arrow function\n在`=>`中，`this`是绑定在**lexical scope**，也就是`this`取决于函数在哪里定义，而不是函数在哪里调用。并且，`this`一旦决定是不会改变的，也就是说`call`, `bind`这些方法都不起作用了。\n```javascript\nvar ex = {\n  loved: true,\n\n  foo() {\n    setTimeout(() => {\n      console.log(this.loved);\n    }, 10.24);\n  }\n}\n\nex.foo(); // true\n```\n\n## Reference\n[You dont know JavaScript - This](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes) chapter\n","slug":"JavaScript-For-Kids-This","published":1,"updated":"2016-02-24T18:31:15.599Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon8n001eqoredc2xq2rm"},{"title":"Medium 是如何加载图片的？","author":"Drake Leung","date":"2016-03-01T09:11:29.000Z","foreword":"分析及实现 Medium 加载图片的效果。","_content":"\n\n## What\n\n首先，我们来看看 Medium 加载图片的效果是怎样子的：\n\n{% vimeo 157258221 %}\n\n我的[博客首页](http://drakeleung.github.io/blog/)也实现了这种效果。下面我们就分析如何实现。\n\n## How\n我们随便打开 Medium 中有图片的[页面](https://medium.com/tag/javascript)，然后 *审查元素*，就可以得到：\n\n{% asset_img inspect.png %}\n\n简化之后得到：\n\n```html\n<section>\n  <div class=\"placeholder\"></div>\n  <div class=\"prossiveMedia\">\n    <img class=\"img-samll\">\n    <canvas></canvas>\n    <img class=\"img-large\">\n  </div>\n</section>\n```\n\n实现的过程大致如下：\n\n1. 使用一个 `placeholder` 来防止图片 *collapse*。\n2. 先加载一个很小的图片\n3. 当这个小图片加载完毕之后，把他画在 `<canvas>` 里面，然后把图片弄模糊。\n4. 当大图片加载完毕之后，显示他。\n\n\n## Do it\n\n首先，HTML 结构如下：\n\n```html\n<section class=\"banner\">\n  <div class=\"placeholder\"></div>\n  <img\n    class=\"img-small\"\n    src=\"https://cdn-images-1.medium.com/freeze/max/27/1*sg-uLNm73whmdOgKlrQdZA.jpeg?q=20\"\n    data-large=\"https://cdn-images-1.medium.com/max/1800/1*sg-uLNm73whmdOgKlrQdZA.jpeg\"\n   >\n</section>\n```\n\n`.placeholder` 是用来撑起 `.banner` 的高度。因为如果我们想要让两张图片重叠的话，会用到 `position: absolute`，定位元素会脱离文档流，那么 `.banner` 的高度就会为 `0`。\n\n`.img-small` 首先加载的是小图片。大图片的 URL 放在了 `data-large` 属性里面。\n\n接下来是，CSS部分：\n\n```CSS\n.banner {\n  position: relative;\n  overflow: hidden;\n}\n\n.placeholder {\n  padding-bottom: 66.6%;\n}\n\nimg {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  opacity: 0;\n  transition: opacity 1s linear;\n}\n\nimg.loaded {\n  opacity: 1;\n}\n\n.img-small {\n  filter: blur(50px);\n  -webkit-filter: blur(50px);\n}\n```\n\n`.banner` 设置了 `relative`，所以他成为了他 children (`.placeholder`, `img`) 的 *containning block* 了。\n\n注意到，`.placeholder` 设置了 `padding-bottom: 66.6%`。`66.6%` 是相对于他的 *containning block* 的宽度，也就是 `.banner` 的宽度。\n这个值应该和 `img` 的高度一样，这样一来，`.banner` 的高度就是 `img` 的高度了。\n\n利用 `transition` 让透明度变化有个渐变效果。\n\n实现模糊效果是使用了 `filter: blur()`，而没有使用 `<canvas>`。\n\n然后，JavaScript 代码部分比较简单：\n\n```javascript\nconst app = (() => {\n  const imgSmall = document.querySelector('.img-small')\n\n  const loadImage = () => {\n    const img = new Image()\n\n    img.src = imgSmall.src\n    img.addEventListener('load', (e) => {\n      imgSmall.classList.add('loaded')\n    }, false)\n\n    const imgLarge = new Image()\n\n    imgLarge.src = imgSmall.dataset.large\n    imgLarge.addEventListener('load', (e) => {\n      imgLarge.classList.add('loaded')\n    }, false)\n\n    imgSmall.parentNode.appendChild(imgLarge)\n  }\n\n  return {\n    loadImage\n  }\n\n})()\n\napp.loadImage()\n```\n\n需要注意的是，我们不能直接监听 `.img-small` 的 `load` 事件，要 `new Image`，然后赋予其 `src`，然后我们就可以监听他的 `load` 事件了。\n\n最后，为了凸显效果，我们要禁止缓存和设置较差的网络环境。具体做法如图：\n\n{% asset_img network.png %}\n\n实际效果如下：\n{% jsfiddle 5sLzjk99 %}\n\n## Resources\n- [How Medium does progressive image loading](https://jmperezperez.com/medium-image-progressive-loading-placeholder/)\n","source":"_posts/How-Medium-Load-Images.md","raw":"---\ntitle: Medium 是如何加载图片的？\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-03-01 17:11:29\nforeword: 分析及实现 Medium 加载图片的效果。\n---\n\n\n## What\n\n首先，我们来看看 Medium 加载图片的效果是怎样子的：\n\n{% vimeo 157258221 %}\n\n我的[博客首页](http://drakeleung.github.io/blog/)也实现了这种效果。下面我们就分析如何实现。\n\n## How\n我们随便打开 Medium 中有图片的[页面](https://medium.com/tag/javascript)，然后 *审查元素*，就可以得到：\n\n{% asset_img inspect.png %}\n\n简化之后得到：\n\n```html\n<section>\n  <div class=\"placeholder\"></div>\n  <div class=\"prossiveMedia\">\n    <img class=\"img-samll\">\n    <canvas></canvas>\n    <img class=\"img-large\">\n  </div>\n</section>\n```\n\n实现的过程大致如下：\n\n1. 使用一个 `placeholder` 来防止图片 *collapse*。\n2. 先加载一个很小的图片\n3. 当这个小图片加载完毕之后，把他画在 `<canvas>` 里面，然后把图片弄模糊。\n4. 当大图片加载完毕之后，显示他。\n\n\n## Do it\n\n首先，HTML 结构如下：\n\n```html\n<section class=\"banner\">\n  <div class=\"placeholder\"></div>\n  <img\n    class=\"img-small\"\n    src=\"https://cdn-images-1.medium.com/freeze/max/27/1*sg-uLNm73whmdOgKlrQdZA.jpeg?q=20\"\n    data-large=\"https://cdn-images-1.medium.com/max/1800/1*sg-uLNm73whmdOgKlrQdZA.jpeg\"\n   >\n</section>\n```\n\n`.placeholder` 是用来撑起 `.banner` 的高度。因为如果我们想要让两张图片重叠的话，会用到 `position: absolute`，定位元素会脱离文档流，那么 `.banner` 的高度就会为 `0`。\n\n`.img-small` 首先加载的是小图片。大图片的 URL 放在了 `data-large` 属性里面。\n\n接下来是，CSS部分：\n\n```CSS\n.banner {\n  position: relative;\n  overflow: hidden;\n}\n\n.placeholder {\n  padding-bottom: 66.6%;\n}\n\nimg {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  opacity: 0;\n  transition: opacity 1s linear;\n}\n\nimg.loaded {\n  opacity: 1;\n}\n\n.img-small {\n  filter: blur(50px);\n  -webkit-filter: blur(50px);\n}\n```\n\n`.banner` 设置了 `relative`，所以他成为了他 children (`.placeholder`, `img`) 的 *containning block* 了。\n\n注意到，`.placeholder` 设置了 `padding-bottom: 66.6%`。`66.6%` 是相对于他的 *containning block* 的宽度，也就是 `.banner` 的宽度。\n这个值应该和 `img` 的高度一样，这样一来，`.banner` 的高度就是 `img` 的高度了。\n\n利用 `transition` 让透明度变化有个渐变效果。\n\n实现模糊效果是使用了 `filter: blur()`，而没有使用 `<canvas>`。\n\n然后，JavaScript 代码部分比较简单：\n\n```javascript\nconst app = (() => {\n  const imgSmall = document.querySelector('.img-small')\n\n  const loadImage = () => {\n    const img = new Image()\n\n    img.src = imgSmall.src\n    img.addEventListener('load', (e) => {\n      imgSmall.classList.add('loaded')\n    }, false)\n\n    const imgLarge = new Image()\n\n    imgLarge.src = imgSmall.dataset.large\n    imgLarge.addEventListener('load', (e) => {\n      imgLarge.classList.add('loaded')\n    }, false)\n\n    imgSmall.parentNode.appendChild(imgLarge)\n  }\n\n  return {\n    loadImage\n  }\n\n})()\n\napp.loadImage()\n```\n\n需要注意的是，我们不能直接监听 `.img-small` 的 `load` 事件，要 `new Image`，然后赋予其 `src`，然后我们就可以监听他的 `load` 事件了。\n\n最后，为了凸显效果，我们要禁止缓存和设置较差的网络环境。具体做法如图：\n\n{% asset_img network.png %}\n\n实际效果如下：\n{% jsfiddle 5sLzjk99 %}\n\n## Resources\n- [How Medium does progressive image loading](https://jmperezperez.com/medium-image-progressive-loading-placeholder/)\n","slug":"How-Medium-Load-Images","published":1,"updated":"2016-03-01T13:39:16.445Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon8r001iqoredc46dgnm"},{"title":"ES6 In Practice(0) - watch a demo","author":"Drake Leung","date":"2015-06-18T08:02:11.000Z","foreword":"通过视频JavaScript 2015来实践一个demo, 利用的包管理器是jspm.","_content":"\n吃完半个西瓜，太饱。于是上yutube，然后搜了`es6 tutorial`，发现了一个30k+ views的[JavaScript In 2015](https://youtu.be/iukBMY4apvI)视频。遂看，**收货良多**。\n\n## live-server\n[live-server](https://www.npmjs.com/package/live-server)这个package，可以帮助我们快速建立一个可以**live reload**的静态服务器。\n\n## jspm\n[jspm](http://jspm.io/)是一个package manager，可以帮助我们快速建立ES6的使用环境。让我们来看一下官方文档的[getting start](https://github.com/jspm/jspm-cli/wiki/Getting-Started)\n\n```html\n <!doctype html>\n  // 需要引入这2个js文件\n  <script src=\"jspm_packages/system.js\"></script>\n  <script src=\"config.js\"></script>\n\n  // 下面是我们自己的js文件\n  <script>\n    System.import('lib/main');\n  </script>\n```\n\n## reddit api\n这里用了一个[jsonp](https://www.npmjs.com/package/jsonp) package，来发起jsonp请求。我们使用`jspm install npm:jsonp`来安装。\n\n**使用reddit api**: 只要在每个`r`后面加`.json`。比如: `https://www.reddit.com/r/pics.json`。然后还要传`param: 'jsonp'`的参数。\n\n```javascript\nclass RedditApi {\n  constructor() {\n    this.redditURL = 'https://www.reddit.com/r/pics.json';\n  }\n\n  load() {\n    return new Promise((resolve, reject) => {\n      jsonp(this.redditURL, {param: 'jsonp'}, (err, data) => {\n        err ? reject(err) : resolve(data.data.children);\n      });\n    });\n  }\n}\n```\n说到API，突然想起[codeacademy](http://www.codecademy.com/learn)上面好像又好多教学，赶紧去一下先。\n\n## Extract Pictures\n利用`Array.map`和`Array.filter`来获取和过滤图片。以前一直不知道这２个函数怎么用。\n```javascript\nexport default (posts) => {\n  return posts\n    .map(post => post.data.url)\n    .filter(url => /png$/.exec(url));\n}\n```\n\n## Display Picture\n利用了`Array.map`和`Array.json`来生成要插入的HTML string。如果我写的话，可以会用循环 = =　果然看多别人的代码还是好的。\n\n```javascript\nexport default (urls) => {\n  var pics = document.querySelector('.pics');\n  pics.innerHTML = urls.map(url => `<img src=${url}>`).join('\\n');\n}\n```\n","source":"_posts/ES6-In-Practice-0-watch-a-demo.md","raw":"title: ES6 In Practice(0) - watch a demo\nauthor: Drake Leung\ndate: 2015-06-18 16:02:11\ntags: ES6\ncategories: JavaScript\nforeword:\n  通过视频JavaScript 2015来实践一个demo, 利用的包管理器是jspm.\n---\n\n吃完半个西瓜，太饱。于是上yutube，然后搜了`es6 tutorial`，发现了一个30k+ views的[JavaScript In 2015](https://youtu.be/iukBMY4apvI)视频。遂看，**收货良多**。\n\n## live-server\n[live-server](https://www.npmjs.com/package/live-server)这个package，可以帮助我们快速建立一个可以**live reload**的静态服务器。\n\n## jspm\n[jspm](http://jspm.io/)是一个package manager，可以帮助我们快速建立ES6的使用环境。让我们来看一下官方文档的[getting start](https://github.com/jspm/jspm-cli/wiki/Getting-Started)\n\n```html\n <!doctype html>\n  // 需要引入这2个js文件\n  <script src=\"jspm_packages/system.js\"></script>\n  <script src=\"config.js\"></script>\n\n  // 下面是我们自己的js文件\n  <script>\n    System.import('lib/main');\n  </script>\n```\n\n## reddit api\n这里用了一个[jsonp](https://www.npmjs.com/package/jsonp) package，来发起jsonp请求。我们使用`jspm install npm:jsonp`来安装。\n\n**使用reddit api**: 只要在每个`r`后面加`.json`。比如: `https://www.reddit.com/r/pics.json`。然后还要传`param: 'jsonp'`的参数。\n\n```javascript\nclass RedditApi {\n  constructor() {\n    this.redditURL = 'https://www.reddit.com/r/pics.json';\n  }\n\n  load() {\n    return new Promise((resolve, reject) => {\n      jsonp(this.redditURL, {param: 'jsonp'}, (err, data) => {\n        err ? reject(err) : resolve(data.data.children);\n      });\n    });\n  }\n}\n```\n说到API，突然想起[codeacademy](http://www.codecademy.com/learn)上面好像又好多教学，赶紧去一下先。\n\n## Extract Pictures\n利用`Array.map`和`Array.filter`来获取和过滤图片。以前一直不知道这２个函数怎么用。\n```javascript\nexport default (posts) => {\n  return posts\n    .map(post => post.data.url)\n    .filter(url => /png$/.exec(url));\n}\n```\n\n## Display Picture\n利用了`Array.map`和`Array.json`来生成要插入的HTML string。如果我写的话，可以会用循环 = =　果然看多别人的代码还是好的。\n\n```javascript\nexport default (urls) => {\n  var pics = document.querySelector('.pics');\n  pics.innerHTML = urls.map(url => `<img src=${url}>`).join('\\n');\n}\n```\n","slug":"ES6-In-Practice-0-watch-a-demo","published":1,"updated":"2016-01-27T06:26:50.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon93001jqoren6o1x7jy"},{"title":"BFC in CSS(0) - WTF","author":"Drake Leung","date":"2015-07-24T17:21:40.000Z","foreword":"BFC？听起来很高大上的样子~","_content":"\n看了[Understanding Block Formatting Contexts in CSS](http://www.sitepoint.com/understanding-block-formatting-contexts-in-css/)这篇文章，终于有点明白什么是BFC(Block Formatting Context)了。\n\n## Normal Flow\n**下面这句话不要忽略啊。要不然很多事情就想不通**。\n> Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.\n\n在normal flow中的盒子都是属于formatting context的！！什么意思？\n```html\n<body>\n  <p> I am in the formatting context</p>\n  <div> I also belong to the formatting context</div>\n</body>\n```\n\n在上面的例子，`p`和`div`都是在*normal flow*里面的。并且，他们都是块级元素，所以他们参与了block formatting contexts。\n\n那么，参与了BFC又会怎么样呢？\n\n## Block Formatting Contexts\n下面的[文档](http://www.w3.org/TR/CSS21/visuren.html#block-formatting)定义了*在BFC中盒子是怎么排版的*:\n\n> In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.\n\n在BFC中，盒子都是按垂直方向一个挨着一个排版的，从*containing block*的顶部开始。2个sibing boxed的\n垂直方向的距离是由`margin`来决定的，但此时的2个盒子的`margin`是会**collapse**(坍塌？折叠？)\n\n那到底是怎么collapse法，我们要怎样才能解决。\n\n## BFC引起的Collapse Margins\n```html\n<style>\n  p {\n    margin: 10px;\n    background-color: lightgreen;\n  }\n</style>\n\n<p> Sibling 1 </p>\n<p> Sibling 2 </p>\n```\n\n上面的例子中，2个`p`的之间的`margin`只有`10px`而不是`20px(10 + 10)`。为什么？因为前面说过，\n\n2个`p`都是在*normal flow*中，并且，他们是块级元素，所以他们会参与block formatting contexts。\n\n又因为在BFC中，2个sibling element的垂直方面的`margin`会collapse！于是，结果取2者较大的那个。\n\n```css\nP:last-child {\n  margin: 20px;\n}\n```\n\n这样一来，2个`p`垂直方向的`margin`就取`20`。因为20比10大。\n\n那么，我们如何解决margin collapse呢？答案就是**创建一个新的bfc**。\n\n为什么可以？因为前面的文档说过: *In a block formatting....*才会发生margin collapse。\n也就是说，如果**不在同一个bfc**的话，那么就不会有margin collapse。因此，我们创建新的bfc就行了。\n\n那么，怎样才能创建新的bfc呢？\n\n## Create a New BFC\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n通过上面的[文档](http://www.w3.org/TR/CSS21/visuren.html#block-formatting)，我们可以总结出以下的情况会创建出新的BFC:\n\n- `float`的值不为`none`\n- `position`的值不为`static`或者`relative`。\n- `display`的值为`table-cell`, `table-caption`, `inline-block`\n- `overflow`的值不为`visible`。\n\n举个例子:\n```html\n<style>\n  .newBFC {\n    overflow: hidden;\n  }\n</style>\n\n<div class=\"newBFC\">\n  <p>I am in the BFC created by my parent tag</p>\n</div>\n```\n上面例子中的`div`就创建了一个新的bfc。\n\n所以，我们就可以解决margin collapse:\n\n```html\n<style>\n  p {\n    margin: 10px;\n    background-color: lightgreen;\n  }\n  .newBFC {\n    overflow: hidden;\n  }\n</style>\n\n<p> Sibling 1 </p>\n<div class=\"newBFC\">\n  <p> Sibling 2 </p>\n</div>\n```\n\n## Wrap up\n总的来说，BFC就是定义了块级元素是如何排版的。\n\n另外，创建新的BFC可以解决一些问题。比如上面的*margin collapse*，还有更多的例子，我们下篇再说。\n","source":"_posts/BFC-in-CSS-0-WTF.md","raw":"title: BFC in CSS(0) - WTF\nauthor: Drake Leung\ntags: [BFC]\ncategories: [CSS]\ndate: 2015-07-25 01:21:40\nforeword: BFC？听起来很高大上的样子~\n---\n\n看了[Understanding Block Formatting Contexts in CSS](http://www.sitepoint.com/understanding-block-formatting-contexts-in-css/)这篇文章，终于有点明白什么是BFC(Block Formatting Context)了。\n\n## Normal Flow\n**下面这句话不要忽略啊。要不然很多事情就想不通**。\n> Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.\n\n在normal flow中的盒子都是属于formatting context的！！什么意思？\n```html\n<body>\n  <p> I am in the formatting context</p>\n  <div> I also belong to the formatting context</div>\n</body>\n```\n\n在上面的例子，`p`和`div`都是在*normal flow*里面的。并且，他们都是块级元素，所以他们参与了block formatting contexts。\n\n那么，参与了BFC又会怎么样呢？\n\n## Block Formatting Contexts\n下面的[文档](http://www.w3.org/TR/CSS21/visuren.html#block-formatting)定义了*在BFC中盒子是怎么排版的*:\n\n> In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the 'margin' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.\n\n在BFC中，盒子都是按垂直方向一个挨着一个排版的，从*containing block*的顶部开始。2个sibing boxed的\n垂直方向的距离是由`margin`来决定的，但此时的2个盒子的`margin`是会**collapse**(坍塌？折叠？)\n\n那到底是怎么collapse法，我们要怎样才能解决。\n\n## BFC引起的Collapse Margins\n```html\n<style>\n  p {\n    margin: 10px;\n    background-color: lightgreen;\n  }\n</style>\n\n<p> Sibling 1 </p>\n<p> Sibling 2 </p>\n```\n\n上面的例子中，2个`p`的之间的`margin`只有`10px`而不是`20px(10 + 10)`。为什么？因为前面说过，\n\n2个`p`都是在*normal flow*中，并且，他们是块级元素，所以他们会参与block formatting contexts。\n\n又因为在BFC中，2个sibling element的垂直方面的`margin`会collapse！于是，结果取2者较大的那个。\n\n```css\nP:last-child {\n  margin: 20px;\n}\n```\n\n这样一来，2个`p`垂直方向的`margin`就取`20`。因为20比10大。\n\n那么，我们如何解决margin collapse呢？答案就是**创建一个新的bfc**。\n\n为什么可以？因为前面的文档说过: *In a block formatting....*才会发生margin collapse。\n也就是说，如果**不在同一个bfc**的话，那么就不会有margin collapse。因此，我们创建新的bfc就行了。\n\n那么，怎样才能创建新的bfc呢？\n\n## Create a New BFC\n> Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than 'visible' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.\n\n通过上面的[文档](http://www.w3.org/TR/CSS21/visuren.html#block-formatting)，我们可以总结出以下的情况会创建出新的BFC:\n\n- `float`的值不为`none`\n- `position`的值不为`static`或者`relative`。\n- `display`的值为`table-cell`, `table-caption`, `inline-block`\n- `overflow`的值不为`visible`。\n\n举个例子:\n```html\n<style>\n  .newBFC {\n    overflow: hidden;\n  }\n</style>\n\n<div class=\"newBFC\">\n  <p>I am in the BFC created by my parent tag</p>\n</div>\n```\n上面例子中的`div`就创建了一个新的bfc。\n\n所以，我们就可以解决margin collapse:\n\n```html\n<style>\n  p {\n    margin: 10px;\n    background-color: lightgreen;\n  }\n  .newBFC {\n    overflow: hidden;\n  }\n</style>\n\n<p> Sibling 1 </p>\n<div class=\"newBFC\">\n  <p> Sibling 2 </p>\n</div>\n```\n\n## Wrap up\n总的来说，BFC就是定义了块级元素是如何排版的。\n\n另外，创建新的BFC可以解决一些问题。比如上面的*margin collapse*，还有更多的例子，我们下篇再说。\n","slug":"BFC-in-CSS-0-WTF","published":1,"updated":"2016-01-27T06:26:38.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cil9gon99001nqorerm5zph86"}],"PostAsset":[{"_id":"source/_posts/从零开始编写一个Hexo主题/hexo.png","post":"cil9gon5d0003qoreh5urhmpq","slug":"hexo.png","modified":1},{"_id":"source/_posts/从零开始编写一个Hexo主题/hexo1.png","post":"cil9gon5d0003qoreh5urhmpq","slug":"hexo1.png","modified":1},{"_id":"source/_posts/从零开始编写一个Hexo主题/hexo2.png","post":"cil9gon5d0003qoreh5urhmpq","slug":"hexo2.png","modified":1},{"_id":"source/_posts/为你的JavaScript代码写测试/0.png","post":"cil9gon670008qore94k4xfcf","slug":"0.png","modified":1},{"_id":"source/_posts/Virtual-DOM/vdom0.png","post":"cil9gon6y000pqorezebn9lz8","slug":"vdom0.png","modified":1},{"_id":"source/_posts/Virtual-DOM/vdom1.png","post":"cil9gon6y000pqorezebn9lz8","slug":"vdom1.png","modified":1},{"_id":"source/_posts/Virtual-DOM/vdom2.png","post":"cil9gon6y000pqorezebn9lz8","slug":"vdom2.png","modified":1},{"_id":"source/_posts/How-Medium-Load-Images/inspect.png","post":"cil9gon8r001iqoredc46dgnm","slug":"inspect.png","modified":1},{"_id":"source/_posts/How-Medium-Load-Images/network.png","post":"cil9gon8r001iqoredc46dgnm","slug":"network.png","modified":1}],"PostCategory":[{"post_id":"cil9gon6k000dqore9rxx02ca","category_id":"cil9gon6n000eqorejdr76x6d","_id":"cil9gon6o000hqorez54qomv5"},{"post_id":"cil9gon6r000iqore4ahje6w8","category_id":"cil9gon6t000jqoredmrunt60","_id":"cil9gon6v000mqorefsretryn"},{"post_id":"cil9gon7g000qqoref9yq1qtz","category_id":"cil9gon7h000rqore5rlawlq3","_id":"cil9gon7i000uqorei97yc7lb"},{"post_id":"cil9gon7q000xqoreq0bo6t6k","category_id":"cil9gon7h000rqore5rlawlq3","_id":"cil9gon7t000yqore344ryjm7"},{"post_id":"cil9gon7x0010qore0srm2ek3","category_id":"cil9gon7h000rqore5rlawlq3","_id":"cil9gon7z0011qore6sjs3oqr"},{"post_id":"cil9gon840015qoreyr91jv41","category_id":"cil9gon7h000rqore5rlawlq3","_id":"cil9gon850016qoreqfdyperr"},{"post_id":"cil9gon8b0019qoreuiuq84v4","category_id":"cil9gon8d001aqorefbm2vdw0","_id":"cil9gon8e001bqore55afsuju"},{"post_id":"cil9gon8h001cqoreaypk9d12","category_id":"cil9gon8d001aqorefbm2vdw0","_id":"cil9gon8j001dqorelyp61738"},{"post_id":"cil9gon8n001eqoredc2xq2rm","category_id":"cil9gon7h000rqore5rlawlq3","_id":"cil9gon8p001fqore4r0meh7n"},{"post_id":"cil9gon93001jqoren6o1x7jy","category_id":"cil9gon7h000rqore5rlawlq3","_id":"cil9gon94001kqorel64oy4nj"},{"post_id":"cil9gon99001nqorerm5zph86","category_id":"cil9gon9b001oqoren170t24a","_id":"cil9gon9d001rqore8ks4t8wo"}],"PostTag":[{"post_id":"cil9gon5d0003qoreh5urhmpq","tag_id":"cil9gon5f0004qore946jomqj","_id":"cil9gon5k0006qorexqpn21ew"},{"post_id":"cil9gon5d0003qoreh5urhmpq","tag_id":"cil9gon5j0005qore9pf17n38","_id":"cil9gon5k0007qorehkvqjv8h"},{"post_id":"cil9gon670008qore94k4xfcf","tag_id":"cil9gon690009qorevjpb5yd7","_id":"cil9gon6a000bqoremkqcq37n"},{"post_id":"cil9gon670008qore94k4xfcf","tag_id":"cil9gon69000aqorehxmq14yc","_id":"cil9gon6a000cqore96nr4zas"},{"post_id":"cil9gon6k000dqore9rxx02ca","tag_id":"cil9gon6n000fqorelxnvpib1","_id":"cil9gon6o000gqoregan2id35"},{"post_id":"cil9gon6r000iqore4ahje6w8","tag_id":"cil9gon6t000kqore07h3wfao","_id":"cil9gon6w000nqore21nhrc7c"},{"post_id":"cil9gon6r000iqore4ahje6w8","tag_id":"cil9gon6u000lqore9s6xsdax","_id":"cil9gon6w000oqore9fso91wv"},{"post_id":"cil9gon7g000qqoref9yq1qtz","tag_id":"cil9gon7h000sqoreq63ehybc","_id":"cil9gon7j000vqoreoxabxhdi"},{"post_id":"cil9gon7g000qqoref9yq1qtz","tag_id":"cil9gon7i000tqorejfuwhooa","_id":"cil9gon7j000wqorec0uszsft"},{"post_id":"cil9gon7q000xqoreq0bo6t6k","tag_id":"cil9gon7h000sqoreq63ehybc","_id":"cil9gon7t000zqore8p406axd"},{"post_id":"cil9gon7x0010qore0srm2ek3","tag_id":"cil9gon7h000sqoreq63ehybc","_id":"cil9gon810013qorehd7822rf"},{"post_id":"cil9gon7x0010qore0srm2ek3","tag_id":"cil9gon800012qoremoudyuwv","_id":"cil9gon810014qore2k49i7tx"},{"post_id":"cil9gon840015qoreyr91jv41","tag_id":"cil9gon7h000sqoreq63ehybc","_id":"cil9gon850017qoreil6jud1c"},{"post_id":"cil9gon8n001eqoredc2xq2rm","tag_id":"cil9gon8p001gqorezqkzvowb","_id":"cil9gon8q001hqore9hg3e791"},{"post_id":"cil9gon93001jqoren6o1x7jy","tag_id":"cil9gon95001lqore47dmzxyu","_id":"cil9gon96001mqorep0yma6se"},{"post_id":"cil9gon99001nqorerm5zph86","tag_id":"cil9gon9c001pqoret6lzb37q","_id":"cil9gon9d001qqorezlt0jupm"}],"Tag":[{"name":"hexo","_id":"cil9gon5f0004qore946jomqj"},{"name":"theme","_id":"cil9gon5j0005qore9pf17n38"},{"name":"JavaScript","_id":"cil9gon690009qorevjpb5yd7"},{"name":"test","_id":"cil9gon69000aqorehxmq14yc"},{"name":"gulp","_id":"cil9gon6n000fqorelxnvpib1"},{"name":"google chrome","_id":"cil9gon6t000kqore07h3wfao"},{"name":"devtools","_id":"cil9gon6u000lqore9s6xsdax"},{"name":"scope","_id":"cil9gon7h000sqoreq63ehybc"},{"name":"closure","_id":"cil9gon7i000tqorejfuwhooa"},{"name":"作用域","_id":"cil9gon800012qoremoudyuwv"},{"name":"This","_id":"cil9gon8p001gqorezqkzvowb"},{"name":"ES6","_id":"cil9gon95001lqore47dmzxyu"},{"name":"BFC","_id":"cil9gon9c001pqoret6lzb37q"}]}}