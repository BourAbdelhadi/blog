webpackJsonp([1,2],[,,,,function(s,a){s.exports=function(s,a,n,e){var l,t=s=s||{},p=typeof s.default;"object"!==p&&"function"!==p||(l=s,t=s.default);var o="function"==typeof t?t.options:t;if(a&&(o.render=a.render,o.staticRenderFns=a.staticRenderFns),n&&(o._scopeId=n),e){var c=o.computed||(o.computed={});Object.keys(e).forEach(function(s){var a=e[s];c[s]=function(){return a}})}return{esModule:l,exports:t,options:o}}},,,,,,,,,,,,,,,,,,,,,function(s,a,n){"use strict";function e(s){return s&&s.__esModule?s:{default:s}}function l(){var s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return s.sort(function(s,a){return new Date(a.date)-new Date(s.date)}).reduce(function(s,a){var n=o.default.format(a.date,"YYYY"),e=s.find(function(s){return s.year===n});return e?e.posts.push(a):s.push({year:n,posts:[a]}),s},[])}function t(s){var a=n(195);return a.keys().map(function(s){var n=a(s),e=n.attributes,l=n.body,t=n.frontmatter,p=s.split("/").slice(-1)[0].split(".").slice(0,-1).join(".");return Object.assign({},e,{key:p,body:l,frontmatter:t})})}Object.defineProperty(a,"__esModule",{value:!0}),a.fetchPosts=a.sortPostsBySameYear=void 0;var p=n(8),o=e(p);a.sortPostsBySameYear=l,a.fetchPosts=t},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(s,a,n){s.exports=n.p+"d3a5dd0236961fee66483534cc436e82.png"},function(s,a,n){"use strict";function e(s){return s&&s.__esModule?s:{default:s}}Object.defineProperty(a,"__esModule",{value:!0});var l=n(9),t=e(l),p=n(24),o=e(p),c=n(182),r=e(c),i=n(186),d=e(i),h=n(185),m=e(h),u=n(184),j=e(u);t.default.use(o.default),a.default=new o.default({mode:"history",routes:[{path:"/",component:r.default},{path:"/posts",component:d.default},{path:"/posts/:id",component:m.default},{path:"*",component:j.default}]})},function(s,a,n){n(175),n(174);var e=n(4)(n(65),n(190),"data-v-4866abf7",null);s.exports=e.exports},function(s,a,n){"use strict";function e(s){return s&&s.__esModule?s:{default:s}}Object.defineProperty(a,"__esModule",{value:!0});var l=n(183),t=e(l),p=n(181),o=e(p);a.default={components:{MyNav:t.default,MyFooter:o.default}}},function(s,a,n){"use strict";function e(s){return s&&s.__esModule?s:{default:s}}Object.defineProperty(a,"__esModule",{value:!0});var l=n(180),t=e(l);a.default={data:function(){return t.default}}},function(s,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0}),a.default={data:function(){return{navs:[{name:"RSS",path:"/about"},{name:"Post",path:"/posts"},{name:"Home",path:"/"}]}}}},function(s,a,n){"use strict";function e(s){return s&&s.__esModule?s:{default:s}}Object.defineProperty(a,"__esModule",{value:!0});var l=n(8),t=e(l),p=n(25);a.default={created:function(){var s=this.$route.params.id,a=this.$root.posts||(this.$root.posts=(0,p.fetchPosts)());this.post=a.find(function(a){return a.key===s})},methods:{formatDate:function(s){return t.default.format(s,"MMMM DD YYYY")}}}},function(s,a,n){"use strict";function e(s){return s&&s.__esModule?s:{default:s}}Object.defineProperty(a,"__esModule",{value:!0});var l=n(8),t=e(l),p=n(25);a.default={created:function(){var s=this.$root.posts||(this.$root.posts=(0,p.fetchPosts)());this.posts=(0,p.sortPostsBySameYear)(s)},methods:{formatDate:function(s){var a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"YYYY-MM-DD";return t.default.format(s,a)}}}},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(s,a){},function(s,a){},function(s,a){},function(s,a){},function(s,a){},function(s,a){},function(s,a){},function(s,a){},function(s,a){},function(s,a){s.exports={title:"lyyourc",bio:"Web Dev / Google-oriented Programming / zzz",socials:[{name:"GitHub",link:"https://github.com/DrakeLeung"},{name:"Weibo",link:"http://weibo.com/cha12chalyc/"},{name:"Twitter",link:"https://twitter.com/DrakeLeung"}]}},function(s,a,n){n(172);var e=n(4)(null,n(188),"data-v-411f66ca",null);s.exports=e.exports},function(s,a,n){n(173);var e=n(4)(n(66),n(189),"data-v-47187dce",null);s.exports=e.exports},function(s,a,n){n(176);var e=n(4)(n(67),n(191),"data-v-72861d84",null);s.exports=e.exports},function(s,a,n){n(171);var e=n(4)(null,n(187),"data-v-21af7444",null);s.exports=e.exports},function(s,a,n){n(179),n(178);var e=n(4)(n(68),n(193),"data-v-dd9b4de2",null);s.exports=e.exports},function(s,a,n){n(177);var e=n(4)(n(69),n(192),"data-v-ce772c18",null);s.exports=e.exports},function(s,a,n){s.exports={render:function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("div",[n("div",[s._m(0),s._v(" "),n("router-link",{staticClass:"link",attrs:{to:"/"}},[s._v(" Home ")])],1)])},staticRenderFns:[function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("h1",[s._v("\n      4\n      "),e("img",{attrs:{src:n(62),alt:"0"}}),s._v("\n      4\n    ")])}]}},function(s,a){s.exports={render:function(){var s=this,a=s.$createElement;s._self._c||a;return s._m(0)},staticRenderFns:[function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("footer",[s._v("\n  © 2017 lyyourc.\n  "),n("a",{attrs:{href:"https://github.com/DrakeLeung/blog",target:"_blank"}},[s._v(" Fork it ")]),s._v(" .\n")])}]}},function(s,a,n){s.exports={render:function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("section",{staticClass:"home"},[s._m(0),s._v(" "),n("h1",{staticClass:"title"},[s._v(" "+s._s(s.title)+" ")]),s._v(" "),n("p",[s._v(" "+s._s(s.bio)+" ")]),s._v(" "),n("ul",{staticClass:"social-list"},s._l(s.socials,function(a){return n("li",{staticClass:"social-item"},[n("a",{attrs:{href:a.link,target:"_blank"}},[s._v(s._s(a.name))])])}))])},staticRenderFns:[function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("figure",[e("img",{staticClass:"avatar",attrs:{src:n(62),alt:"avatar"}})])}]}},function(s,a){s.exports={render:function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("div",{staticClass:"container"},[n("my-nav"),s._v(" "),n("router-view",{staticClass:"content"}),s._v(" "),n("my-footer")],1)},staticRenderFns:[]}},function(s,a){s.exports={render:function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("nav",[n("ul",{staticClass:"nav-list"},s._l(s.navs,function(a){return n("li",{staticClass:"nav-item"},[n("router-link",{attrs:{to:a.path}},[s._v(s._s(a.name))])],1)}))])},staticRenderFns:[]}},function(s,a){s.exports={render:function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("div",{staticClass:"post-list"},s._l(s.posts,function(a){return n("section",{staticClass:"post-entity"},[a.year!==s.formatDate(new Date,"YYYY")?n("p",{staticClass:"post-year"},[s._v("\n      "+s._s(a.year)+" year\n    ")]):s._e(),s._v(" "),s._l(a.posts,function(a,e){return n("div",{staticClass:"post-entry",class:{gutter:(e+1)%5===0}},[n("div",{staticClass:"post-date"},[n("span",{staticClass:"post-day"},[s._v("\n          "+s._s(s.formatDate(a.date,"DD"))+"\n        ")]),s._v(" "),n("small",[s._v("\n          "+s._s(s.formatDate(a.date,"MMM"))+"\n        ")])]),s._v(" "),n("h3",{staticClass:"post-title"},[n("router-link",{attrs:{to:"/posts/"+a.key}},[s._v(s._s(a.title))])],1)])})],2)}))},staticRenderFns:[]}},function(s,a){s.exports={render:function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("article",[n("header",[n("h1",{staticClass:"post-title"},[s._v(s._s(s.post.title))]),s._v(" "),n("small",{staticClass:"post-date"},[s._v(s._s(s.formatDate(s.post.date)))])]),s._v(" "),n("section",{staticClass:"post-body",domProps:{innerHTML:s._s(s.post.body)}})])},staticRenderFns:[]}},,function(s,a,n){function e(s){return n(l(s))}function l(s){var a=t[s];if(!(a+1))throw new Error("Cannot find module '"+s+"'.");return a}var t={"./5-Ways-to-Make-a-Sticky-Footer.md":196,"./BFC-in-CSS-0-WTF.md":197,"./How-Medium-Load-Images.md":198,"./JavaScript-Module-A-Beginner-Guide.md":199,"./JavaScript-Modules-Part-2.md":200,"./Learning-React-Without-Using-React-Part-1.md":201,"./Learning-React-Without-Using-React-Part-2.md":202,"./Oh-My-Nginx.md":203,"./Promise.md":204,"./Virtual-DOM.md":205,"./Write-Test-For-Your-JavaScript.md":206,"./Write-a-Hexo-Theme-From-Strach.md":207,"./a-mathematical-expressions-parser.md":208,"./bubble-sorting-visually.md":209,"./fetch-api-now.md":210,"./google-chrome-Devtools-Overview.md":211,"./implement-a-simple-AMD-module-loader.md":212,"./justified-layout.md":213,"./let-us-learn-rxjs.md":214,"./my-2016-review.md":215};e.keys=function(){return Object.keys(t)},e.resolve=l,s.exports=e,e.id=195},function(s,a){s.exports={attributes:{title:"5 Ways To Make A Sticky Footer",author:"Drake Leung",tags:[],categories:[],date:"2016-01-20T15:19:06.000Z",foreword:"总结一下创建Sticky Footer的5种方法。"},body:'<p><em>Sticky Footer</em>在内容展示的网站都会用到。比如blog，xx的主页等等。</p>\n<h2 id="what-is-sticky-footer"><a class="header-anchor" href="#what-is-sticky-footer" aria-hidden="true">#</a> What is Sticky Footer</h2>\n<p>为了简单起见，我们不妨假设我们的<code>index.html</code>是这样的:</p>\n<pre class="hljs"><code><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Ways to make a sticky foote<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p>那么，如下面的图所示，图<code>a</code>和<code>b</code>都不是<em>Sticky Footer</em>.</p>\n<p><img src="http://ww2.sinaimg.cn/large/7f85b91egw1f0asb7siypj20go088q4x.jpg" alt=""></p>\n<p>因为图<code>a</code>的页脚的后面还有空白部分。我们想要的应该是页脚就是在页面的最底部。</p>\n<p>那么图<code>b</code>为什么不是呢？他不是在页面的最底部吗？没错，但是我们想要的是只有当<strong>scroller bar</strong>滑到最底部的时候，才会出现页脚。</p>\n<p>像下面的图<code>c</code>和<code>d</code>才是我们的<em>Sticky Footer</em>:<br>\n<img src="http://ww2.sinaimg.cn/large/7f85b91egw1f0asq75p07j20gl09i0vh.jpg" alt=""></p>\n<h2 id="ways-to-sticky-footer"><a class="header-anchor" href="#ways-to-sticky-footer" aria-hidden="true">#</a> Ways to Sticky Footer</h2>\n<p>废话少说，下面会介绍几种创建<em>Sticky Footer</em>的方法。</p>\n<p>我们会从最简单的方法开始，但最简单的不一定是最好的，符合自己的使用场景才是最好的。最后总结每种方法的优缺点。</p>\n<p>(P.S. 假设我们都使用上面的<code>index.html</code>所示结构)</p>\n<h3 id="flexbox"><a class="header-anchor" href="#flexbox" aria-hidden="true">#</a> Flexbox</h3>\n<p><em><a href="https://philipwalton.github.io/solved-by-flexbox/demos/sticky-footer/">方法来源</a></em></p>\n<pre class="hljs"><code><span class="hljs-comment">/* #0 */</span>\n<span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">display</span>: flex;\n  <span class="hljs-attribute">flex-direction</span>: column;\n  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;\n  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;\n}\n\n<span class="hljs-comment">/* #1 */</span>\n<span class="hljs-selector-tag">main</span> {\n  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;\n}\n</code></pre>\n<p><code>#0</code>是中的<code>min-height: 100vh</code>是为了让<code>&lt;main&gt;</code>的高度没有大于屏幕的高度时，使得<code>footer</code>可以在页面的底部。而，<code>margin: 0</code>是去掉原本浏览器自带的<code>&lt;body&gt;</code>的样式。</p>\n<p><code>#1</code>的<code>flex: 1</code>是为了让<code>&lt;main&gt;</code>占满多余的空间。</p>\n<h3 id="modern-way"><a class="header-anchor" href="#modern-way" aria-hidden="true">#</a> Modern Way</h3>\n<p><em><a href="http://mystrd.at/modern-clean-css-sticky-footer/">方法来源</a></em></p>\n<pre class="hljs"><code><span class="hljs-comment">/* #0 */</span>\n<span class="hljs-selector-tag">html</span> {\n  <span class="hljs-attribute">position</span>: relative;\n  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;\n}\n\n<span class="hljs-comment">/* #1 */</span>\n<span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* same to footer height */</span>\n}\n\n<span class="hljs-comment">/* #2 */</span>\n<span class="hljs-selector-tag">footer</span> {\n  <span class="hljs-attribute">position</span>: absolute;\n  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n}\n</code></pre>\n<p><code>#0</code>中的<code>position: relative</code>很显然是为了让<code>&lt;html&gt;</code>变成<em>containning block</em>，<br>\n这个在<code>#2</code>会说到。同样地，<code>min-height: 100%</code>和上面的<em>flexbox</em>方法中的<code>#0</code>一样。</p>\n<p><code>#1</code>的<code>margin-bottom</code>设为<code>100px</code>是和<code>&lt;footer&gt;</code>的高度一样的。目的是当<code>&lt;body&gt;</code>的内容溢出<br>\n的时候，防止<code>&lt;footer&gt;</code>的内容蹿到<code>&lt;body&gt;</code>里面。</p>\n<p><code>#2</code>设置了<code>position: absolute</code>，这样，<code>left</code>和<code>bottom</code>的值都是相对于<code>&lt;footer&gt;</code>的<em>containning block</em>来说的。<br>\n由于在<code>#0</code>设置了<code>&lt;html&gt;</code>的<code>position</code>为<code>relative</code>，所以<code>&lt;html&gt;</code>就是<code>&lt;footer&gt;</code>的<em>containning block</em>。</p>\n<h3 id="table-way"><a class="header-anchor" href="#table-way" aria-hidden="true">#</a> Table Way</h3>\n<p><em><a href="http://codepen.io/anon/pen/zrRLVW">方法来源</a>或者<a href="https://gist.github.com/goldsky/7322156">这个</a></em></p>\n<pre class="hljs"><code><span class="hljs-selector-tag">html</span>,\n<span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;\n}\n\n<span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">display</span>: table; <span class="hljs-comment">/* #0 */</span>\n}\n<span class="hljs-selector-tag">main</span>,\n<span class="hljs-selector-tag">footer</span> {\n  <span class="hljs-attribute">display</span>: table-row;\n}\n\n<span class="hljs-comment">/* #1\nmain {\n  height: 100%;\n}\n*/</span>\n\n<span class="hljs-selector-tag">footer</span> {\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>; <span class="hljs-comment">/* #2 */</span>\n}\n</code></pre>\n<p>其实这个方法就是利用了<code>table</code>布局，然后设置<code>&lt;footer&gt;</code>的高度为<code>1px</code>(如<code>#2</code>所示)。但是我并不知道为什么。<br>\n并且，如果我把<code>#2</code>注释掉，把<code>#1</code>的注释去掉，也是work的。所以不知道设置<code>1px</code>有什么用。</p>\n<h3 id="old-way"><a class="header-anchor" href="#old-way" aria-hidden="true">#</a> Old Way</h3>\n<p><em><a href="http://ryanfait.com/resources/footer-stick-to-bottom-of-page/">方法来源</a></em></p>\n<p>这种方法需要我们改变一下我们的<code>index.html</code>，给我们的<code>&lt;main&gt;</code>添加一个空白的<code>&lt;div&gt;</code>。<br>\n他其实是<code>&lt;footer&gt;</code>的<em>placeholder</em>。</p>\n<pre class="hljs"><code><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Ways to make a sticky foote<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"push"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- new --&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>\n</code></pre>\n<p>那么，对应的CSS是这样的：</p>\n<pre class="hljs"><code><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;\n}\n\n<span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;\n}\n\n<span class="hljs-selector-tag">main</span> {\n  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;\n  <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">100px</span>; <span class="hljs-comment">/* #0 */</span>\n}\n\n<span class="hljs-selector-tag">footer</span>,\n<span class="hljs-selector-class">.push</span> {\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* #1 */</span>\n}\n</code></pre>\n<p><code>#0</code>给<code>&lt;main&gt;</code>设置了<code>margin-bottom: -100px</code>。这是<code>&lt;footer&gt;</code>的高度的相反数。<br>\n他是为了让<code>&lt;footer&gt;</code>可以蹿到<code>&lt;div class=&quot;push&quot;&gt;&lt;/div&gt;</code>的位置。</p>\n<p>因为<code>.push</code>就是<code>&lt;footer&gt;</code>的placeholder, 显然他们的<code>height</code>必须是一样的，如<code>#1</code>所示。</p>\n<p>其实我们还可以使用为了<code>:after</code>改进一下。因为<code>.push</code>存在的意义只是为了样式而样式，并不是页面的结构，所以也没有必要出现在<code>index.html</code>里面。因此，我们有了下面的<em>Old Way Plus</em>。</p>\n<h3 id="old-way-plus"><a class="header-anchor" href="#old-way-plus" aria-hidden="true">#</a> Old Way Plus</h3>\n<p><em><a href="https://css-tricks.com/snippets/css/sticky-footer/">方法来源</a></em></p>\n<p>(注意，这个时候我们并不需要给<code>&lt;main&gt;</code>添加一个<code>&lt;div class=&quot;push&quot;&gt;&lt;/div&gt;</code>)</p>\n<pre class="hljs"><code><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;\n}\n\n<span class="hljs-selector-tag">main</span> {\n  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;\n  <span class="hljs-comment">/* equal to footer height */</span>\n  <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">100px</span>;\n}\n\n<span class="hljs-comment">/* #0 */</span>\n<span class="hljs-selector-tag">main</span><span class="hljs-selector-pseudo">:after</span> {\n  <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;\n  <span class="hljs-attribute">display</span>: block;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n}\n\n<span class="hljs-selector-tag">footer</span> {\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;\n}\n</code></pre>\n<p><code>#0</code>, 我们利用伪类<code>:after</code>来替代上面的<em>Old Way</em>的<code>.push</code>，这样就不需要给<code>index.html</code><br>\n添加不必要的标签。</p>\n<h2 id="to-sum-up"><a class="header-anchor" href="#to-sum-up" aria-hidden="true">#</a> To Sum Up</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>难度</th>\n<th>Footer需要固定高度</th>\n<th>浏览器兼容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Flexbox</td>\n<td>+</td>\n<td>No</td>\n<td>+</td>\n</tr>\n<tr>\n<td>Modern way</td>\n<td>++</td>\n<td>Yes</td>\n<td>+++</td>\n</tr>\n<tr>\n<td>Table way</td>\n<td>++</td>\n<td>No</td>\n<td>++?</td>\n</tr>\n<tr>\n<td>Old way</td>\n<td>+++</td>\n<td>Yes</td>\n<td>+++</td>\n</tr>\n<tr>\n<td>Old way Plus</td>\n<td>++</td>\n<td>Yes</td>\n<td>++</td>\n</tr>\n</tbody>\n</table>\n',frontmatter:"title: 5 Ways To Make A Sticky Footer\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-01-20 15:19:06\nforeword: 总结一下创建Sticky Footer的5种方法。"}},function(s,a){s.exports={attributes:{title:"BFC in CSS(0) - WTF",author:"Drake Leung",tags:["BFC"],categories:["CSS"],date:"2015-07-25T01:21:40.000Z",foreword:"BFC？听起来很高大上的样子~"},body:'<p>看了<a href="http://www.sitepoint.com/understanding-block-formatting-contexts-in-css/">Understanding Block Formatting Contexts in CSS</a>这篇文章，终于有点明白什么是BFC(Block Formatting Context)了。</p>\n<h2 id="normal-flow"><a class="header-anchor" href="#normal-flow" aria-hidden="true">#</a> Normal Flow</h2>\n<p><strong>下面这句话不要忽略啊。要不然很多事情就想不通</strong>。</p>\n<blockquote>\n<p>Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context.</p>\n</blockquote>\n<p>在normal flow中的盒子都是属于formatting context的！！什么意思？</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> I am in the formatting context<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> I also belong to the formatting context<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n</code></pre>\n<p>在上面的例子，<code>p</code>和<code>div</code>都是在<em>normal flow</em>里面的。并且，他们都是块级元素，所以他们参与了block formatting contexts。</p>\n<p>那么，参与了BFC又会怎么样呢？</p>\n<h2 id="block-formatting-contexts"><a class="header-anchor" href="#block-formatting-contexts" aria-hidden="true">#</a> Block Formatting Contexts</h2>\n<p>下面的<a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting">文档</a>定义了<em>在BFC中盒子是怎么排版的</em>:</p>\n<blockquote>\n<p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the \'margin\' properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p>\n</blockquote>\n<p>在BFC中，盒子都是按垂直方向一个挨着一个排版的，从<em>containing block</em>的顶部开始。2个sibing boxed的<br>\n垂直方向的距离是由<code>margin</code>来决定的，但此时的2个盒子的<code>margin</code>是会<strong>collapse</strong>(坍塌？折叠？)</p>\n<p>那到底是怎么collapse法，我们要怎样才能解决。</p>\n<h2 id="bfccollapse-margins"><a class="header-anchor" href="#bfccollapse-margins" aria-hidden="true">#</a> BFC引起的Collapse Margins</h2>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n  <span class="hljs-selector-tag">p</span> {\n    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;\n    <span class="hljs-attribute">background-color</span>: lightgreen;\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Sibling 1 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Sibling 2 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n</code></pre>\n<p>上面的例子中，2个<code>p</code>的之间的<code>margin</code>只有<code>10px</code>而不是<code>20px(10 + 10)</code>。为什么？因为前面说过，</p>\n<p>2个<code>p</code>都是在<em>normal flow</em>中，并且，他们是块级元素，所以他们会参与block formatting contexts。</p>\n<p>又因为在BFC中，2个sibling element的垂直方面的<code>margin</code>会collapse！于是，结果取2者较大的那个。</p>\n<pre class="hljs"><code><span class="hljs-selector-tag">P</span><span class="hljs-selector-pseudo">:last-child</span> {\n  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;\n}\n</code></pre>\n<p>这样一来，2个<code>p</code>垂直方向的<code>margin</code>就取<code>20</code>。因为20比10大。</p>\n<p>那么，我们如何解决margin collapse呢？答案就是<strong>创建一个新的bfc</strong>。</p>\n<p>为什么可以？因为前面的文档说过: *In a block formatting....*才会发生margin collapse。<br>\n也就是说，如果<strong>不在同一个bfc</strong>的话，那么就不会有margin collapse。因此，我们创建新的bfc就行了。</p>\n<p>那么，怎样才能创建新的bfc呢？</p>\n<h2 id="create-a-new-bfc"><a class="header-anchor" href="#create-a-new-bfc" aria-hidden="true">#</a> Create a New BFC</h2>\n<blockquote>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with \'overflow\' other than \'visible\' (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n</blockquote>\n<p>通过上面的<a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting">文档</a>，我们可以总结出以下的情况会创建出新的BFC:</p>\n<ul>\n<li><code>float</code>的值不为<code>none</code></li>\n<li><code>position</code>的值不为<code>static</code>或者<code>relative</code>。</li>\n<li><code>display</code>的值为<code>table-cell</code>, <code>table-caption</code>, <code>inline-block</code></li>\n<li><code>overflow</code>的值不为<code>visible</code>。</li>\n</ul>\n<p>举个例子:</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n  <span class="hljs-selector-class">.newBFC</span> {\n    <span class="hljs-attribute">overflow</span>: hidden;\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"newBFC"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am in the BFC created by my parent tag<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p>上面例子中的<code>div</code>就创建了一个新的bfc。</p>\n<p>所以，我们就可以解决margin collapse:</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">\n  <span class="hljs-selector-tag">p</span> {\n    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;\n    <span class="hljs-attribute">background-color</span>: lightgreen;\n  }\n  <span class="hljs-selector-class">.newBFC</span> {\n    <span class="hljs-attribute">overflow</span>: hidden;\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>\n\n<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Sibling 1 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"newBFC"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Sibling 2 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<h2 id="wrap-up"><a class="header-anchor" href="#wrap-up" aria-hidden="true">#</a> Wrap up</h2>\n<p>总的来说，BFC就是定义了块级元素是如何排版的。</p>\n<p>另外，创建新的BFC可以解决一些问题。比如上面的<em>margin collapse</em>，还有更多的例子，我们下篇再说。</p>\n',frontmatter:"title: BFC in CSS(0) - WTF\nauthor: Drake Leung\ntags: [BFC]\ncategories: [CSS]\ndate: 2015-07-25 01:21:40\nforeword: BFC？听起来很高大上的样子~"}},function(s,a){s.exports={attributes:{title:"Medium 是如何加载图片的？",author:"Drake Leung",tags:[],categories:[],date:"2016-03-01T17:11:29.000Z",foreword:"分析及实现 Medium 加载图片的效果。"},body:'<h2 id="what"><a class="header-anchor" href="#what" aria-hidden="true">#</a> What</h2>\n<p>首先，我们来看看 Medium 加载图片的效果是怎样子的：</p>\n<p>{% vimeo 157258221 %}</p>\n<p>我的<a href="http://drakeleung.github.io/blog/">博客首页</a>也实现了这种效果。下面我们就分析如何实现。</p>\n<h2 id="how"><a class="header-anchor" href="#how" aria-hidden="true">#</a> How</h2>\n<p>我们随便打开 Medium 中有图片的<a href="https://medium.com/tag/javascript">页面</a>，然后 <em>审查元素</em>，就可以得到：</p>\n<p><img src="/inspect.png" alt=""></p>\n<p>简化之后得到：</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"placeholder"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"prossiveMedia"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"img-samll"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"img-large"</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>\n</code></pre>\n<p>实现的过程大致如下：</p>\n<ol>\n<li>使用一个 <code>placeholder</code> 来防止图片 <em>collapse</em>。</li>\n<li>先加载一个很小的图片</li>\n<li>当这个小图片加载完毕之后，把他画在 <code>&lt;canvas&gt;</code> 里面，然后把图片弄模糊。</li>\n<li>当大图片加载完毕之后，显示他。</li>\n</ol>\n<h2 id="do-it"><a class="header-anchor" href="#do-it" aria-hidden="true">#</a> Do it</h2>\n<p>首先，HTML 结构如下：</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"banner"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"placeholder"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">img</span>\n    <span class="hljs-attr">class</span>=<span class="hljs-string">"img-small"</span>\n    <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn-images-1.medium.com/freeze/max/27/1*sg-uLNm73whmdOgKlrQdZA.jpeg?q=20"</span>\n    <span class="hljs-attr">data-large</span>=<span class="hljs-string">"https://cdn-images-1.medium.com/max/1800/1*sg-uLNm73whmdOgKlrQdZA.jpeg"</span>\n   &gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>\n</code></pre>\n<p><code>.placeholder</code> 是用来撑起 <code>.banner</code> 的高度。因为如果我们想要让两张图片重叠的话，会用到 <code>position: absolute</code>，定位元素会脱离文档流，那么 <code>.banner</code> 的高度就会为 <code>0</code>。</p>\n<p><code>.img-small</code> 首先加载的是小图片。大图片的 URL 放在了 <code>data-large</code> 属性里面。</p>\n<p>接下来是，CSS部分：</p>\n<pre class="hljs"><code><span class="hljs-selector-class">.banner</span> {\n  <span class="hljs-attribute">position</span>: relative;\n  <span class="hljs-attribute">overflow</span>: hidden;\n}\n\n<span class="hljs-selector-class">.placeholder</span> {\n  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">66.6%</span>;\n}\n\n<span class="hljs-selector-tag">img</span> {\n  <span class="hljs-attribute">position</span>: absolute;\n  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1s</span> linear;\n}\n\n<span class="hljs-selector-tag">img</span><span class="hljs-selector-class">.loaded</span> {\n  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n}\n\n<span class="hljs-selector-class">.img-small</span> {\n  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(50px);\n  <span class="hljs-attribute">-webkit-filter</span>: <span class="hljs-built_in">blur</span>(50px);\n}\n</code></pre>\n<p><code>.banner</code> 设置了 <code>relative</code>，所以他成为了他 children (<code>.placeholder</code>, <code>img</code>) 的 <em>containning block</em> 了。</p>\n<p>注意到，<code>.placeholder</code> 设置了 <code>padding-bottom: 66.6%</code>。<code>66.6%</code> 是相对于他的 <em>containning block</em> 的宽度，也就是 <code>.banner</code> 的宽度。<br>\n这个值应该和 <code>img</code> 的高度一样，这样一来，<code>.banner</code> 的高度就是 <code>img</code> 的高度了。</p>\n<p>利用 <code>transition</code> 让透明度变化有个渐变效果。</p>\n<p>实现模糊效果是使用了 <code>filter: blur()</code>，而没有使用 <code>&lt;canvas&gt;</code>。</p>\n<p>然后，JavaScript 代码部分比较简单：</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> app = <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> {\n  <span class="hljs-keyword">const</span> imgSmall = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'.img-small\'</span>)\n\n  <span class="hljs-keyword">const</span> loadImage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image()\n\n    img.src = imgSmall.src\n    img.addEventListener(<span class="hljs-string">\'load\'</span>, (e) =&gt; {\n      imgSmall.classList.add(<span class="hljs-string">\'loaded\'</span>)\n    }, <span class="hljs-literal">false</span>)\n\n    <span class="hljs-keyword">const</span> imgLarge = <span class="hljs-keyword">new</span> Image()\n\n    imgLarge.src = imgSmall.dataset.large\n    imgLarge.addEventListener(<span class="hljs-string">\'load\'</span>, (e) =&gt; {\n      imgLarge.classList.add(<span class="hljs-string">\'loaded\'</span>)\n    }, <span class="hljs-literal">false</span>)\n\n    imgSmall.parentNode.appendChild(imgLarge)\n  }\n\n  <span class="hljs-keyword">return</span> {\n    loadImage\n  }\n\n})()\n\napp.loadImage()\n</code></pre>\n<p>需要注意的是，我们不能直接监听 <code>.img-small</code> 的 <code>load</code> 事件，要 <code>new Image</code>，然后赋予其 <code>src</code>，然后我们就可以监听他的 <code>load</code> 事件了。</p>\n<p>最后，为了凸显效果，我们要禁止缓存和设置较差的网络环境。具体做法如图：</p>\n<p><img src="/network.png" alt=""></p>\n<p>实际效果如下：<br>\n{% jsfiddle 5sLzjk99 %}</p>\n<h2 id="resources"><a class="header-anchor" href="#resources" aria-hidden="true">#</a> Resources</h2>\n<ul>\n<li><a href="https://jmperezperez.com/medium-image-progressive-loading-placeholder/">How Medium does progressive image loading</a></li>\n</ul>\n',
frontmatter:"title: Medium 是如何加载图片的？\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-03-01 17:11:29\nforeword: 分析及实现 Medium 加载图片的效果。"}},function(s,a){s.exports={attributes:{title:"「译」JavaScript Modules Part1: A Beginner Guide",author:"Drake Leung",tags:[],categories:["翻译"],date:"2016-02-07T21:50:52.000Z",foreword:"超级详细地介绍了 JavaScript 模块化的进化历史。"},body:'<p><strong>(原文：<a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.4ufizwkud">JavaScript Modules: A Beginner\'s Guide - Preethi Kasireddy</a>)</strong></p>\n<p>如果你是刚接触 JavaScript 的话，像「module bundler vs. module loaders」， 「Webpack vs. Browserify」 以及「AMD vs. CommonJS」这些术语可以一下子把你搞晕。</p>\n<p>JavaScript的模块系统(module system)也许是很吓人的，但是对于web开发者来说，理解他是很重要的。</p>\n<p>在本文，我会使用通俗易懂的话(以及一些代码)来解释这些术语。我希望能帮助到你。</p>\n<p>注意：为了简单起见，我会分成2部分来说：Part 1 会解释什么是 <em>module</em> 以及为什么要使用他们。Part 2 (在下周发表)会接着解释什么是 <em>bundle modules</em> 以及其实现方法。</p>\n<h2 id="part-1-module"><a class="header-anchor" href="#part-1-module" aria-hidden="true">#</a> Part 1: 有谁可以再解释解释什么是 module 吗？</h2>\n<p>好的作者会把他们的书籍分成多个章节；好的程序员也会把他们的程序分成多个模块。</p>\n<p>就像书的章节一样，module 只是单词(在这里，即是 code )的集合。</p>\n<p>但是，好的模块是高度包含自己独立的功能。这让他们可以根据需求更改，删除，增加，而不扰乱整个系统。</p>\n<h2 id="module"><a class="header-anchor" href="#module" aria-hidden="true">#</a> 为什么使用 module ？</h2>\n<p>使用modules对于大型，相互依赖的代码库来说是很多好处的。在我看来，最重要的是：</p>\n<p>**1) 可维护性：**根据定义，module 是独立的。一个设计良好的 module 是尽可能多地减少代码的耦合，从而他能够独立地开发和改进。当一个 module 的耦合度低的时候，更新他是很容易一件事情。</p>\n<p>回到我们书籍的例子，当你因为更新了一个章节，从而需要调整剩余章节的话，这简直是噩耗。相反，你更愿意编写章节的时候，不影响其他章节。</p>\n<p>**2) 命名空间(namespacing)：**在 JavaScript 中，在 top-level 函数的作用域的外面的变量就是 <em>global</em> (全局)变量，全局变量即是每个人都可以 access 他们。因为这样，就很容易造成&quot;命名空间污染”，也就是无相关的代码共享全局变量。</p>\n<p>在毫无相关的代码中共享全局变量在开发中 <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">is a big no no</a>。</p>\n<p>在本文的下面，我们会解释 module 可以让我们避免命名空间污染，通过为我们的变量创建私有空间。</p>\n<p>**3) 可重用性：**我们不妨老实承认，我们过去是把一个项目的代码copy到另一个项目中。比方说，你copy了你之前项目的一些util方法到当前的项目中。</p>\n<p>这是很浪费时间的。但是慢着，如果使用 module ，一个我们可以不断复用的 module ，这不是很好吗？</p>\n<h2 id="incorporate-modules"><a class="header-anchor" href="#incorporate-modules" aria-hidden="true">#</a> 你是如何合并模块(incorporate modules)?</h2>\n<p>有很多方法可以在你的程序中合并模块。我们现在就来讲解他们的其中一些：</p>\n<h3 id="module-pattern"><a class="header-anchor" href="#module-pattern" aria-hidden="true">#</a> Module Pattern</h3>\n<p><em>Module pattern</em> 其实就是模仿 <em>class</em> 的概念(因为 JavaScript 并不真正地支持 class )，因此我们可以把公有方法，私有方法以及变量都保存在一个对象里面——这个就有点类似于 class 在其他编程语言(如 Java 或者 Python )中的使用。这可以让我们给公有方法创建 API ，然后暴露出去；并且同时可以把私有的变量和方法都封装在一个闭包作用域(closure scope)中。</p>\n<p>有几个方法可以实现 module pattern。在第一个例子中。我会使用 <em>anonymous closure</em>。他会把我们所有的代码都放进一个匿名函数里面。(记住：在 JavaScript 中，<code>function</code> 是创建作用域的唯一方法？)</p>\n<p><strong>例子一：Anonymous closure</strong></p>\n<pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// We keep these variables private inside this closure scope</span>\n\n  <span class="hljs-keyword">var</span> myGrades = [<span class="hljs-number">93</span>, <span class="hljs-number">95</span>, <span class="hljs-number">88</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>, <span class="hljs-number">91</span>];\n\n  <span class="hljs-keyword">var</span> average = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> total = myGrades.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, item</span>) </span>{\n      <span class="hljs-keyword">return</span> accumulator + item}, <span class="hljs-number">0</span>);\n\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'Your average grade is \'</span> + total / myGrades.length + <span class="hljs-string">\'.\'</span>;\n  }\n\n  <span class="hljs-keyword">var</span> failing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-keyword">var</span> failingGrades = myGrades.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n      <span class="hljs-keyword">return</span> item &lt; <span class="hljs-number">70</span>;});\n\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'You failed \'</span> + failingGrades.length + <span class="hljs-string">\' times.\'</span>;\n  }\n\n  <span class="hljs-built_in">console</span>.log(failing());\n\n}());\n\n<span class="hljs-comment">// ‘You failed 2 times.’</span>\n</code></pre>\n<p>有了这个，我们的匿名函数就有了它自己的求值环境(evaluation environment)或者&quot;closure&quot;，并且我们可以立马对他求值(evaluate)。这可以让我们从 parent namespace(global) 中隐藏变量。</p>\n<p>这种方法的好处就是，你可以在匿名函数中使用局部变量而不会 overwrite(覆盖) 已经存在的全局变量，但与此同时，你还可以 access 全局变量，就像这样：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> global = <span class="hljs-string">\'Hello, I am a global variable :)\'</span>;\n\n(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// We keep these variables private inside this closure scope</span>\n\n  <span class="hljs-keyword">var</span> myGrades = [<span class="hljs-number">93</span>, <span class="hljs-number">95</span>, <span class="hljs-number">88</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>, <span class="hljs-number">91</span>];\n\n  <span class="hljs-keyword">var</span> average = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> total = myGrades.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, item</span>) </span>{\n      <span class="hljs-keyword">return</span> accumulator + item}, <span class="hljs-number">0</span>);\n\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'Your average grade is \'</span> + total / myGrades.length + <span class="hljs-string">\'.\'</span>;\n  }\n\n  <span class="hljs-keyword">var</span> failing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-keyword">var</span> failingGrades = myGrades.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n      <span class="hljs-keyword">return</span> item &lt; <span class="hljs-number">70</span>;});\n\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'You failed \'</span> + failingGrades.length + <span class="hljs-string">\' times.\'</span>;\n  }\n\n  <span class="hljs-built_in">console</span>.log(failing());\n  <span class="hljs-built_in">console</span>.log(global);\n}());\n\n<span class="hljs-comment">// \'You failed 2 times.\'</span>\n<span class="hljs-comment">// \'Hello, I am a global variable :)\'</span>\n</code></pre>\n<p>注意到在匿名函数2旁的括号是必须的，因为以关键字<code>function</code>开头的语句会被认为是 <em>function declaration</em> (记住，在 JavaScript 中，你是不能定义没有名字的function declaration。) 因此，这对括号就创建一个 <em>function expression</em>。如果不明白的话，你可以<a href="http://stackoverflow.com/questions/1634268/explain-javascripts-encapsulated-anonymous-function-syntax">阅读这里</a>。</p>\n<p><strong>例子二：Global import</strong></p>\n<p>另一个较流行的方法是 <em>global import</em> ，就像 jQuery 一样。他有点类似于上面的　<em>anonymous closure</em>，只是现在我们把全局变量作为参数传进了匿名函数中。</p>\n<pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">globalVariable</span>) </span>{\n\n  <span class="hljs-comment">// Keep this variables private inside this closure scope</span>\n  <span class="hljs-keyword">var</span> privateFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Shhhh, this is private!\'</span>);\n  }\n\n  <span class="hljs-comment">// Expose the below methods via the globalVariable interface while</span>\n  <span class="hljs-comment">// hiding the implementation of the method within the</span>\n  <span class="hljs-comment">// function() block</span>\n\n  globalVariable.each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, iterator</span>) </span>{\n    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(collection)) {\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; collection.length; i++) {\n        iterator(collection[i], i, collection);\n      }\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> collection) {\n        iterator(collection[key], key, collection);\n      }\n    }\n  };\n\n  globalVariable.filter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, test</span>) </span>{\n    <span class="hljs-keyword">var</span> filtered = [];\n    globalVariable.each(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n      <span class="hljs-keyword">if</span> (test(item)) {\n        filtered.push(item);\n      }\n    });\n    <span class="hljs-keyword">return</span> filtered;\n  };\n\n  globalVariable.map = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, iterator</span>) </span>{\n    <span class="hljs-keyword">var</span> mapped = [];\n    globalUtils.each(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, collection</span>) </span>{\n      mapped.push(iterator(value));\n    });\n    <span class="hljs-keyword">return</span> mapped;\n  };\n\n  globalVariable.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection, iterator, accumulator</span>) </span>{\n    <span class="hljs-keyword">var</span> startingValueMissing = accumulator === <span class="hljs-literal">undefined</span>;\n\n    globalVariable.each(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n      <span class="hljs-keyword">if</span>(startingValueMissing) {\n        accumulator = item;\n        startingValueMissing = <span class="hljs-literal">false</span>;\n      } <span class="hljs-keyword">else</span> {\n        accumulator = iterator(accumulator, item);\n      }\n    });\n\n    <span class="hljs-keyword">return</span> accumulator;\n\n  };\n\n }(globalVariable));\n</code></pre>\n<p>在这个例子中，<code>globalVariable</code> 在全局中唯一的一个变量。这个方法比前一个方法好的地方在于：你可以在前面就定义全局变量，这样就方便别人阅读你的代码。</p>\n<p><strong>例子三：Object interface</strong></p>\n<p>创建 module 的例子还有一个就是使用独立的 <em>object interface</em>，就像这样：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> myGradesCalculate = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\n  <span class="hljs-comment">// Keep this variable private inside this closure scope</span>\n  <span class="hljs-keyword">var</span> myGrades = [<span class="hljs-number">93</span>, <span class="hljs-number">95</span>, <span class="hljs-number">88</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>, <span class="hljs-number">91</span>];\n\n  <span class="hljs-comment">// Expose these functions via an interface while hiding</span>\n  <span class="hljs-comment">// the implementation of the module within the function() block</span>\n\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">average</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">var</span> total = myGrades.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, item</span>) </span>{\n        <span class="hljs-keyword">return</span> accumulator + item;\n        }, <span class="hljs-number">0</span>);\n\n      <span class="hljs-keyword">return</span><span class="hljs-string">\'Your average grade is \'</span> + total / myGrades.length + <span class="hljs-string">\'.\'</span>;\n    },\n\n    <span class="hljs-attr">failing</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">var</span> failingGrades = myGrades.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n          <span class="hljs-keyword">return</span> item &lt; <span class="hljs-number">70</span>;\n        });\n\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'You failed \'</span> + failingGrades.length + <span class="hljs-string">\' times.\'</span>;\n    }\n  }\n})();\n\nmyGradesCalculate.failing(); <span class="hljs-comment">// \'You failed 2 times.\'</span>\nmyGradesCalculate.average(); <span class="hljs-comment">// \'Your average grade is 70.33333333333333.\'</span>\n</code></pre>\n<p>显而易见，这种方法可以让我们自己定义哪些变量/方法是私有的(例如，<code>myGrads</code>)，以及哪些变量/方法是我们想要暴露给他们的，通过 <code>return</code> 语句(比如，<code>average</code> &amp; <code>failing</code>)。</p>\n<p><strong>例子四：Revealing module pattern</strong></p>\n<p>这个跟上面的方法是很相似的，除了他保证所有的变量和方法都是私有的，直到我们显式地暴露出去：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> myGradesCalculate = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\n  <span class="hljs-comment">// Keep this variable private inside this closure scope</span>\n  <span class="hljs-keyword">var</span> myGrades = [<span class="hljs-number">93</span>, <span class="hljs-number">95</span>, <span class="hljs-number">88</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>, <span class="hljs-number">91</span>];\n\n  <span class="hljs-keyword">var</span> average = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> total = myGrades.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, item</span>) </span>{\n      <span class="hljs-keyword">return</span> accumulator + item;\n      }, <span class="hljs-number">0</span>);\n\n    <span class="hljs-keyword">return</span><span class="hljs-string">\'Your average grade is \'</span> + total / myGrades.length + <span class="hljs-string">\'.\'</span>;\n  };\n\n  <span class="hljs-keyword">var</span> failing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> failingGrades = myGrades.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n        <span class="hljs-keyword">return</span> item &lt; <span class="hljs-number">70</span>;\n      });\n\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'You failed \'</span> + failingGrades.length + <span class="hljs-string">\' times.\'</span>;\n  };\n\n  <span class="hljs-comment">// Explicitly reveal public pointers to the private functions</span>\n  <span class="hljs-comment">// that we want to reveal publicly</span>\n\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">average</span>: average,\n    <span class="hljs-attr">failing</span>: failing\n  }\n})();\n\nmyGradesCalculate.failing(); <span class="hljs-comment">// \'You failed 2 times.\'</span>\nmyGradesCalculate.average(); <span class="hljs-comment">// \'Your average grade is 70.33333333333333.\'</span>\n</code></pre>\n<p>上面好像讲了好多东西，其实对于 module pattern 来说，只是冰山一角。下面是一些我认为比较有用的资源：</p>\n<ul>\n<li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript">Learn JavaScript Design Patterns</a> - by <em>Addy Osmani</em></li>\n<li><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">Adequately Good by Ben Cherry</a> - 通过例子讲述module pattern的高级使用</li>\n<li><a href="https://carldanley.com/js-module-pattern/">Blog of Carl Danley</a> - module pattern的概述以及其他 JavaScript pattern 的资源</li>\n</ul>\n<h2 id="commonjs-and-amd"><a class="header-anchor" href="#commonjs-and-amd" aria-hidden="true">#</a> CommonJS and AMD</h2>\n<p>上面讲到的所有方法都有一个共同点：使用全局变量将其所有代码都封装在一个函数里面，从而使用 <em>closure scope</em> 为他自己创建出了一个私有的命名空间。</p>\n<p>他们各自有各自的优点，但是他们也有他们的弊端。</p>\n<p>其中一个，作为一名开发者，为了加载你的文件，你需要知道正确的依赖顺序。比如，你要在项目中使用 <code>Backbone</code>，那么你需要通过 <code>script</code> 标签来加载他的源文件。</p>\n<p>但是，因为 <code>Backbone</code> 是依赖 <code>Underscore.js</code>，那么加载 <code>Backbone</code> 的 <code>script</code> 标签就不能在 <code>Underscore</code> 的前面。</p>\n<p>作为一名开发者，维护依赖以及让他们的顺序都正确的话，有时是一件很头疼的事情。</p>\n<p>另一个弊端就是他们仍然会产生命名空间冲突。比如，你的两个 module 具有相同的名字。又或者，你的一个模块有两个版本，并且你同时需要他们。</p>\n<p>因此，你也会这样想到：能不能设计一种方法，既可以访问 module 的接口，但同时又不污染全局作用域。</p>\n<p>其实有两种已经实现好的方法：即是 CommonJS 和 AMD 。</p>\n<h3 id="commonjs"><a class="header-anchor" href="#commonjs" aria-hidden="true">#</a> CommonJS</h3>\n<p>CommonJS是一个自愿的工作小组，设计和实现 JavaScript 模块系统的 API。</p>\n<p>一个 CommonJS 模块其实就是 <code>exports</code> 了具体对象的 JavaScript 代码块，使得他们能够被程序中的其他模块 <code>require</code> 。如果你写过 <code>Node.js</code> 的话，你应该对他很熟悉。</p>\n<p>有了 CommonJS，每个 JavaScript 文件在他们各自唯一的 module context (就像封装在一个闭包中)保存了模块。在这个作用域里面，我们使用 <code>module.exports</code> 对象来暴露模块，使用<code>require</code>来加载他们。</p>\n<p>当你定义了一个 CommonJS 文件，也许他就长这样子的：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myModule</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">this</span>.hello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'hello!\'</span>;\n  }\n\n  <span class="hljs-keyword">this</span>.goodbye = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'goodbye!\'</span>;\n  }\n}\n\n<span class="hljs-built_in">module</span>.exports = myModule;\n</code></pre>\n<p>我们使用特殊的对象<code>module</code>，然后把我们函数的引用赋给<code>module.exports</code>。这个让CommonJS的模块系统知道我们想要暴露哪些，从而让别的文件引用。</p>\n<p>然后，如果别人想使用我的<code>myModule</code>，他们可以引用它到文件中，像这样：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> myModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'myModule\'</span>);\n\n<span class="hljs-keyword">var</span> myModuleInstance = <span class="hljs-keyword">new</span> myModule();\nmyModuleInstance.hello(); <span class="hljs-comment">// \'hello!\'</span>\nmyModuleInstance.goodbye(); <span class="hljs-comment">// \'goodbye!\'</span>\n</code></pre>\n<p>这个方法比前面所讲的 <em>module pattern</em> 有2个明显的优点：</p>\n<ol>\n<li>避免全局命名空间的污染</li>\n<li>让我们的依赖更加清晰</li>\n</ol>\n<p>而且，语法很简洁，我很喜欢。</p>\n<p>还有一个注意的是，CommonJS是针对server实现的，并且<strong>同步加载modules</strong>。这是很重要的，因为如果我们有3个module需要引入，那么他会一个接着一个加载。</p>\n<p>现在，CommonJS对于server端很极好的。但是不幸的是，他不适用于浏览器。因为在web读取一个module比在磁盘中读取慢得多。如果开始加载module，就会阻塞浏览器直到modules全部加载完毕。(我会在 Part 2 讲述解决方法)。</p>\n<h3 id="amd"><a class="header-anchor" href="#amd" aria-hidden="true">#</a> AMD</h3>\n<p>CommonJS是很好，但是如果我们想要异步加载modules呢？答案就是<em>Asynchronous Module Definition</em>，即<em>AMD</em>。</p>\n<p>使用AMD加载module就像这样：</p>\n<pre class="hljs"><code>define([<span class="hljs-string">\'myModule\'</span>, <span class="hljs-string">\'myOtherModule\'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">myModule, myOtherModule</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(myModule.hello());\n});\n</code></pre>\n<p><code>define</code>函数的第一个参数是一个数组，他包含了所需的依赖。这些依赖会在背后加载(不会阻塞)，而且一旦加载完毕，<code>define</code>就会调用传给他的callback函数。</p>\n<p>接着，callback函数就会把加载好的依赖作为他的参数——在上面例子中，即是<code>myModule</code>和<code>myOtherModule</code>。最后，这些依赖他们自己必须通过关键字<code>define</code>来定义。</p>\n<p>比如，<code>myModule</code>也许是这样子的：</p>\n<pre class="hljs"><code>define([], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">hello</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'hello\'</span>);\n    },\n    <span class="hljs-attr">goodbye</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'goodbye\'</span>);\n    }\n  };\n});\n</code></pre>\n<p>不像CommonJS，AMD是以浏览器为核心来实现异步加载module的。(注意到，有很多人强烈地认为动态加载文件是不好的，这个我们在Part 2会讲到)。</p>\n<p>除了异步之外，AMD的另一个优点是，你的module可以是对象，函数，构造函数，字符串，JSON以及其他类型。而CommonJS只支持对象作为module。</p>\n<p>总的来说，AMD并不兼容io，文件系统，以及其他面向server的feature，并且，封装的语法比<code>require</code>较复杂一点。</p>\n<h3 id="umd"><a class="header-anchor" href="#umd" aria-hidden="true">#</a> UMD</h3>\n<p>对于需要你同时支持AMD和CommonJS的项目，你可以选择<em>Universal Module Definition (UMD)</em>。</p>\n<p>UMD本质上创建了一个方式，支持他们其中的一种，也支持全局变量的定义。因此，UMD module可以同时在client和server端使用。</p>\n<p>让我们来看看UMD是怎样子的：</p>\n<pre class="hljs"><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root, factory</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">\'function\'</span> &amp;&amp; define.amd) {\n      <span class="hljs-comment">// AMD</span>\n    define([<span class="hljs-string">\'myModule\'</span>, <span class="hljs-string">\'myOtherModule\'</span>], factory);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">\'object\'</span>) {\n      <span class="hljs-comment">// CommonJS</span>\n    <span class="hljs-built_in">module</span>.exports = factory(<span class="hljs-built_in">require</span>(<span class="hljs-string">\'myModule\'</span>), <span class="hljs-built_in">require</span>(<span class="hljs-string">\'myOtherModule\'</span>));\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">// Browser globals (Note: root is window)</span>\n    root.returnExports = factory(root.myModule, root.myOtherModule);\n  }\n}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">myModule, myOtherModule</span>) </span>{\n  <span class="hljs-comment">// Methods</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notHelloOrGoodbye</span>(<span class="hljs-params"></span>)</span>{}; <span class="hljs-comment">// A private method</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>{}; <span class="hljs-comment">// A public method because it\'s returned (see below)</span>\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">goodbye</span>(<span class="hljs-params"></span>)</span>{}; <span class="hljs-comment">// A public method because it\'s returned (see below)</span>\n\n  <span class="hljs-comment">// Exposed public methods</span>\n  <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">hello</span>: hello,\n      <span class="hljs-attr">goodbye</span>: goodbye\n  }\n}));\n</code></pre>\n<p>更多关于UMD的例子，请查看 <a href="https://github.com/umdjs/umd">enlightening repo</a>。</p>\n<h2 id="native-js"><a class="header-anchor" href="#native-js" aria-hidden="true">#</a> Native JS</h2>\n<p>哈！你居然能看到这里，看来我没有搞晕你。太棒了。因为在结束之前，我们还有一个定义module的方法。</p>\n<p>如你所见，上面的方法没有一种是原生JavaScript支持的。相反，我们使用了各种各样的方式去模拟一个模块系统。</p>\n<p>幸运的是，在TC39工作的人(设计ECMAScript的语法和语义)在ES6实现了内置的模块系统。</p>\n<p>下面的资源很好地讲解了ES6的模块系统：</p>\n<ul>\n<li><a href="http://jsmodules.io/cjs.html">jsmodules.io</a></li>\n<li><a href="http://exploringjs.com/es6/ch_modules.html">exploringjs.com</a></li>\n</ul>\n<p>ES6的module结合了CommonJS和AMD的优点，比如简洁的语法和异步加载。还有优点是，比如支持循环依赖。</p>\n<p>我最喜欢的ES6 modules的feature是，<em>imports</em>是<em>exports</em>的<strong>live read-only views</strong>(而CommonJS的import只是exports的一份copy而已，并且不是即时)。</p>\n<p>下面例子会讲述live read-only view是怎样子的：</p>\n<pre class="hljs"><code><span class="hljs-comment">// lib/counter.js</span>\n\n<span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>{\n  counter++;\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>{\n  counter--;\n}\n\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">counter</span>: counter,\n  <span class="hljs-attr">increment</span>: increment,\n  <span class="hljs-attr">decrement</span>: decrement\n};\n\n\n<span class="hljs-comment">// src/main.js</span>\n\n<span class="hljs-keyword">var</span> counter = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'../../lib/counter\'</span>);\n\ncounter.increment();\n<span class="hljs-built_in">console</span>.log(counter.counter); <span class="hljs-comment">// 1</span>\n</code></pre>\n<p>在这个例子中，我们创建了module的<strong>2份copy</strong>：一个是当我们<code>export</code>他，另一个是当我们<code>require</code>他。</p>\n<p>并且，在<code>main.js</code>的那份copy已经和原本的失去连接了。这就是为什么当我们给<code>counter</code>增加时他还是<code>1</code>——因为我们<code>import</code>的<code>counter</code>已经和原来的失去联系。</p>\n<p>因为，增加<code>counter</code>会在原来的module可以实现，但是在你copy的那份就实现不了。如果想要后者实现的话，只能手动地操作了：</p>\n<pre class="hljs"><code>counter.counter++;\n<span class="hljs-built_in">console</span>.log(counter.counter); <span class="hljs-comment">// 2</span>\n</code></pre>\n<p>在另一个方面，ES6对于我们<code>import</code>的module创建了一个<strong>live read-only view</strong>。</p>\n<pre class="hljs"><code><span class="hljs-comment">// lib/counter.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>{\n  counter++;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>) </span>{\n  counter--;\n}\n\n\n<span class="hljs-comment">// src/main.js</span>\n<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> counter <span class="hljs-keyword">from</span> <span class="hljs-string">\'../../counter\'</span>;\n\n<span class="hljs-built_in">console</span>.log(counter.counter); <span class="hljs-comment">// 1</span>\ncounter.increment();\n<span class="hljs-built_in">console</span>.log(counter.counter); <span class="hljs-comment">// 2</span>\n</code></pre>\n<p>很cool，对吧。</p>\n<h2 id="bunding-modules"><a class="header-anchor" href="#bunding-modules" aria-hidden="true">#</a> 向前看：bunding modules</h2>\n<p>哇。时间过得真快。我真的希望能够帮助你更好地理解JavaScript的modules。</p>\n<p>在下一部分，我会讲<strong>module bundling</strong>，涉及到几个核心的主题：</p>\n<ul>\n<li>为什么我们需要<em>module bundling</em></li>\n<li>不同方法实现<em>bundling</em></li>\n<li>ECMAScript的模块加载器API</li>\n<li>...更多...</li>\n</ul>\n<p>注意：为了简单起见，我跳过了许多细节(比如，循环依赖)。如果我留下了很重要或者很棒的东西，请留言让我知道！</p>\n<p><strong>(原文：<a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.4ufizwkud">JavaScript Modules: A Beginner’s Guide - Preethi Kasireddy</a>)</strong></p>\n',frontmatter:"title: '「译」JavaScript Modules Part1: A Beginner Guide'\nauthor: Drake Leung\ntags: []\ncategories: [翻译]\ndate: 2016-02-07 21:50:52\nforeword: 超级详细地介绍了 JavaScript 模块化的进化历史。"}},function(s,a){s.exports={attributes:{title:"「译」JavaScript Modules Part2: Module Bundling",author:"Drake Leung",tags:[],categories:["翻译"],date:"2016-02-08T15:57:07.000Z",foreword:"JavaScript 模块化 Part2 - 主要讲述 module bundling。"},body:'<p><strong>(原文：<a href="https://medium.freecodecamp.com/javascript-modules-part-2-module-bundling-5020383cf306#.m5o3ar7dt">JavaScript Modules Part 2: Module Bundling</a>)</strong></p>\n<p>在Part 1，我讲解了什么是 <em>module</em> ，为什么要使用他们，以及合并 module 的各种方法。在Part 2，我会讲解什么是 <em>bundle modules</em> : 为什么要，不同方法的实现，以及 module 在今后web开发的情况。</p>\n<h2 id="module-bundling"><a class="header-anchor" href="#module-bundling" aria-hidden="true">#</a> 什么是 module bundling?</h2>\n<p>简单来说，<em>module bundling</em> 其实就是把一组 module (以及他们的依赖)，按照正确的顺序，打包(bundle)到一个单独的文件(或者一组文件)里面。但是对于web开发来说，细节才是魔鬼 :)</p>\n<h2 id="module"><a class="header-anchor" href="#module" aria-hidden="true">#</a> 为什么把所有的 module 都打包在一起？</h2>\n<p>当你把程序分成多个 module 的时候，你很可能会把他们组织在不同的文件和文件夹中。偶尔你会有第三方 module ，比如<code>Underscore</code>或者<code>React</code>。</p>\n<p>那么，当用户浏览你的页面时，这些文件都会通过 <code>&lt;script&gt;</code> 标签引入到你的 HTML 文件。每个文件就需要一个 <code>&lt;script&gt;</code> 标签，就意味着，浏览器需要单独地加载每个文件，一个...接着...一个。</p>\n<p>...然而这对于页面的加载时间是很不友好的。</p>\n<p>为了解决这个问题，我们 <em>bundle</em>，或者 <em>concatenate</em> 所有的文件到一个大文件里面(或者一组文件，根据情况)，这样就可以减少请求的数量。这个就是你听别的开发人员所说的「build step」或者「build process」。</p>\n<p>另一个加速 bundling 操作的的方法是「minify」(压缩)代码。<em>minification</em> 就是从源代码中去除不必要的字符(比如，空格，注释，换行符等)。这样一来，不仅减少了代码的大小，而且不影响其本身的功能。</p>\n<p>更少的数据就意味着浏览器处理的时间更少，因为减少了下载文件的时间。如果你曾经见过文件名有后缀<code>min</code>，比如<code>underscore.min.js</code>，其实就是相对于完整版的一个不具可读性，压缩过的版本。</p>\n<p>像 <em>gulp</em> 或者 <em>Grunt</em> 这样的 Task runners，对开发者来说，是很容易进行<code>concatenations</code>和<code>minification</code>。这样一来，保证了代码对开发者的可读性的同时，也保证了对浏览器的优化。</p>\n<h2 id="bundle-module"><a class="header-anchor" href="#bundle-module" aria-hidden="true">#</a> 实现bundle module的各种方法</h2>\n<p>当你使用标准的 module pattern (前面讲解的)的其中一种来定义 module 的时候，<em>concatenating</em> 和 <em>minifying</em> 你的文件是极好的，你所需要做的就是把你的一堆JavaScript代码打包在一起。</p>\n<p>但是，当你使用浏览器不能解析的非原生模块系统时，比如 CommonJS，AMD。你需要一种特殊的工具来把你的代码转换成浏览器可以解析的。这就是为什么 <em>Browserify</em>，<em>RequireJS</em>，<em>Webpack</em>，和其他「module bundlers」又或者「module loaders」会出现。</p>\n<p>为了 bundling 或者 loading 你的代码，module bundlers 提供了好多额外的 feature。比如当你修改代码时自动重编译，还有提供调试时所需要的 source maps。</p>\n<p>现在让我们来看看 module bundling 的几种方法:</p>\n<h3 id="bundling-commonjs"><a class="header-anchor" href="#bundling-commonjs" aria-hidden="true">#</a> Bundling CommonJS</h3>\n<p>从 Part1 可知，CommonJS 是同步加载 module 的，这是很好的除了对浏览器不适用之外。我提到过有解决方法——其中一种就是使用 <em>Browserify</em> 。Browserify 可以给浏览器编译 CommonJS 的 module。</p>\n<p>举个例子，我们有一个 <code>main.js</code> 文件，他 <em>import</em> 了一个可以计算数组平均值的 module:</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> myDependency = <span class="hljs-built_in">require</span>(‘myDependency’);\n<span class="hljs-keyword">var</span> myGrades = [<span class="hljs-number">93</span>, <span class="hljs-number">95</span>, <span class="hljs-number">88</span>, <span class="hljs-number">0</span>, <span class="hljs-number">91</span>];\n<span class="hljs-keyword">var</span> myAverageGrade = myDependency.average(myGrades);\n</code></pre>\n<p>在这个例子中，我们有一个依赖(<code>myDependency</code>)。使用下面的命令，<em>Browserify</em> 会递归地把<code>main.js</code>前面所有需要的module打包到一个单独的文件里(<code>bundle.js</code>)：</p>\n<pre class="hljs"><code>\tbrowserify main.js -o bundle.js\n</code></pre>\n<p><em>Browserify</em> 的实现方法：为了遍历你整个项目的依赖，他会把每个 <code>require</code> 解析成 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>。当他计算出你项目的依赖关系时，他就会按照正确的顺序把他们都打包在一个单独的文件里面。因此，你只需要把一个单独的，带上<code>bundle.js</code>的<code>&lt;script&gt;</code>标签放在你的 HTML 文件里面。这样一来，只要一个 HTTP 请求，就可以加载所有的modules。豪爽~</p>\n<p>相似地，如果你有多个文件且有多个依赖，你只需要简单地告诉 <em>Browserify</em> 你的 <code>entry file</code>，然后坐下，<em>Browserify</em> 就会开始施魔法。</p>\n<p>最后：准备好你打包好的文件，然后使用像 <em>Minify-JS</em> 这样的工具来压缩的你的代码。</p>\n<h3 id="bundling-amd"><a class="header-anchor" href="#bundling-amd" aria-hidden="true">#</a> Bundling AMD</h3>\n<p>如果你使用AMD，也许你会使用一个像<code>RequireJS</code>或者<code>Curl</code>这样的AMD加载器。一个module loader(vs. a bundler)会动态地加载module，当你程序需要的时候。</p>\n<p>提醒一下，AMD与CommonJS不同的地方之一是，前者是动态加载模块的。也就是说，有了AMD，你实际上不需要<em>build step</em>(打包你所有的module到一个单独文件)，因为你是动态加载module——也就是只有当你需要module的时候才去下载文件，而不是当用户第一次浏览的时候，就把所有的module都下载。</p>\n<p>但在实际生产中，用户每次行为就需要请求下载对应的module是没有意义的。因此很多web开发者为了额外的性能，都会使用工具去打包和压缩他们的AMD modules，比如<em>RequireJS optimizer</em>，<em>r.js</em>。</p>\n<p>总的来说，AMD和CommonJS关于bundling的区别是：前者可以不需要build step。除非，你想<em>push the code live</em>，这时你可以使用像<code>r.js</code>这样的优化器。</p>\n<p>更多关于CommonJS和AMD的讨论，请查看这篇文章<a href="http://tomdale.net/2012/01/amd-is-not-the-answer/">Tom Dale’s blog</a> :)</p>\n<h3 id="webpack"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> Webpack</h3>\n<p>就目前的bundlers来说，<em>Webpack</em>是锋芒初现的。他可以识别任意一种模块系统，比如CommonJS，AMD或者ES6。</p>\n<p>你也许会这样想到：既然我们已经有了Browserify和RequireJS这样的工具，为什么还需要Webpack。其实，Webpack提供了很有用的feature像<strong>code splitting</strong>—把你的代码拆分成动态加载的「chuncks」。</p>\n<p>比如说，如果你的web应用有一块代码是在特定情况下才加载的，那么把所有的代码打包在一个单独的很大的文件里面就不是很适合了。在这种情况下，你可以使用<em>code splitting</em>提取代码到按需加载的<em>chunks</em>里面，这样就避免了用户首次访问时需要加载体积很大的<code>bundle.js</code>。</p>\n<p><em>Code splitting</em>是Webpack提供的feature之一。网上有很多讨论Webpack和Browserify的文章，不妨看下面的链接：</p>\n<ul>\n<li><a href="https://gist.github.com/substack/68f8d502be42d5cd4942">https://gist.github.com/substack/68f8d502be42d5cd4942</a></li>\n<li><a href="http://mattdesl.svbtle.com/browserify-vs-webpack">http://mattdesl.svbtle.com/browserify-vs-webpack</a></li>\n<li><a href="http://blog.namangoel.com/browserify-vs-webpack-js-drama">http://blog.namangoel.com/browserify-vs-webpack-js-drama</a></li>\n</ul>\n<h2 id="es6-modules"><a class="header-anchor" href="#es6-modules" aria-hidden="true">#</a> ES6 Modules</h2>\n<p>接下来我会讨论ES6 modules，他也许在未来让以上的bundlers的使用变少(等一下你就会明白我在讲什么)。首先，让我们来理解ES6 modules是如何加载的。</p>\n<p>ES6 modules与AMD，CMD最大的不同之处在于，前者设计时考虑到了静态分析(static analysis)。这就意味着，当你<code>import</code> 模块时，这个<code>import</code>动作在编译的时候就完成了。也就是，在执行脚本之前，可以让我们移除掉不需要的<code>exports</code>。移除掉不必要的<code>exports</code>不但可以减少空间，还能减轻浏览器的压力。</p>\n<p>那么问题来了：这个和<em>dead code elimination</em>(如使用UglifyJS去压缩代码)有什么不同？答案是：<strong>看情况</strong>。</p>\n<p>(注意：<em>Dead code elimination</em>其实是移除掉不必要的代码和变量。不妨这样想：他是把你<strong>打包后</strong>的程序的多余的代码和变量移除掉。</p>\n<p>有时候，<em>dead code elimination</em>在ES6 module和UglifyJS中是一样的，但有时候又不是。如果你想了解更多你可以查看在<a href="https://github.com/rollup/rollup">Rollup’s wiki</a>的一个很棒的例子。</p>\n<p>ES6不同的地方在于实现dead code elimination的方法，叫<strong>tree shaking</strong>。Tree shaking实际上与dead code elimination的理念是相反的。他只打包了你所必需的代码，而不是把不需要的代码移除掉。让我们来看一下tree shaking的一个例子：</p>\n<p>假设我们有一个<code>util.js</code>文件 ，他有多个函数，我们用ES6的语法来导出他们。</p>\n<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">collection, iterator</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(collection)) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">collection, test</span>) </span>{\n  <span class="hljs-keyword">var</span> filtered = [];\n  each(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n    <span class="hljs-keyword">if</span> (test(item)) {\n      filtered.push(item);\n    }\n  });\n  <span class="hljs-keyword">return</span> filtered;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">collection, iterator</span>) </span>{\n  <span class="hljs-keyword">var</span> mapped = [];\n  each(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, collection</span>) </span>{\n    mapped.push(iterator(value));\n  });\n  <span class="hljs-keyword">return</span> mapped;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span>(<span class="hljs-params">collection, iterator, accumulator</span>) </span>{\n  <span class="hljs-keyword">var</span> startingValueMissing = accumulator === <span class="hljs-literal">undefined</span>;\n  each(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n    <span class="hljs-keyword">if</span> (startingValueMissing) {\n      accumulator = item;\n      startingValueMissing = <span class="hljs-literal">false</span>;\n    } <span class="hljs-keyword">else</span> {\n      accumulator = iterator(accumulator, item);\n    }\n  });\n  <span class="hljs-keyword">return</span> accumulator;\n}\n</code></pre>\n<p>接下来，我们假设我们并不知道我们需要<code>util.js</code>的哪一个函数，所以，在<code>main.js</code>中我们这样引入他：</p>\n<pre class="hljs"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Utils <span class="hljs-keyword">from</span> ‘./utils.js’;\n</code></pre>\n<p>然后，我们开始使用其中的一个函数：</p>\n<pre class="hljs"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Utils <span class="hljs-keyword">from</span> ‘./utils.js’;\n\nUtils.each([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{ <span class="hljs-built_in">console</span>.log(x) });\n</code></pre>\n<p>而，<code>main.js</code>被<em>tree shaking</em>编译之后，是长这样的：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">collection, iterator</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(collection)) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n};\n\neach([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(x)\n});\n</code></pre>\n<p>注意到，只有我们使用的<code>each</code>被引入了，而不是<code>util.js</code>里所有的函数。</p>\n<p>那么，如果我们使用<code>filter</code>函数而不是<code>each</code>的话，我们的<code>main.js</code>:</p>\n<pre class="hljs"><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Utils <span class="hljs-keyword">from</span> ‘./utils.js’;\nUtils.filter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{ <span class="hljs-keyword">return</span> x === <span class="hljs-number">2</span> });\n</code></pre>\n<p>tree shaking 编译后，<code>main.js</code>变成了这样：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">collection, iterator</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(collection)) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; collection.length; i++) {\n      iterator(collection[i], i, collection);\n    }\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> collection) {\n      iterator(collection[key], key, collection);\n    }\n  }\n};\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span>(<span class="hljs-params">collection, test</span>) </span>{\n  <span class="hljs-keyword">var</span> filtered = [];\n  each(collection, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{\n    <span class="hljs-keyword">if</span> (test(item)) {\n      filtered.push(item);\n    }\n  });\n  <span class="hljs-keyword">return</span> filtered;\n};\n\nfilter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{\n  <span class="hljs-keyword">return</span> x === <span class="hljs-number">2</span>\n});\n</code></pre>\n<p>注意到这个时候,<code>each</code>和<code>filter</code>都被引入了，这是因为<code>filter</code>函数是依赖于<code>each</code>的。</p>\n<p>很cool，对不对？</p>\n<p>我建议你通过<em>Rollup.js</em>的 <a href="http://rollupjs.org/">live demo and editor</a> ，去玩玩和了解一下tree shaking。</p>\n<h2 id="es6-modules-2"><a class="header-anchor" href="#es6-modules-2" aria-hidden="true">#</a> 构建ES6 modules</h2>\n<p>好的，现在我们知道了ES6 modules的加载很其他module format是不同的，但是我们还没讲怎么构建ES6 modules。</p>\n<p>不幸的是，ES6 modules 还需要额外的工作，因为浏览器还没有实现原生的ES6 module加载。</p>\n<p>下面有两种方法来构建/转换 ES6 modules，使得在浏览器中可以使用。其中，第一种是当前最常见的：</p>\n<ol>\n<li>使用转换器(比如，Babel或者Traceur)，把你ES6代码转换成CommonJS，AMD或者UMD格式的ES5代码。然后把转换好的代码送到一个module bundler里去，比如Browserify或者Webpack，这样就创建了一个或多个打包好的文件。</li>\n<li>使用<a href="http://rollupjs.org/">Rollup.js</a>：这种方法和前面的很相似，除了在打包之前会使用ES6 module的静态分析。他利用<strong>tree shaking</strong>把最少的代码量打包。总体来说，Rollup.js比Webpack或者Browserify最大的好处是，当你使用ES6 module时，可以使你的代码的体积更小。需要注意的是，Rollup提供了多种格式来打包你的代码，包括ES6，CommonJS，AMD，CMD，UMD或者IIFE。IIFE和UMD可以适用于你的浏览器，但如果你选择了AMD，CommonJS或者ES6的话，你需要找其他方法把你的代码转成浏览器可以识别的，比如使用Browserify，Webpack，RequireJS等等。</li>\n</ol>\n<h2 id="jumping-through-hoops"><a class="header-anchor" href="#jumping-through-hoops" aria-hidden="true">#</a> Jumping through hoops</h2>\n<p>作为web开发者，我们需要跳过这些繁文缛节。因为把ES6 modules代码转换成浏览器可以解释的ES5不是一件易事。</p>\n<p>问题就是：我们可以直接在浏览器使用ES6 module，且不用弄上面说到的两种方法吗？</p>\n<p>答案是：很快。</p>\n<p>ECMAScript现在已经有解决方案的规范了，叫做<a href="https://github.com/ModuleLoader/es6-module-loader">ECMAScript 6 module loader API</a>。简单介绍，他是一种可编程的，基于Promise的API，可以动态加载你的modules，并且cache他们，使得随后的<code>import</code>不需要加载另外一份新版本的module。</p>\n<p>他大概是这样子的：</p>\n<pre class="hljs"><code><span class="hljs-comment">// myModule.js</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myModule</span> </span>{\n  <span class="hljs-keyword">constructor</span>() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Hello, I am a module\'</span>);\n  }\n  hello() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'hello!\'</span>);\n  }\n  goodbye() {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'goodbye!\'</span>);\n  }\n}\n</code></pre>\n<pre class="hljs"><code><span class="hljs-comment">// main.js</span>\n\nSystem.import(‘myModule’).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">myModule</span>) </span>{\n  <span class="hljs-keyword">new</span> myModule.hello();\n});\n<span class="hljs-comment">// ‘hello!’</span>\n</code></pre>\n<p>另外一种方法是，你可以直接在<code>script</code>标签里，直接注明<code>type=module</code>来定义modules。</p>\n<pre class="hljs"><code>&lt; script type = <span class="hljs-string">"module"</span> &gt;\n  <span class="hljs-comment">// loads the \'myModule\' export from \'mymodule.js\'</span>\n  <span class="hljs-keyword">import</span> {\n    hello\n  } <span class="hljs-keyword">from</span> <span class="hljs-string">\'mymodule\'</span>;\n<span class="hljs-keyword">new</span> Hello(); <span class="hljs-comment">// \'Hello, I am a module!\'</span>\n&lt; <span class="hljs-regexp">/script&gt;\n</span></code></pre>\n<p>如果你还没有看过module loader API的polyfill，我强烈建议你至少去<a href="https://github.com/ModuleLoader/es6-module-loader">看一看</a>。</p>\n<p>如果你想要测试一下这种方法的话，你可以试试<a href="https://github.com/systemjs/systemjs">SystemJS</a>。他是基于<a href="https://github.com/ModuleLoader/es6-module-loader">ES6 Module Loader polyfill</a>创建的。他可以在浏览器和Node环境中，动态地加载任何格式的modules(ES6 modules，AMD，CommonJS以及全局的scripts)。他会跟踪所有已经加载到「module registry」的modules，避免了重新加载已经加载过的modules。值得提醒的是，他也可以自动地转换ES6 modules(如果你开启这个option的话)，还可以从任何一种模块格式中加载任何一种格式的模块。太棒了。</p>\n<h2 id="es6-modulesbundlers"><a class="header-anchor" href="#es6-modulesbundlers" aria-hidden="true">#</a> 既然我们已经有了ES6 modules，还需要bundlers吗？</h2>\n<p>ES6 modules的逐渐流行，产生了一些有趣的问题：</p>\n<h3 id="http2module-bundlers"><a class="header-anchor" href="#http2module-bundlers" aria-hidden="true">#</a> HTTP/2会使module bundlers过时吗？</h3>\n<p>对于HTTP/1，我们的每个TCP连接只允许一个请求。这就是为什么加载多个资源需要多个请求。有了HTTP/2，一切都变了。HTTP/2是<em>fully multiplexed</em>，这就意味着多个请求和多个响应可以并行。这样一来，我们可以在一个TCP连接中，进行多个请求。</p>\n<p>既然每个HTTP/2请求的开销已经比HTTP/1小得多，那么长远来看，加载一堆的modules并不会降低很多的性能。于是有些人就认为，module bundling已经不需要了。这其实是有可能的，但是我们还要视情况而定。</p>\n<p>比如说，module bundling提供了HTTP/2没有提供的优点，像移除掉不需要的<code>exports</code>从而减少空间。如果你搭建的网页是每个微小的<code>bit</code>都会影响性能的话，那么bundling就给了你巨大的好处。另一方面，如果你对性能要求不是很高的话，你可以跳过构建过程，从而节省了一些时间。</p>\n<p>总起来说，我们现在离享受HTTP/2带来的好处还很远。我个人猜测build process还会持续一段时间。</p>\n<h3 id="commonjsamdumd"><a class="header-anchor" href="#commonjsamdumd" aria-hidden="true">#</a> CommonJS，AMD和UMD还过时吗？</h3>\n<p>一旦ES6变成了标准，那么我们真的还需要非原生的module feature吗？</p>\n<p>我表示怀疑。</p>\n<p>如果只遵循单一的语法去加载和引入module，并且不需要中间步骤，这对于web开发者来说很棒的。但到达这一步还需要多久呢？</p>\n<p>机会是有的，但需要一段时间。</p>\n<p>并且，每个人都可以根据自己的口味去选择，因此「one truthful approach」并不会成为现实。</p>\n<h2 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 结论</h2>\n<p>当开发者讨论modules和module bundling的时候，我希望这两篇文章可以帮助他们厘清这些术语。如果你有疑问的话，你回头看看<a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.y8hs0nsne">part I</a> 。</p>\n<p>同样地，可以在评论中和我讨论，同时随时欢迎你提问题。</p>\n<p>Happy bundling :)</p>\n<p><strong>(原文：<a href="https://medium.freecodecamp.com/javascript-modules-part-2-module-bundling-5020383cf306#.m5o3ar7dt">JavaScript Modules Part 2: Module Bundling</a>)</strong></p>\n',
frontmatter:"title: '「译」JavaScript Modules Part2: Module Bundling'\nauthor: Drake Leung\ntags: []\ncategories: [翻译]\ndate: 2016-02-08 15:57:07\nforeword: JavaScript 模块化 Part2 - 主要讲述 module bundling。"}},function(s,a){s.exports={attributes:{title:"「译」Learning React Without Using React Part 1",author:"Drake Leung",tags:[],categories:[],date:"2016-03-20T13:05:34.000Z",foreword:"用 React 的组件化，单向数据流的思路，来改进一个 jQuery 实现的 todo。"},body:'<p><em>原文链接：<a href="https://medium.com/javascript-inside/learn-the-concepts-part-1-418952d968cb#.femmquo5d">Learning React Without Using React Part 1</a></em></p>\n<p>当我们谈起 React 的时候总是有很多疑惑。下面简单地介绍了 React 以及他的一些底层原理。</p>\n<p>当你完成 Part1 和 Part2 之后，你会学到什么呢？你也许就会知道你为什么需要 React 以及 Redux 类似的 state container （状态管理器）。</p>\n<p>然而，<strong>你并不需要学习</strong>: JSX，ES6/ES*，Webpack，Hot Reloading，也不需要理解 Virtual DOM，甚至不需要 React 本身。</p>\n<p>那么，我们首先要做的是：</p>\n<p>阅读 <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/jquery/js/app.js">Jquery 实现的 TodoMVC</a> 的代码。</p>\n<p>也许你会注意到有一个叫 <code>render</code> 的方法，他会在某个事件触发或者数据更新的时候被调用。现在，我们从头来实现一个例子：当 <code>input</code> 的值改变时，调用 <code>render</code> 函数，并且更新 DOM 元素。（<a href="http://plnkr.co/edit/fjQbQwZpQlhd5wXoc9J8?p=preview">点击这里可查看完整的代码</a>）</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> state = {<span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>}\n\n$(<span class="hljs-string">\'#input\'</span>).on(<span class="hljs-string">\'keyup\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  state.value = $(<span class="hljs-keyword">this</span>).val().trim()\n  render()\n})\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params"></span>) </span>{\n  $(<span class="hljs-string">\'#output\'</span>).html(state.value)\n}\n\nrender()\n</code></pre>\n<p>我们使用一个全局变量 <code>state</code> 来同步所有的东西。也就是说，当 <em>input</em> 的值改变时会更新两样东西：</p>\n<ol>\n<li>更新整个应用的 <code>state</code></li>\n<li>更新 DOM（根据应用当前的 <code>state</code> 来调用 <code>render</code> 函数）</li>\n</ol>\n<p>先记住这些，我们等一下就会返回来。</p>\n<p>现在，我们有了一个新想法：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">output</span>(<span class="hljs-params">text</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-string">\'&lt;div&gt;\'</span> + text + <span class="hljs-string">\'&lt;/div&gt;\'</span>\n}\n</code></pre>\n<p>显然，调用 <code>output(foo)</code> 就会返回 <code>\'&lt;div&gt;foo&lt;/div&gt;\'</code>。</p>\n<p>那么接下来：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">h2</span> (<span class="hljs-params">text</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-string">\'&lt;h2&gt;\'</span> + text + <span class="hljs-string">\'&lt;/h2&gt;\'</span>\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">div</span> (<span class="hljs-params">text</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-string">\'&lt;div&gt;\'</span> + text + <span class="hljs-string">\'&lt;/div&gt;\'</span>\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">header</span> (<span class="hljs-params">text</span>) </span>{\n  <span class="hljs-keyword">return</span> div(h2(text))\n}\n\n<span class="hljs-built_in">console</span>.log(header(<span class="hljs-string">\'foo\'</span>) === <span class="hljs-string">\'&lt;div&gt;&lt;h2&gt;foo&lt;/h2&gt;&lt;/div&gt;\'</span>) <span class="hljs-comment">// true</span>\n</code></pre>\n<p>上面的函数都是基于一个 <em>text(input)</em> 然后返回一个 <em>string(text)</em> 。调用 <code>header</code> 的时候传入相同的参数（<em>input</em>），都会得到相同的字符串（<em>output</em>）。如果你在想思考 React 中的 <strong>stateless functions</strong> 的话，那么这个其实就是一个简化版。只是 Stateless functions 会返回一个 React Element 而不是一个简单的 string ，但是思路是一样的。</p>\n<p>既然这样，我们就把这个想法应用到我们之前的例子中。我们添加了一个 <code>button</code>，用来添加 todo item 。</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> state = {<span class="hljs-attr">items</span>: [], <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>}\n\n$(<span class="hljs-string">\'#add\'</span>).on(<span class="hljs-string">\'click\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{\n  <span class="hljs-keyword">var</span> value = $(<span class="hljs-string">\'#input\'</span>).val().trim()\n  $(<span class="hljs-string">\'#input\'</span>).val(<span class="hljs-string">\'\'</span>)\n\n  state.items.push({\n    <span class="hljs-attr">id</span>: state.id++,\n    <span class="hljs-attr">text</span>: value,\n    <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>\n  })\n\n  render()\n})\n\n$(<span class="hljs-string">\'#list\'</span>).on(<span class="hljs-string">\'click\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> toggleId = <span class="hljs-built_in">parseInt</span>($(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">\'id\'</span>))\n\n  state.items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{\n    el.id === toggleId &amp;&amp; (el.completed = !el.completed)\n  })\n\n  render()\n})\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> items = state.items.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{\n    <span class="hljs-keyword">var</span> completed = item.completed ? <span class="hljs-string">\'completed\'</span> : <span class="hljs-string">\'\'</span>\n\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'&lt;li class="item + \'</span> + completed + <span class="hljs-string">\'" id="\'</span> + item.id + <span class="hljs-string">\'"&gt;(\'</span> +\n      item.id + <span class="hljs-string">\') \'</span> + item.text + <span class="hljs-string">\'&lt;/li&gt;\'</span>\n  }).join(<span class="hljs-string">\'\'</span>)\n\n  <span class="hljs-keyword">var</span> html = <span class="hljs-string">\'&lt;ul&gt;\'</span> + items = <span class="hljs-string">\'&lt;/ul&gt;\'</span>\n\n  $(<span class="hljs-string">\'#list\'</span>).html(html)\n}\n\nrender()\n</code></pre>\n<p>效果图如下。我们的应用现在可以显示所有的 todo，也可以改变每个 todo 的状态（进行中或者完成）。</p>\n<p><img src="https://cdn-images-1.medium.com/max/800/1*ouOYh6bI3q_8y1XLCoVD-A.png" alt="simple todo lsit"></p>\n<p>在上面，我们定义了两个 <code>click</code> 事件，当他们触发时就会更新我们的 <code>state</code> 以及调用 <code>render</code> 函数。而 <code>render</code> 函数会创建一个 todo list 。 <code>state</code> 作为中间媒介，简化了事件和 DOM 元素之间的交互，而不是** 通过事件来直接操作 DOM ** （不需要定义每个 DOM 元素和每个事件以及他们之间的关系）。当某个 <em>action</em>（如 click 事件） 触发之后，<code>state</code> 就会更新，接着调用 <code>render</code> 函数，最后我们的应用就会更新。这样一来，就简化了好多复杂的交互。</p>\n<p>上面的例子是很好的，我们不妨再来重构他。</p>\n<p>可以看到，<code>render</code> 函数有一点乱。我们不妨创建一个函数，他接收一个参数（input），然后基于这个参数返回一个字符串（output）。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ItemRow</span> (<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">var</span> className = props.completed ? <span class="hljs-string">\' item completed\'</span> : <span class="hljs-string">\'item\'</span>\n  <span class="hljs-keyword">return</span> <span class="hljs-string">\'&lt;li className="\'</span> + className +<span class="hljs-string">\' "&gt;\'</span> + props.text + <span class="hljs-string">\'&lt;/li&gt;\'</span>\n}\n</code></pre>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ItemsList</span> (<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-string">\'&lt;ul&gt;\'</span> + props.items.map(ItemRow).join(<span class="hljs-string">\'\'</span>) + <span class="hljs-string">\'&lt;/ul&gt;\'</span>\n}\n</code></pre>\n<p>看，现在我们的 <code>render</code> 函数优美多了：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params"></span>) </span>{\n  $(<span class="hljs-string">\'#list\'</span>).html(ItemsList({\n    <span class="hljs-attr">items</span>: state.items\n  }))\n}\n</code></pre>\n<p>如果 <code>render</code> 函数并不知道 <code>state</code> 是什么，而是期望一个 <em>input</em> 作为参数呢？好吧，现在我们可以重构一下 <code>render</code> 函数，他期望接收一个 <code>props</code> 对象（这其实就是 React Component 所期望的。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params">props</span>) </span>{\n  $(<span class="hljs-string">\'#list\'</span>).html(ItemsList({\n    <span class="hljs-attr">items</span>: props.items\n  }))\n}\n</code></pre>\n<p>现在，<code>render</code> 函数并不依赖外部的状态（state），这使得我们在调用 <code>render</code> 时可以随便传入一个 <em>input</em> ，也就意味着我们的应用重新渲染时，相同的 <em>input</em> 会有相同的 <em>output</em> 。需要注意的是，DOM 操作其实是一个 side effect，但是现在我们暂时忽略他。</p>\n<p>把 <code>state</code> 从 <code>render</code> 函数中分离出来，可以使得我们很容易实现 <code>Undo/Redo</code>。这也意味着每当 * 当前的 state * 改变时，我们能够创建一个 history ，保存这个当前的 state 。</p>\n<p>另外一个优化就是传一个 root node 作为参数，而不是写死在 <code>render</code> 函数里面：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params">props, node</span>) </span>{\n  node.html(ItemsList({\n    <span class="hljs-attr">items</span>: props.items\n  }))\n}\n</code></pre>\n<p>因此，我们可以这样调用 <code>render</code> 函数：</p>\n<pre class="hljs"><code>render(state, $(<span class="hljs-string">\'#list\'</span>))\n</code></pre>\n<p>我们会很容易想到：当 <code>state</code> 改变的时候，能不能自动地更新应用？也就是，不用手动地调用 <code>render</code> 函数。</p>\n<p>现在，我们来创建一个 <em>store</em> ，他的作用是当 <code>state</code> 改变之后，就立马调用 <code>render</code> 函数。下面的实现虽然简单，但也是一个 advanced state container 的雏形。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span> (<span class="hljs-params">initialState</span>) </span>{\n  <span class="hljs-keyword">var</span> _state = initialState || {},\n    _listeners = []\n\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateListeners</span> (<span class="hljs-params">state</span>) </span>{\n    _listeners.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">listener</span>) </span>{\n      listener.cb(state)\n    })\n  }\n\n  <span class="hljs-keyword">return</span> {\n    <span class="hljs-attr">setState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{\n      _state = state\n      updateListeners(state)\n    },\n\n    <span class="hljs-attr">getState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">return</span> _state\n    },\n\n    <span class="hljs-attr">onUpdate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, cb</span>) </span>{\n      _listeners.push({<span class="hljs-attr">name</span>: name, <span class="hljs-attr">cb</span>: cb})\n    }\n  }\n}\n</code></pre>\n<p>现在，我们更新 <code>state</code> 只需要简单地调用 <code>setState</code> 方法。只要 <code>state</code> 一改变，我们的 <code>render</code> 函数就会被调用：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> store = createStore(store)\n\nstore.onUpdate(<span class="hljs-string">\'rootRender\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{\n  render(state, $(<span class="hljs-string">\'#list\'</span>))\n})\n</code></pre>\n<p><a href="http://plnkr.co/edit/fjQbQwZpQlhd5wXoc9J8?p=preview">点击这里可查看完整的代码</a></p>\n<p>** 现在我们学会了什么？ ** 我们知道了简单的单向数据流（one-way data flow）的原则。我们给 <code>render</code> 函数传了一个 <code>state</code> 参数，然后 <code>state</code> 就会像流水一样，流到 <code>render</code> 函数的每个层次中。比如，<code>ItemRow</code> 函数需要 <code>ItemsList</code> 给他传进正确的参数。</p>\n<p>我们已经创建了多个组件（component），并且我们把这些组件组合（compose）在一起。回想一下前面的 <code>header</code> 例子，我们把 <code>div</code> 和 <code>h2</code> 函数组合成了一个 <code>header</code> 函数。并且，这些函数都是 <em>pure function</em> ，这使得所有更新都是可预测的。</p>\n<p>并且，我们使用了 <em>store</em> 来管理我们的 <code>state</code>。</p>\n<p>而，React 会用更好更优美的方法来实现上面这些东西。组件（组合），使用 Virtual DOM 优化渲染，单向数据流等等。</p>\n<blockquote>\n<p>…we can focus on examining React’s true strengths: composition, unidirectional data flow, freedom from DSLs, explicit mutation and static mental model.</p>\n</blockquote>\n<p>From <a href="https://medium.com/@dan_abramov/youre-missing-the-point-of-react-a20e34a51e1a">Dan Abramov - you\'re missing the point of react</a></p>\n<p>我们可以优化的东西还有很多，比如继续优化 state container，重构我们的 listeners，实现 undo/redo，以及更多更好的 feature。<strong>这些东西我们都会在 Part 2 呈现</strong>。</p>\n<p><em>原文链接：<a href="https://medium.com/javascript-inside/learn-the-concepts-part-1-418952d968cb#.femmquo5d">Learning React Without Using React Part 1</a></em></p>\n',frontmatter:"title: 「译」Learning React Without Using React Part 1\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-03-20 13:05:34\nforeword: 用 React 的组件化，单向数据流的思路，来改进一个 jQuery 实现的 todo。"}},function(s,a){s.exports={attributes:{title:"「译」Learning React Without Using React Part2",author:"Drake Leung",tags:[],categories:[],date:"2016-03-22T16:12:22.000Z",foreword:"用 React 的组件化，单向数据流的思路，来改进一个 jQuery 实现的 todo。"},body:'<p><em><a href="https://medium.com/javascript-inside/learning-react-without-using-react-part-2-703621a89432#.guh60nwi7">原文链接</a></em></p>\n<p>请阅读 <a href="http://drakeleung.github.io/blog/2016/03/20/Learning-React-Without-Using-React-Part-1/">Part 1</a> 如果你还没有的话。</p>\n<p>让我们继续 Part1 没讲到的东西。<br>\n我们这两篇文章主要是专注于如何重构我们的 todo list。现在，我们的实现包含了可以渲染整个应用的函数（组合），还有管理我们状态（state）的 <em>store</em>。然而，我们还有很多方法去优化我们的应用。<a href="http://plnkr.co/edit/fjQbQwZpQlhd5wXoc9J8?p=preview">完整代码请查看这里</a>。</p>\n<p>首先，我们还没有正确地处理事件。现在，我们的组件根本就没有绑定任何事件。在 React 里面，数据流是从上往下，而事件流则是从下往上（In React data flows down while events move up）。也就是说，当事件触发的时候，我们应该沿着组件链，从下往上找其对应的回调函数。比如，我们的 <code>ItemRow</code> 函数应该调用一个从 <code>props</code> 传递下来的函数。</p>\n<p>那么，我们怎么实现呢？下面是一个小尝试：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ItemRow</span> (<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">var</span> className = props.completed ? <span class="hljs-string">\'item completed\'</span> : <span class="hljs-string">\'item\'</span>\n\n  <span class="hljs-keyword">return</span> $(<span class="hljs-string">\'&lt;li&gt;\'</span>)\n    .on(<span class="hljs-string">\'click\'</span>, props.onUpdate.bind(<span class="hljs-literal">null</span>, props.id))\n    .addClass(className)\n    .attr(<span class="hljs-string">\'id\'</span>, props.id)\n    .html(props.text)\n}\n</code></pre>\n<p>在上面，我们给 <code>list</code> 元素绑定了一个事件。当点击他们的时候，<code>onUpdate</code> 函数就会被调用。</p>\n<p>现在，我们不妨定义一个函数，他可以在创建元素的时候同时为其绑定事件。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span> (<span class="hljs-params">tag, attrs, children</span>) </span>{\n  <span class="hljs-keyword">var</span> elem = $(<span class="hljs-string">\'&lt;\'</span>, + tag + <span class="hljs-string">\'&gt;\'</span>)\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> attrs) {\n    <span class="hljs-keyword">var</span> val = attrs[key]\n\n    <span class="hljs-keyword">if</span> (key.indexOf(<span class="hljs-string">\'on\'</span>) === <span class="hljs-number">0</span>) {\n      <span class="hljs-keyword">var</span> event = key.substr(<span class="hljs-number">2</span>).toLowerCase()\n      elem.on(event, val)\n    } <span class="hljs-keyword">else</span> {\n      elem.attr(key, val)\n    }\n  }\n\n  <span class="hljs-keyword">return</span> elem.html(children)\n}\n</code></pre>\n<p>这样一来，我们的 <code>ItemRow</code> 函数可以写成这样：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ItemRow</span> (<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">var</span> className = props.completed ? <span class="hljs-string">\'item completed\'</span> : <span class="hljs-string">\'item\'</span>\n\n  <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">\'li\'</span>, {\n    <span class="hljs-attr">id</span>: props.id,\n    <span class="hljs-attr">class</span>: props.className,\n    <span class="hljs-attr">onClick</span>: props.onUpdate.bind(<span class="hljs-literal">null</span>, props.id)\n  }, props.text)\n}\n</code></pre>\n<p>需要注意的是 React 中的 <code>createElement</code> 函数是创建了一个 JavaScript 对象来表示 DOM 元素。还有一点，让我们来看看 React 中的 JSX 语法到底是怎样子的。</p>\n<p>下面就是一个 JSX 例子：</p>\n<pre class="hljs"><code><span class="hljs-keyword">return</span> ( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">\'el\'</span> <span class="hljs-attr">className</span>=<span class="hljs-string">\'entry\'</span>&gt;</span> Hello <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)\n</code></pre>\n<p>接着会转换成：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> SomeElement = React.createElement(<span class="hljs-string">\'div\'</span>, {\n  <span class="hljs-attr">id</span>: <span class="hljs-string">\'el\'</span>,\n  <span class="hljs-attr">className</span>: <span class="hljs-string">\'entry\'</span>\n}, <span class="hljs-string">\'Hello\'</span>)\n</code></pre>\n<p>然后调用 <code>SomeElement</code> 函数会返回一个像下面差不多的 JavaScript 对象：</p>\n<pre class="hljs"><code>{\n  <span class="hljs-comment">// ...</span>\n  type: <span class="hljs-string">\'div\'</span>,\n  <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span>,\n  <span class="hljs-attr">ref</span>: <span class="hljs-literal">null</span>,\n  <span class="hljs-attr">props</span>: {\n    <span class="hljs-attr">children</span>: <span class="hljs-string">\'Hello\'</span>,\n    <span class="hljs-attr">className</span>: <span class="hljs-string">\'entry\'</span>,\n    <span class="hljs-attr">id</span>: <span class="hljs-string">\'el\'</span>\n  }\n}\n</code></pre>\n<p>想要了解更多的话，请阅读 <a href="https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca#.x2b1qra2o">React Components, Elements, and Instances</a></p>\n<p>回到我们的例子中，<code>onUpdate</code> 函数是从哪里来的？</p>\n<p>现在来看看我们的 <code>render</code> 函数。他定义了一个 <code>updateState</code> 函数，然后通过 <code>props</code> 把这个函数传给 <code>ItemList</code> 组件。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params">props, node</span>) </span>{\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateState</span> (<span class="hljs-params">toggleId</span>) </span>{\n    state.items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{\n      <span class="hljs-keyword">if</span> (el.id === toggleId) {\n        el.completed = !el.completed\n      }\n    })\n    store.setState(state)\n  }\n\n  node.empty().append([ItemList({\n    <span class="hljs-attr">items</span>: props.items,\n    <span class="hljs-attr">onUpdate</span>: updateState\n  })])\n}\n</code></pre>\n<p>然后，<code>ItemList</code> 函数会把 <code>onUpdate</code> 传到每个 <code>ItemRow</code> 。</p>\n<pre class="hljs"><code>functions extending(base, item) {\n  <span class="hljs-keyword">return</span> $.extend({}, item, base)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ItemsList</span> (<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">\'ul\'</span>, {}, props.items\n    .map(extending.bind(<span class="hljs-literal">null</span>, {<span class="hljs-attr">onUpdate</span>: props.onUpdate}))\n  )\n    .map(ItemRow)\n}\n</code></pre>\n<p>通过以上我们实现了：数据流是从下往下的，而事件流是从下往上。这就意味着我们可以把定义在全局的监听器移除掉（用来监听点击 item 的时候，改变他的状态）。我们把这个函数移到了 <code>render</code> 函数里面，也就是前面所讲的 <code>updateState</code>。</p>\n<p>** 我们还可以重构。 **</p>\n<p>现在我们把 <code>input</code> 和 <code>button</code> 从 HTML 标签变成函数。因此，我们整个 HTML 文件就只剩下一个 <code>div</code> 。</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span>\n</code></pre>\n<p>我们的 <code>input</code> 元素很容易创建，就这样：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> input = createElement(<span class="hljs-string">\'input\'</span>, {<span class="hljs-attr">id</span>: <span class="hljs-string">\'input\'</span>})\n</code></pre>\n<p>同样地，我们也可以把监听搜索框按钮点击的全局函数放在我们的 <code>SearchBar</code> 函数里面。<code>SearchBar</code> 函数会返回一个 <code>input</code> 和一个 <code>button</code> 元素，他会通过 <code>props</code> 传进来的回调函数来处理点击事件。</p>\n<pre class="hljs"><code>functions SearchBar(props) {\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onButtonClick</span> (<span class="hljs-params">e</span>) </span>{\n    <span class="hljs-keyword">var</span> val = $(<span class="hljs-string">\'#input\'</span>).val()\n    $(<span class="hljs-string">\'#input\'</span>).val(<span class="hljs-string">\'\'</span>)\n    props.update(val)\n    e.preventDefault()\n  }\n\n  <span class="hljs-keyword">var</span> input = createElement(<span class="hljs-string">\'input\'</span>, {<span class="hljs-attr">id</span>: <span class="hljs-string">\'input\'</span>})\n  <span class="hljs-keyword">var</span> button = createElement(<span class="hljs-string">\'button\'</span>, {\n    <span class="hljs-attr">id</span>: <span class="hljs-string">\'add\'</span>,\n    <span class="hljs-attr">onClick</span>: onButtonClick.bind(<span class="hljs-literal">null</span>)\n  }, <span class="hljs-string">\'Add\'</span>)\n\n  <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">\'div\'</span>, {}, {input, button})\n}\n</code></pre>\n<p>我们的 <code>render</code> 函数调用 <code>SearchBar</code> 的同时传递正确的 <code>props</code> 参数。在我们更新 <code>update</code> 函数之前，让我们想想 <em>re-render</em> 应该在哪里调用才是正确的。首先，忽略我们的 <code>store</code>，把注意力集中在如何在一个 high level component 中处理 <em>state</em>。</p>\n<p>目前为止，所有的函数都是 <em>stateless</em> 的。接下来我们会创建一个函数，他会处理 <em>state</em> ，以及在适当的时候更新子组件（children）。</p>\n<p><strong>Container Component</strong></p>\n<p>让我们来创建一个 high level container 吧。与此同时，为了更好理解，你可以阅读 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.iy4tfncwt">Presentational and Container Component</a>。</p>\n<p>首先，我们给这个 container component 取名为 <code>App</code>。他所做的事情就是调用 <code>SearchBar</code> 和 <code>ItemList</code> 函数。现在，我们继续重构 <code>render</code> 函数。其实就是把代码移到 <code>App</code> 里面去而已。</p>\n<p>我们不妨先来看看 <code>render</code> 现在是怎样子的：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params">component, node</span>) </span>{\n  node.empty().append(component)\n}\n\nrender(App(state), $(<span class="hljs-string">\'#app\'</span>))\n</code></pre>\n<p>我们的 <code>render</code> 函数只是简单地把整个应用渲染到指定的节点中。但是，React 的实现会比这个复杂一点，而我们仅仅把一棵 element tree 添加到指定的根节点中而已。但是抽象起来理解的话，这个已经足够了。</p>\n<p>现在，我们的 <code>App</code> 函数其实就是我们旧的 <code>render</code> 函数，除了 DOM 操作被删掉。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> (<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSearchBar</span> (<span class="hljs-params">value</span>) </span>{\n    state.items.push({\n      <span class="hljs-attr">id</span>: state.id++,\n      <span class="hljs-attr">text</span>: value,\n      <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span>\n    })\n  }\n\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateState</span> (<span class="hljs-params">toggleId</span>) </span>{\n    state.items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>{\n      <span class="hljs-keyword">if</span> (el.id === toggleId) {\n        el.completed = !el.completed\n      }\n    })\n    store.setState(state)\n  }\n\n  <span class="hljs-keyword">return</span> [\n    SearchBar({<span class="hljs-attr">update</span>: updateSearchBar}),\n    ItemsList({<span class="hljs-attr">items</span>: props.items, <span class="hljs-attr">onUpdate</span>: updateState})\n  ]\n}\n</code></pre>\n<p>我们还需要改进一样东西：我们访问的 <code>store</code> 是全局的，并且重新渲染的话需要调用 <code>setState</code> 函数。</p>\n<p>我们现在来重构 <code>App</code> 函数，使得他的子组件重新渲染的是不需要调用 <code>store</code> 。那么应该要怎么实现呢？</p>\n<p>首先我们要忽略 <code>store</code>，并且想想怎么调用 <code>setState</code> 函数，从而使得组件和他的子组件重新渲染。</p>\n<p>我们需要跟踪这个 high level component 当前的状态，并且只要 <code>setState</code> 一调用，就立马重新渲染。下面是一个简单的实现：</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> (<span class="hljs-params">props</span>) </span>{\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInitialState</span> (<span class="hljs-params">props</span>) </span>{\n    <span class="hljs-keyword">return</span> {\n      <span class="hljs-attr">items</span>: [],\n      <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>\n    }\n  }\n\n  <span class="hljs-keyword">var</span> _state = getInitialState(),\n    _node = <span class="hljs-literal">null</span>\n\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setState</span> (<span class="hljs-params">state</span>) </span>{\n    _state = state\n    render()\n  }\n\n  <span class="hljs-comment">// ..</span>\n}\n</code></pre>\n<p>我们通过调用 <code>getInitialState</code> 来初始化我们的 <code>state</code> ，然后每当使用 <code>setState</code> 来更新状态的时候，我们会调用 <code>render</code> 函数。</p>\n<p>而 <code>render</code> 函数要么创建一个 node，要么简单地更新 node，只要 <code>state</code> 发生改变。</p>\n<pre class="hljs"><code><span class="hljs-comment">// naive implement of render</span>\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">var</span> children = [\n    SearchBar({<span class="hljs-attr">update</span>: updateSearchState}),\n    ItemList({\n      <span class="hljs-attr">items</span>: _state.items,\n      <span class="hljs-attr">onUpdate</span>: updateState\n    })\n  ]\n\n  <span class="hljs-keyword">if</span> (!_node) {\n    <span class="hljs-keyword">return</span> _node = createElement(<span class="hljs-string">\'div\'</span>, {<span class="hljs-attr">class</span>: <span class="hljs-string">\'top\'</span>}, children)\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">return</span> _node.html(children)\n  }\n}\n</code></pre>\n<p>很显然，这对性能来说是不好的。需要知道的是，React 中的 <code>setState</code> 不会渲染整个应用，而是组件和他的子组件。</p>\n<p>下面是 <code>render</code> 函数的最新代码，我们调用 <code>App</code> 时不需要带任何参数，只是需要简单地调用 <code>getInitialState</code>返回初始的状态。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">component, node</span>) </span>{\n  node.empty().append(component);\n}\nrender(App(), $(<span class="hljs-string">\'#app\'</span>));\n</code></pre>\n<p><a href="http://plnkr.co/edit/ISi8AiVuYSfFIfMy9z6t?p=preview">查看的所有的代码请点击这里</a></p>\n<p><strong>继续改进</strong></p>\n<p>如果有一个函数，他会返回一个对象。这个对象包含了 <code>setState</code> 函数，还能够区分传进来 <code>props</code> 和 组件本身自己的 <code>state</code>。</p>\n<p>差不多就像下面这样：</p>\n<pre class="hljs"><code><span class="hljs-keyword">var</span> App = createClass({\n  <span class="hljs-attr">updateSearchState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) </span>{ <span class="hljs-comment">/*...*/</span> },\n\n  <span class="hljs-attr">updateState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{ <span class="hljs-comment">/*... */</span> },\n\n  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> children = [\n      SearchBar({\n        <span class="hljs-attr">updateSearchState</span>: <span class="hljs-keyword">this</span>.updateSearchState\n      }),\n      ItemsList({\n        <span class="hljs-attr">items</span>: <span class="hljs-keyword">this</span>.state.items,\n        <span class="hljs-attr">onUpdate</span>: <span class="hljs-keyword">this</span>.updateState\n      })\n    ]\n\n    <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">\'div\'</span>, {<span class="hljs-attr">class</span>: <span class="hljs-string">\'top\'</span>}, children)\n  }\n})\n</code></pre>\n<p>很幸运的是，在 React 中，你可以通过调用 <code>React.createClass</code> 来创建组件。他提供了很多选择，比如 ES6 Class ，stateless function 等，<a href="https://facebook.github.io/react/docs/reusable-components.html">更多请查看文档</a>。</p>\n<p>综上，我们讲解了数据流如何从上往下，而事件从下往上。我们也看到了如何处理一个组件的状态。关于 React 的东西，还有很多要学习。下面的链接也许可以帮助到你。</p>\n<p><strong>扩展阅读</strong></p>\n<ul>\n<li><a href="https://facebook.github.io/react/docs/thinking-in-react.html">Thnking in React</a></li>\n<li><a href="https://facebook.github.io/react/docs/getting-started.html">Getting Start React</a></li>\n<li><a href="https://medium.com/javascript-scene/jsx-looks-like-an-abomination-1c1ec351a918#.59q26eqe0">JSX</a></li>\n<li><a href="https://github.com/petehunt/react-howto">React How to</a></li>\n<li><a href="http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome">Removing User Interface Complexity, or Why React is Awesome</a></li>\n<li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.kcyewm6ab">Presentational and Container Component</a></li>\n<li><a href="https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca#.xis6z3p1z">React Component, Elements, and Instances</a></li>\n</ul>\n<p><strong>结尾语</strong></p>\n<p>本来打算在这篇文章讲解如何创建一个 <em>advanced state container</em> ，实现 <em>undo/redo</em> 以及更多 feature ，但是我认为已经超出了这篇文章的范围。</p>\n<p>如果大家有兴趣的话，我也许会写 Part 2.1。</p>\n<p><em><a href="https://medium.com/javascript-inside/learning-react-without-using-react-part-2-703621a89432#.guh60nwi7">原文链接</a></em></p>\n',frontmatter:"title: 「译」Learning React Without Using React Part2\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-03-22 16:12:22\nforeword: 用 React 的组件化，单向数据流的思路，来改进一个 jQuery 实现的 todo。"}},function(s,a){s.exports={attributes:{title:"有趣的 Nginx",author:"Drake Leung",
tags:[],categories:[],date:"2016-08-11T00:53:50.000Z",foreword:"如何使用 nginx 来协助前端开发"},body:'<p>由于在开发项目的时候用到了 <code>nginx</code> ，觉得挺不错的，所以了解了一下。</p>\n<p>一个项目的开发环境一般都会分为4个阶段。</p>\n<ul>\n<li>test(local): 本地</li>\n<li>alpha</li>\n<li>beta</li>\n<li>production</li>\n</ul>\n<p>每个环境下，前端的域名是不同的，并且调用后台接口的 <code>url</code> 也是不同的。假设我们的项目名字叫做 <code>toon</code>，并且 root domain 是 <code>lyyourc.com</code>，那么就有：</p>\n<pre class="hljs"><code><span class="hljs-comment"># 前端4个环境下的域名</span>\n-  <span class="hljs-built_in">test</span>: toon.test.lyyourc.net\n- alpha: toon.alpha.lyyourc.net\n-  beta: toon.alpha.lyyourc.net\n-  prod: toon.lyyourc.com\n\n<span class="hljs-comment"># 后台接口</span>\n-  alpha: toon-api.alpha.lyyourc.net\n-   beta: toon-api..beta.lyyourc.net\n-   prod: toon-api.lyyourc.com\n</code></pre>\n<p>那么，在这种情况下，我们应该如何：</p>\n<blockquote>\n<p>不同环境下，前端使用不同的域名，访问对应的后台接口呢？</p>\n</blockquote>\n<p>首先，我们要解决<strong>前端怎么使用域名来访问我们的 web 应用</strong>。</p>\n<p>最简单的办法当然是<strong>改 hosts</strong> 。应该还有其他办法，比如 <a href="https://github.com/typicode/hotel">hotel - get local domain in seconds</a> 。</p>\n<pre class="hljs"><code><span class="hljs-comment"># my project - toon</span>\n127.0.0.1 toon.test.lyyourc.net\n</code></pre>\n<p>接下来，我们需要用到 nginx 作为一个 <strong>proxy server</strong> ，把接收到请求转发到对应的后台接口。</p>\n<p>如果你还没接触过 nginx 的话，现在就是一个好机会啦。打开 <a href="http://nginx.org/en/docs/">nginx 的官网</a>，安装，看 <a href="http://nginx.org/en/docs/beginners_guide.html">Beginner’s Guide</a> 。</p>\n<p>下面，修改我们的 <code>nginx.conf</code>(OSX: <code>/usr/local/etc/nginx/</code>)</p>\n<pre class="hljs"><code>worker_processes  7;\nevents { worker_connections 256; }\n\nhttp {\n  server {\n    <span class="hljs-comment"># 监听 80 端口</span>\n    listen 80; \n    \n    <span class="hljs-comment"># 域名符合：toon.*.lyyourc.net 等</span>\n    server_name ~^toon\\.(.*\\.)?(lyyourc)\\.net$;\n\n    location / {\n      root <span class="hljs-string">"/Users/drake/Projects/demo/fun/nginx"</span>;\n    }\n\n    <span class="hljs-comment"># 只要含有 `/api/` 请求，都转发</span>\n    location /api/ {\n      proxy_pass http://toon-api.alpha.lyyourc.net;\n    }\n  }\n}\n</code></pre>\n<p>然后运行：<code>sudo nginx -s reload</code>，重新读取 nginx 的配置文件。如果失败的话，会有相关的提示信息。比如下面少写了 <code>event</code> 这个指令：</p>\n<pre class="hljs"><code>nginx: [emerg] no <span class="hljs-string">"events"</span> section <span class="hljs-keyword">in</span> configuration\n</code></pre>\n<p>在上面的 <code>nginx.conf</code> 中，我们定义了：</p>\n<blockquote>\n<p>只要请求是来自 80 端口，域名符合，URL中包含了 <code>/api/</code> 的，我们都转发到 <code>http://toon-api.alpha.lyyourc.net</code> ，如果为 <code>/</code> 的话，直接读取 <code>/Users/drake/Projects/demo/fun/nginx</code> 目录下的 <code>index.html</code> 。</p>\n</blockquote>\n<p>然后，我们前端需要做的是：<strong>根据当前的域名，请求对应的后台接口。</strong></p>\n<ul>\n<li>写一个配置文件</li>\n</ul>\n<pre class="hljs"><code><span class="hljs-comment">// host.js</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apiHost = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n  <span class="hljs-keyword">const</span> items = <span class="hljs-built_in">window</span>.location.hostname.split(<span class="hljs-string">\'.\'</span>)\n  <span class="hljs-keyword">const</span> env = items[<span class="hljs-number">1</span>]\n\n  <span class="hljs-keyword">switch</span> (env) {\n    <span class="hljs-keyword">case</span> <span class="hljs-string">\'test\'</span>: <span class="hljs-comment">// 本地开发环境 =&gt; nginx</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'\'</span>\n\n    <span class="hljs-keyword">case</span> <span class="hljs-string">\'alpha\'</span>:\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'//toon-api.alpha.lyyourc.net\'</span>\n\n    <span class="hljs-keyword">case</span> <span class="hljs-string">\'beta\'</span>:\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'//toon-api.beta.lyyourc.net\'</span>\n\n    <span class="hljs-keyword">default</span>:\n      <span class="hljs-keyword">return</span> <span class="hljs-string">\'//toon-api.lyyourc.com\'</span>\n  }\n}\n</code></pre>\n<ul>\n<li>每次请求的时候都带上这个 host :</li>\n</ul>\n<pre class="hljs"><code><span class="hljs-keyword">import</span> { apiHost } <span class="hljs-keyword">from</span> <span class="hljs-string">\'host.js\'</span>\n\nfetch(<span class="hljs-string">`<span class="hljs-subst">${apiHot()}</span>/api/heros/`</span>)\n  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())\n</code></pre>\n<p>这时就有：</p>\n<ul>\n<li>前端域名为 <code>toon.test.lyyourc.net</code> 的时候</li>\n<li><code>apiHost</code> 返回空字符串 <code>\'\'</code></li>\n<li>访问后台接口的 URL 为 <code>toon.test.lyyourc.net/api/xx</code></li>\n<li>在 <code>/etc/hosts</code> 匹配了这个 URL ，转到 <code>127.0.0.1</code></li>\n<li>Nginx 接收，转发到 <code>http://toon-api.alpha.lyyourc.net</code></li>\n</ul>\n<p>为什么不直接在 <code>host.js</code> 里面返回 <code>http://toon-api.alpha.lyyourc.net</code> 呢？原因有2个我认为：1个是浏览器的同源策略而产生的<strong>跨域问题</strong>，另1个是当我们想要测试任何环境下的后台接口，我们只需要改 <code>nginx.conf</code> 里面的 <code>proxy_pass</code> 就好了。</p>\n<p>综上，<strong>不知道是否还有更好的解决办法呢？</strong></p>\n<p>其实 nginx 还可以做很多事情啦。比如一个服务器上轻松地跑多个 App ，还有反代 google ，配置 HTTPS 等等。</p>\n<p>Oh~ My Nginx!!</p>\n',frontmatter:"title: 有趣的 Nginx\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-08-11 00:53:50\nforeword: 如何使用 nginx 来协助前端开发"}},function(s,a){s.exports={attributes:{title:"迷之前端轮子 - 实现 ES2015 Promise",author:"Drake Leung",tags:[],categories:[],date:"2016-02-06T17:59:59.000Z",foreword:"为了更好地学习ES2015的Promise，我们不妨来从零开始实现它。"},body:'<p>(所有代码请查看<a href="https://github.com/DrakeLeung/tiny-promise">GitHub tiny-promise</a>)</p>\n<h2 id="why"><a class="header-anchor" href="#why" aria-hidden="true">#</a> Why</h2>\n<p>在此之前，我一直不明白 <em>promise</em> 的workflow是怎样子的。所以在使用的时候，一直很迷惑。比如，</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-string">\'success\'</span>), <span class="hljs-number">1000</span>)\n})\n\np1.then(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(msg))\n</code></pre>\n<p>对于上面的代码，之前的我只知道<code>resolve</code>的参数<code>success</code>会传给<code>then</code>的<code>msg</code>。但是为什么呢？而且，我更没想过到底是<code>then</code>先执行呢还是<code>resolve</code>先执行？这有什么影响？</p>\n<h2 id="how"><a class="header-anchor" href="#how" aria-hidden="true">#</a> How</h2>\n<p>那么，就让我们从零开始实现一个promise吧。</p>\n<h3 id="promise-constructor"><a class="header-anchor" href="#promise-constructor" aria-hidden="true">#</a> Promise Constructor</h3>\n<p>根据<a href="http://devdocs.io/javascript/global_objects/promise">docs</a>，<code>Promise</code>这个构造函数只接受一个参数，且这个参数是一个<code>function</code>。他有2个参数，分别是<code>resolve</code>和<code>reject</code>。<br>\n我们要在构造函数里面执行<code>executor</code>函数，并且传2个参数给他。</p>\n<p>并且，我们构造函数还有一些property，比如他的状态，数据等</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TinyPromise</span> (<span class="hljs-params">executor</span>) </span>{\n  <span class="hljs-keyword">this</span>.state = promiseState.PENDING\n  <span class="hljs-keyword">this</span>.msg = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>\n  <span class="hljs-keyword">this</span>.chains = [] <span class="hljs-comment">// 在`then()`时再讲</span>\n\n  executor(resolve, reject)\n}\n</code></pre>\n<p>接着，定义<code>resolve</code>和<code>reject</code>这2个传给<code>executor</code>的参数</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{\n  <span class="hljs-keyword">let</span> self = <span class="hljs-keyword">this</span>\n\n  <span class="hljs-keyword">if</span> (self.state !== promiseState.FULLFILLED) { <span class="hljs-comment">// #0</span>\n    self.state = promiseState.FULLFILLED\n    self.msg = value\n  }\n\n  notify(self) <span class="hljs-comment">// 下面再讲</span>\n}\n</code></pre>\n<p><code>#0</code>为什么要加上<code>if</code>判断呢？因为有可能<code>resolve</code>并不是异步执行的，所以在调用<code>then()</code>的时候，promise的状态已经为<code>fullfilled</code>了，所以这个时候<code>value</code>是<code>undefined</code>的。你可以自己试试。</p>\n<p>到底<code>chains</code>是什么呢？</p>\n<h3 id="then"><a class="header-anchor" href="#then" aria-hidden="true">#</a> Then</h3>\n<p>当调用<code>then</code>的时候，他会返回一个promise。重复之，便形成了链(chain)。因此，我们每次都把这个promise放进<code>this.chains</code>里面。</p>\n<pre class="hljs"><code><span class="hljs-keyword">this</span>[<span class="hljs-string">\'then\'</span>] = <span class="hljs-function">(<span class="hljs-params">onFullfilled, onRejected</span>) =&gt;</span> {\n  <span class="hljs-keyword">let</span> o = {\n    onFullfilled,\n    onRejected\n  }\n\n  o.promise = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    o = <span class="hljs-built_in">Object</span>.assign(o, {resolve, reject})\n  })\n\n  <span class="hljs-keyword">this</span>.chains = [...this.chains, o]\n\n  <span class="hljs-comment">// doesn\'t call resolve or reject in executor async-ly</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === promiseState.FULLFILLED) <span class="hljs-comment">// #0</span>\n    resolve.call(<span class="hljs-keyword">this</span>)\n  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === promiseState.REJECTED)\n    reject.call(<span class="hljs-keyword">this</span>)\n\n  <span class="hljs-keyword">return</span> o.promise\n}\n</code></pre>\n<p>在<code>#0</code>，我们为什么需要做这个判断呢？因为在调用<code>then</code>时，promise的状态已经不是<code>pending</code>了。为什么？看看文本前面的<em>Why</em>部分。</p>\n<p>注意到，我们把<code>then</code>的2个参数，以及<code>executor</code>的2个参数都放进了<code>this.chains</code>里面。</p>\n<h3 id="notify"><a class="header-anchor" href="#notify" aria-hidden="true">#</a> Notify</h3>\n<p><code>notify</code>函数的作用就是把<code>then</code>返回的结果传递到下一个<code>then</code>里面去。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> handleFullfill = <span class="hljs-function">(<span class="hljs-params">chain, self</span>) =&gt;</span> {\n  <span class="hljs-comment">// 上一个then()的success handler的返回值</span>\n  <span class="hljs-keyword">const</span> result = chain.onFullfilled(self.msg)\n  <span class="hljs-comment">// 传给下一个then()</span>\n  chain.resolve(result)\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> notify = <span class="hljs-function"><span class="hljs-params">self</span> =&gt;</span> {\n  self.chains.forEach(<span class="hljs-function"><span class="hljs-params">chain</span> =&gt;</span> {\n    <span class="hljs-keyword">switch</span> (self.state) {\n      <span class="hljs-keyword">case</span> promiseState.FULLFILLED:\n        handleFullfill(chain, self)\n        <span class="hljs-keyword">break</span>\n\n      <span class="hljs-keyword">case</span> promiseState.REJECTED:\n        handleReject(chain, self)\n        <span class="hljs-keyword">break</span>\n    }\n  })\n}\n</code></pre>\n<h3 id="promiseresolve"><a class="header-anchor" href="#promiseresolve" aria-hidden="true">#</a> Promise.resolve</h3>\n<p>这个方法<code>resolve</code>其实就是<code>Promise</code>构造函数的一个property。</p>\n<pre class="hljs"><code>defineProp(TinyPromise, <span class="hljs-string">\'resolve\'</span>, msg =&gt;\n  <span class="hljs-keyword">new</span> TinyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    resolve(msg)\n  })\n)\n\n<span class="hljs-keyword">const</span> defineProp = (\n  obj = {},\n  prop,\n  value\n) =&gt; {\n  <span class="hljs-keyword">try</span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.defineProperties(obj, prop, {\n      value,\n      <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,\n      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,\n      <span class="hljs-attr">enumerate</span>: <span class="hljs-literal">true</span>\n    })\n  } <span class="hljs-keyword">catch</span> (e) {\n    obj[prop] = value\n    <span class="hljs-keyword">return</span> obj\n  }\n}\n</code></pre>\n<h2 id="wrap-up"><a class="header-anchor" href="#wrap-up" aria-hidden="true">#</a> Wrap up</h2>\n<p>实现完以上，你就可以解决本文前面部分<em>Why</em>的问题了。</p>\n<p><code>then</code>首先会执行，因为<code>resolve</code>是异步的(<code>setTimeout</code>里面)。这时，我们把<code>then</code>的参数放在一个对象数组里面。等到<code>resolve</code>调用的时候，我们再去遍历这个数组，调用<code>then</code>的参数，并且把返回值传给下一个promise。</p>\n<p>如果<code>resolve</code>不是异步的话，那么<code>resolve</code>比<code>then</code>先执行。在<code>then</code>执行的时候，状态已经为<code>fullfilled</code>了。因此只需要直接调用<code>notify</code>函数。</p>\n<p>Cool~</p>\n',frontmatter:"title: 迷之前端轮子 - 实现 ES2015 Promise\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-02-06 17:59:59\nforeword: 为了更好地学习ES2015的Promise，我们不妨来从零开始实现它。"}},function(s,a){s.exports={attributes:{title:"迷之前端轮子 - 实现一个简单的 Virtual DOM",author:"Drake Leung",tags:[],categories:[],date:"2016-01-31T13:30:49.000Z",foreword:"然而我并没有实现React Diff算法，因为不会= ="},body:'<p>最近实现了一个简单版的<a href="https://github.com/DrakeLeung/little-virtual-DOM">Virtual DOM</a>。<br>\n之所以简单，是因为并没有实现React的diff算法，不过我们还是可以了解一下Virtual DOM。</p>\n<h2 id="what"><a class="header-anchor" href="#what" aria-hidden="true">#</a> What</h2>\n<p><em>Virtual DOM</em> 其实就是用JS对象去表示DOM元素。<br>\n{% asset_img vdom0.png %}<br>\n<img src="/vdom0.png" alt=""></p>\n<h2 id="why"><a class="header-anchor" href="#why" aria-hidden="true">#</a> Why</h2>\n<p>比如，我们要添加5个<code>&lt;li&gt;</code>：</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> appendElement =\n  <span class="hljs-function"><span class="hljs-params">type</span> =&gt;</span>\n    () =&gt;\n      <span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(type))\n\n<span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span>)).forEach(appendElement(<span class="hljs-string">\'li\'</span>))\n</code></pre>\n<p>上面每次生成一个<code>li</code>就插入，这样是很慢的。正确的做法应该是先生成5个<code>li</code>，然后再一次性把这个5个<code>li</code>插入。这个过程，我们就可以使用Virtual DOM来实现。</p>\n<h2 id="how"><a class="header-anchor" href="#how" aria-hidden="true">#</a> How</h2>\n<p>总共分4个步骤，如下图所示：<br>\n<img src="/vdom2.png" alt=""></p>\n<h3 id="vnode"><a class="header-anchor" href="#vnode" aria-hidden="true">#</a> VNode</h3>\n<p><code>VNode</code>这个函数是用JavaScript对象来表示DOM元素，比如：</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"item1"</span>&gt;</span>Call Me Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n</code></pre>\n<p>可以表示为:</p>\n<pre class="hljs"><code>{\n  <span class="hljs-attr">type</span>: <span class="hljs-string">\'li\'</span>,\n  <span class="hljs-attr">props</span>: {\n    <span class="hljs-attr">id</span>: <span class="hljs-string">\'item1\'</span>\n  },\n  <span class="hljs-attr">children</span>: [<span class="hljs-string">\'item1\'</span>]\n}\n</code></pre>\n<p>当然，<code>props</code>可以是数组，<code>children</code> 也可以放在<code>props</code>里面。</p>\n<h3 id="tohtml"><a class="header-anchor" href="#tohtml" aria-hidden="true">#</a> toHTML</h3>\n<p>这个就是把<code>VNode</code>转化成真正的DOM元素。</p>\n<pre class="hljs"><code><span class="hljs-comment">//</span>\n<span class="hljs-comment">// 大体分3步</span>\n<span class="hljs-comment">//</span>\n\n<span class="hljs-comment">// Step 1: createElement</span>\n<span class="hljs-keyword">const</span> node = <span class="hljs-built_in">document</span>.createElement(type)\n\n<span class="hljs-comment">// Step 2: set props</span>\n<span class="hljs-built_in">Object</span>.keys(props).forEach(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> {\n  node.setAttribute(prop, props[prop])\n})\n\n<span class="hljs-comment">// Step 3: set children</span>\nchildren.forEach(<span class="hljs-function"><span class="hljs-params">VChild</span> =&gt;</span> {\n  <span class="hljs-keyword">let</span> childNode\n\n  <span class="hljs-comment">// if text</span>\n  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> VChild === <span class="hljs-string">\'string\'</span>) {  <span class="hljs-comment">// #0</span>\n    childNode = <span class="hljs-built_in">document</span>.createTextNode(VChild)\n  } <span class="hljs-keyword">else</span> {\n    childNode = createNode(VChild)\n  }\n\n  node.appendChild(childNode)\n})\n\n<span class="hljs-keyword">return</span> node\n</code></pre>\n<p>在<code>#0</code>中，如果当前node是<code>string</code>的话，就表明是<code>text</code>。否则进行递归。</p>\n<h3 id="diff"><a class="header-anchor" href="#diff" aria-hidden="true">#</a> Diff</h3>\n<p><code>diff</code>需要把新的Virtual DOM和旧的进行比较，从而得到变化的地方。<br>\n这个过程最难的了。我没用实现React的diff算法，只是对同级元素进行了比较而已。</p>\n<p>主要有不同的4种情况:</p>\n<pre class="hljs"><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TEXT = <span class="hljs-string">\'TEXT\'</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> PROPS = <span class="hljs-string">\'PROPS\'</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> REPLACE = <span class="hljs-string">\'REPLACE\'</span>\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADD_CHILD = <span class="hljs-string">\'ADD_CHILD\'</span>\n</code></pre>\n<ul>\n<li><code>TEXT</code>: 替换旧的<code>text</code></li>\n<li><code>PROPS</code>: 表明<code>props</code>可能是增加，删除或修改</li>\n<li><code>REPLACE</code>: 替换旧的节点，包括删除的</li>\n<li><code>ADD_CHILD</code>: 表示需要增加child</li>\n</ul>\n<p>实现过程不讲述，详细看源代码(<a href="https://github.com/DrakeLeung/little-virtual-DOM/blob/master/src%2Fdiff.js">diff</a>)</p>\n<h3 id="patch"><a class="header-anchor" href="#patch" aria-hidden="true">#</a> Patch</h3>\n<p>这个过程把上个步骤得到的<code>diff</code>来给当前的DOM节点进行操作。这个过程就是我们优化DOM操作的地方。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> applyPatch = <span class="hljs-function">(<span class="hljs-params">node, currentPatch</span>) =&gt;</span> {\n  <span class="hljs-keyword">switch</span> (currentPatch.type) {\n    <span class="hljs-keyword">case</span> patchType.TEXT:\n      node.nodeValue = currentPatch.content\n      <span class="hljs-keyword">break</span>\n\n    <span class="hljs-keyword">case</span> patchType.PROPS:\n      setProps(node, currentPatch.props)\n      <span class="hljs-keyword">break</span>\n\n    <span class="hljs-keyword">case</span> patchType.REPLACE:\n      <span class="hljs-keyword">if</span> (isExist(currentPatch.node)) {\n        node.parentNode.replaceChild(toHTML(currentPatch.node), node)\n      } <span class="hljs-keyword">else</span> {\n        node.parentNode.removeChild(node)\n      }\n      <span class="hljs-keyword">break</span>\n\n    <span class="hljs-keyword">case</span> patchType.ADD_CHILD:\n      node.appendChild(toHTML(currentPatch.node))\n      <span class="hljs-keyword">break</span>\n\n    <span class="hljs-keyword">default</span>:\n  }\n}\n</code></pre>\n<h2 id="wrap-up"><a class="header-anchor" href="#wrap-up" aria-hidden="true">#</a> Wrap up</h2>\n<p>从实现这个简单的Virtual DOM，思路确实是打开了不少。</p>\n<ul>\n<li>用JavaScript对象来表示DOM元素。之前只会直接操作DOM，没有想到可以这样玩。</li>\n<li>怎么比较2棵树的不同？只需要比较同级的元素。虽然还是不会比较children</li>\n<li>复习了DOM的一些知识。</li>\n</ul>\n<p>所以<strong>多尝试</strong>不同的东西，思路会扩展不少~</p>\n<h2 id="resource"><a class="header-anchor" href="#resource" aria-hidden="true">#</a> Resource</h2>\n<ul>\n<li><a href="https://gist.github.com/sebmarkbage/fcb1b6ab493b0c77d589">React (Virtual) DOM Terminology</a></li>\n<li><a href="https://gcanti.github.io/2014/10/29/understanding-react-and-reimplementing-it-from-scratch-part-1.html">Understanding-react-and-reimplementing-it-from-scratch-part-1</a></li>\n<li><a href="https://www.zhihu.com/question/29504639">怎么更好地理解虚拟DOM</a></li>\n<li><a href="https://github.com/livoras/blog/issues/13">如何实现一个Virtual DOM算法</a></li>\n</ul>\n',frontmatter:"title: 迷之前端轮子 - 实现一个简单的 Virtual DOM\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-01-31 13:30:49\nforeword: 然而我并没有实现React Diff算法，因为不会= ="}},function(s,a){s.exports={attributes:{title:"为你的JavaScript代码写测试",author:"Drake Leung",tags:["JavaScript","test"],categories:[],date:"2016-02-17T19:32:51.000Z",foreword:"我会把测试JavaScript代码的功力一一传授给你。"},body:'<p>下面会讲解如何使用 karama, jasmine 以及 webpack，来为我们的 ES6 代码编写测试。<br>\n最后我写了一个可用的例子，请查看 <a href="https://github.com/DrakeLeung/ES2015-Starter-Kit/tree/master">ES2015-Starter-Kit</a> 。</p>\n<h2 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 艰难的抉择</h2>\n<blockquote>\n<p>首先，我们要写测试，用什么写？自己写一个函数，还是使用某个测试框架？</p>\n</blockquote>\n<p>看起来，后者可观一点。</p>\n<blockquote>\n<p>然后，有哪些测试框架可以选择？选哪个？</p>\n</blockquote>\n<p>于是，我们 google 之，找到 stackoverflow 的一个问题 <a href="http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd">JavaScript unit test tools for TDD</a>。</p>\n<p>看了问题回答，很纠结，太多了不知道选择哪个！最后，我决定选择 <a href="https://karma-runner.github.io/0.13/index.html">Karma</a>, <a href="https://github.com/jasmine/jasmine">Jasmine</a> 和 <a href="http://mochajs.org/">Mocha</a> 这三者之一，根据 Star 数量以及维护团队。</p>\n<p><img src="/mocha-jasmine-karma.png" alt=""></p>\n<blockquote>\n<p>那么，<em>Karma</em>, <em>Jasmine</em> 以及 <em>Mocha</em> 这三者之间哪个好，有什么不同？</p>\n</blockquote>\n<p>于是，我们不妨 google，找到了 <a href="http://stackoverflow.com/questions/24391462/what-are-the-differences-between-mocha-chai-karma-jasmine-should-js-etc-te">What are the differences between mocha, chai, karma, jasmine, should.js, etc. testing frameworks?</a> 这个问题。</p>\n<p>从回答中我们可以知道：<em>Karma</em> 只是一个 test runner，他负责提供 environment。而 <em>Jasmine</em> 和 <em>Mocha</em> 是编写测试脚本的框架。也就是说，我们可以选择 <em>Karma + Jasmine</em>或者 <em>Karma + Mocha</em>。我们不妨先选择前者~</p>\n<p>综上所述，<strong>我们要使用 <em>Karma + Jasmine</em> 组合来为我们的 JavaScript 代码写测试</strong>。</p>\n<h2 id="-2"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> 战斗的号角</h2>\n<p>接下来，我们根据文档（<a href="https://karma-runner.github.io/0.13/intro/installation.html">karma - Installation</a>, <a href="https://karma-runner.github.io/0.13/intro/configuration.html">karma - Configuration</a> 和 <a href="http://jasmine.github.io/2.0/introduction.html">Jasmine - introduction</a>），很容易就能搞起来。</p>\n<p>在这里我想说的是：当编写多个测试脚本的时候，你也许可以使用 <code>beforeEach</code> 和 <code>afterEach</code>。他们分别会在每个测试（spec）的之前和之后执行一次。</p>\n<h2 id="-3"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> 副本</h2>\n<p>最后还有一个问题是<em>如何结合 <a href="http://webpack.github.io/">Webpack</a></em> 来为我们的ES6代码编写测试。</p>\n<p>我不得不承认，这是一个很不错的问题。然而，我也通过google找到了答案。</p>\n<p>详细教程请看 <em>VueJS</em> 的 <a href="https://vuejs.github.io/vue-loader/workflow/testing.html">Testing</a> 文档。</p>\n<h2 id="-4"><a class="header-anchor" href="#-4" aria-hidden="true">#</a> 战斗的荣耀</h2>\n<p>你可以为你的仓库弄一个亮晶晶的 <a href="https://docs.travis-ci.com/user/status-images/">travis ci status image</a>：</p>\n<p><img src="https://travis-ci.org/travis-ci/travis-web.svg?branch=master" alt=""></p>\n<p>详细设置请查看 <a href="https://docs.travis-ci.com/user/getting-started/">travis docs</a>以及这篇教程 <a href="http://www.sitepoint.com/testing-javascript-jasmine-travis-karma/">Testing JavaScript with Jasmine, Travis, and Karma</a>。</p>\n<p>最后，如果还是不懂的话，可以查看我写的一个例子：<a href="https://github.com/DrakeLeung/ES2015-Starter-Kit/tree/master">ES2015-Starter-Kit</a></p>\n<h2 id="resources"><a class="header-anchor" href="#resources" aria-hidden="true">#</a> Resources</h2>\n<ul>\n<li><a href="http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd">JavaScript unit test tools for TDD</a></li>\n<li><a href="http://stackoverflow.com/questions/24391462/what-are-the-differences-between-mocha-chai-karma-jasmine-should-js-etc-te">What are the differences between mocha, chai, karma, jasmine, should.js, etc. testing frameworks?</a></li>\n<li><a href="https://vuejs.github.io/vue-loader/workflow/testing.html">vuejs - Testing</a></li>\n<li><a href="http://www.sitepoint.com/testing-javascript-jasmine-travis-karma/">Testing JavaScript with Jasmine, Travis, and Karma</a></li>\n</ul>\n',frontmatter:"title: 为你的JavaScript代码写测试\nauthor: Drake Leung\ntags: [JavaScript, test]\ncategories: []\ndate: 2016-02-17 19:32:51\nforeword: 我会把测试JavaScript代码的功力一一传授给你。"}},function(s,a){s.exports={attributes:{title:"从零开始编写一个Hexo主题",author:"Drake Leung",tags:["hexo","theme"],categories:[],date:"2016-01-27T22:23:29.000Z",foreword:"从零开始写一个主题的话，就意味着我们要了解Hexo的workflow。"},body:'<p>之前我也不会写，但是当我了解以下东西的时候，就可以从零开始写一个Hexo主题了。<br>\n<img src="/hexo2.png" alt=""></p>\n<ul>\n<li>NodeJS / NPM</li>\n<li>模板引擎(Template Engine)，比如EJS, Jade，Handlebars等等都可以</li>\n<li>HTML / CSS / JavaScript</li>\n<li>阅读Hexo的<a href="https://hexo.io/docs/">文档</a></li>\n<li>阅读Hexo默认主题<a href="https://github.com/hexojs/hexo-theme-landscape">landscape</a>的源码</li>\n</ul>\n<p>以上正是一名Web前端人员需要了解和掌握的东西。<br>\n<strong>不过，不会前端也不要紧，我告诉你以下的东西就足够了。</strong></p>\n<h2 id="nodejs-npm"><a class="header-anchor" href="#nodejs-npm" aria-hidden="true">#</a> NodeJS / NPM</h2>\n<p>首先，Hexo是由NodeJS来编写的。编写一个应用是需要第三方包(依赖/库)，这个就是我们的<code>package.json</code>文件的由来。这些package怎么下载的呢？答案就是通过<a href="https://www.npmjs.com/">NPM</a>(Node Package Manager)，然后他们都会安装在<code>node_modules/</code>这个文件夹里面。</p>\n<p>OK，这就是我们需要知道的NodeJS和NPM的知识。</p>\n<h2 id="hexoworkflow"><a class="header-anchor" href="#hexoworkflow" aria-hidden="true">#</a> Hexo的Workflow</h2>\n<p><strong>下面是重点。</strong></p>\n<p>Hexo会读取根目录下的<code>_config.yml</code>里面的<code>theme</code>属性, 从而采用对应的主题。而主题都是放在<code>themes/</code>目录下面的，然后你会发现他里面有个<code>landscape</code>的目录，这个就是默认主题啦。</p>\n<p>2<a href="/hexo1.png"></a></p>\n<p>接着，我们查看<code>themes/landscape/</code>目录，以及根据文档<a href="https://hexo.io/docs/themes.html">docs-themes</a>，我们很容易得出：一个主题其实由4部分组成。</p>\n<ul>\n<li><code>_config.yml</code>: 主题的配置文件</li>\n<li><code>source/</code>: 放我们的CSS文件以及图片</li>\n<li><code>layout/</code>: 模板文件</li>\n<li><code>scripts</code>: 放JavaScript文件，他们会自动加载</li>\n</ul>\n<p>然后，根据文档<a href="https://hexo.io/docs/templates.html">docs-templates</a>，不难得出：</p>\n<p>每次当我们在浏览器访问时，Hexo都会去解析<code>sources</code>目录下对应的模板文件。不同的URL对应不同的文件，所以才有了不同的页面。那么，我们怎么知道哪个URL对应哪个页面呢？(下面我们以<code>EJS</code>为例)</p>\n<p>无论URL是什么，Hexo先读取<code>layout.ejs</code>，然后里面的<a href="https://github.com/hexojs/hexo-theme-landscape/blob/master/layout%2Flayout.ejs">body</a>变量会替换成以下内容：(<em>Fallback</em>的意思是如果访问<code>/archives</code>时，我们的<code>archives.ejs</code>不存在的话，就会返回<code>index.ejs</code>)</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>Template</th>\n<th>Fallback</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>index.ejs</td>\n<td></td>\n</tr>\n<tr>\n<td>/archives</td>\n<td>archive.ejs</td>\n<td>index.ejs</td>\n</tr>\n<tr>\n<td>文章</td>\n<td>post.ejs</td>\n<td>index.ejs</td>\n</tr>\n</tbody>\n</table>\n<p>如下图所示:</p>\n<p>2<a href="/hexo.png"></a></p>\n<p>或者，可以先尝试一下没有<code>layout.ejs</code>的情况，因为比较简单。也就是，访问<code>/</code>，Hexo就返回<code>index.ejs</code>里面的东西给你。访问<code>/archives</code>就返回<code>archive.ejs</code>。</p>\n<h2 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 模板文件</h2>\n<p>那么，接下来就要编写我们的模板文件了。怎么写呢？<br>\n比如我的根目录想显示所有的文章？我们就要使用Hexo提供的<a href="https://hexo.io/docs/variables.html">变量</a>了。通过文档，我们可以得出<code>page.posts</code>这个变量就包含了所有的文章。</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">page.posts.each</span>(<span class="hljs-attr">function</span>(<span class="hljs-attr">post</span>){ %&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> post.title <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> post.content <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">%</span> }) %&gt;</span>\n</code></pre>\n<p>编写模板文件的时候，我们可能利用Hexo内置的一些<a href="https://hexo.io/docs/helpers.html">helper</a>来方便开发，比如分页使用<a href="https://hexo.io/docs/helpers.html#paginator">paginator</a>，路径处理使用<a href="https://hexo.io/docs/helpers.html#url_for">url_for</a>等。</p>\n<h2 id="-2"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> 样式</h2>\n<p>我们的CSS文件是放在<code>source</code>里面的，然后要怎么加载呢？这个时候，我们就需要在模板文件里面引入，比如我们的首页需要<code>app.css</code>，那么就在<code>index.ejs</code>里面引用就行了。如果每个页面都用到的话，就放在<code>layout.ejs</code>。</p>\n<pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">%-</span> <span class="hljs-attr">css</span>(\'<span class="hljs-attr">path</span>/<span class="hljs-attr">to</span>/<span class="hljs-attr">app</span>\') %&gt;</span>\n</code></pre>\n<p>当然，你也可以使用预处理器来写样式，比如Sass，Stylus等等。此时，你就要下载对应的package来解释成CSS。比如，我使用的是Sass，那么我就要<code>npm i --save hexo-renderer-sass</code>来把<code>.scss</code>文件解释成<code>.css</code>文件。</p>\n<h2 id="-3"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> 总结一下</h2>\n<p>如果遇到问题的话，查看Hexo默认主题<a href="https://github.com/hexojs/hexo-theme-landscape">landscape</a>的源码以及<a href="https://hexo.io/docs/">文档</a>就能解决了。<br>\n最后卖下广告，这是我写的主题：<a href="https://github.com/DrakeLeung/hexo-theme-again">hexo-theme-again</a>。</p>\n',frontmatter:"title: 从零开始编写一个Hexo主题\nauthor: Drake Leung\ntags: [hexo, theme]\ncategories: []\ndate: 2016-01-27 22:23:29\nforeword: 从零开始写一个主题的话，就意味着我们要了解Hexo的workflow。"}},function(s,a){s.exports={attributes:{title:"A Mathematical Expressions Parser",author:"Drake Leung",tags:[],categories:[],date:"2016-07-14T20:56:20.000Z",foreword:"计算四则运算表达式（含括号）的值。"},body:'<p>更多信息可查看 <a href="http://drakeleung.github.io/demo/slides/calc">SLIDE</a> 。</p>\n<h2 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 问题</h2>\n<p>我们的问题是这样子的：</p>\n<blockquote>\n<p>写一个 <code>calculate</code> 函数，他的参数是一个四则运算表达式字符串，返回结果则是该参数的求值。</p>\n</blockquote>\n<pre class="hljs"><code>calculate(<span class="hljs-string">\'1+2*3\'</span>) <span class="hljs-comment">// 7</span>\ncalculate(<span class="hljs-string">\'1*(2+3)*4)\'</span>) <span class="hljs-comment">// 20</span>\n\n<span class="hljs-comment">/*\n * 规则：\n * 1. 禁止 eval 及其类似物\n * 2. 禁止第三方库\n */</span>\n</code></pre>\n<h2 id="-2"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> 最简单的思路</h2>\n<p>假设字符串就是简单的 <code>1+2</code>，那么最简单的想法当然是：</p>\n<blockquote>\n<p>遍历该字符串，然后根据不同的操作符，计算其结果，重复之。</p>\n</blockquote>\n<p>然而，当字符串为 <code>1+2*3</code> 时，得到的结果是 <code>9</code> 而不是 <code>7</code> 。这是因为我们并没有考虑到<strong>操作符的优先级</strong>。并且，如果加上括号（<code>()</code>）的话，那么优先级就变得更加复杂。</p>\n<p>所以啊，我们就想：</p>\n<blockquote>\n<p>能不能没有优先级，按顺序就好啦，这样就简单多了。</p>\n</blockquote>\n<h2 id="-3"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> 逆波兰</h2>\n<p>只要努力 google 一下，我们就可以找到解决方法：</p>\n<blockquote>\n<p>使用「逆波兰表达式」。</p>\n</blockquote>\n<p>像我们平时使用的 <code>1 + 1</code> 就叫 <em>中缀表达式</em> 。而 <em>逆波兰</em>（<em>后缀表达式</em> ）则形如 <code>1 1 +</code>。</p>\n<p>现在，我们的问题就变成了:</p>\n<blockquote>\n<p>怎样把「中缀表达式」转换成「逆波兰表达式」？</p>\n</blockquote>\n<h2 id="tokenizer"><a class="header-anchor" href="#tokenizer" aria-hidden="true">#</a> Tokenizer</h2>\n<p>第一步，我们需要做的是：</p>\n<pre class="hljs"><code>// 假设我们的字符串形如：`1+2*3-4`\n// 那么就要把他转换成这样的一个数组：\n\n[\n  { <span class="hljs-built_in">type</span>: <span class="hljs-string">\'number\'</span>, value: 1 },\n  { <span class="hljs-built_in">type</span>: <span class="hljs-string">\'operator\'</span>, value: <span class="hljs-string">\'+\'</span> },\n  { <span class="hljs-built_in">type</span>: <span class="hljs-string">\'number\'</span>, value: 2 },\n  ....\n]\n</code></pre>\n<p><em>查看代码请点击 <a href="https://github.com/DrakeLeung/calc/blob/master/src/tokenizer.js">tokenizer</a> 。</em></p>\n<h2 id="torpn"><a class="header-anchor" href="#torpn" aria-hidden="true">#</a> toRPN</h2>\n<p>第二步，我们要把得到的 tokens 转换成 <em>逆波兰</em> 形式。这个时候需要用到 <a href="">shunting-yard</a> 算法。</p>\n<p><em>查看代码请点击 <a href="https://github.com/DrakeLeung/calc/blob/master/src/toRPN.js">toRPN</a> 。</em></p>\n<h2 id="calculator"><a class="header-anchor" href="#calculator" aria-hidden="true">#</a> Calculator</h2>\n<p>第三步，也是我们最后一步。</p>\n<p>我们需要把创建一个 <strong>操作数栈</strong> ，如果是操作数的话，push 到栈里去；如果是操作符的话，把栈里的前两个操作数 pop 出来，计算他们和该操作符的结果。然后把结果 push 到栈里。重复之，直到遍历完所有的 tokens 。</p>\n<p><em>查看代码请点击 <a href="https://github.com/DrakeLeung/calc/blob/master/src/index.js">calculator</a> 。</em></p>\n<h2 id="-4"><a class="header-anchor" href="#-4" aria-hidden="true">#</a> 抽象语法树</h2>\n<p>其实，我们还能做些更有趣的事情。比如，构建一棵 AST 。做法其实和第三步差不多。</p>\n<ol>\n<li>创建一个 <strong>操作数栈</strong></li>\n<li>遍历 tokens</li>\n<li>如果 token 为操作数，则 push 到栈里。</li>\n<li>如果 token 为操作符，则把 栈里的两个操作数 pop 出来，与该操作符形成 AST 的一个节点，接着把该节点 push 到栈里去</li>\n<li>重复之，直到遍历完 tokens</li>\n</ol>\n<p>有了 AST 之后，如果我们对其分别进行前序，中序，后序遍历的话，就可以得到 <strong>前缀表达式</strong> ，<strong>中缀表达式</strong> ，以及 <strong>后缀表达式</strong> 。</p>\n<p><em>查看代码请点击 <a href="https://github.com/DrakeLeung/calc/blob/master/src/parser.js">parser</a> 。</em></p>\n<h2 id="-5"><a class="header-anchor" href="#-5" aria-hidden="true">#</a> 项目源码</h2>\n<p>所有代码可查看：https://github.com/DrakeLeung/calc</p>\n',
frontmatter:"title: A Mathematical Expressions Parser\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-07-14 20:56:20\nforeword: 计算四则运算表达式（含括号）的值。"}},function(s,a){s.exports={attributes:{title:"冒泡排序可视化",author:"Drake Leung",tags:[],categories:[],date:"2016-03-27T23:01:37.000Z",foreword:"实现一个冒泡排序的可视化。"},body:'<p>TL;DR: <a href="http://plnkr.co/edit/je2wWv?p=preview">在线例子和相关代码请查看这里。</a></p>\n<p>本文章的目的来源于知乎的一个问题：<a href="https://www.zhihu.com/question/41642706">我用js写了一个冒泡排序法，怎么用html和css把排序过程展现出来？</a></p>\n<p>下面讲一下要解决的几个问题和 tips。</p>\n<h2 id="swap-animation"><a class="header-anchor" href="#swap-animation" aria-hidden="true">#</a> Swap Animation</h2>\n<p>我觉得「两个柱状图的交换动画」是整个应用的难点。</p>\n<p>看了 <a href="http://visualgo.net/sorting.html">visual.net</a>，他的实现是利用 CSS3 的 <code>transform</code> 函数里面的 <code>translate</code>。这似乎是不错的想法，但是我发现要用 JS 获取 <code>translate</code> 对应的值的话，<a href="http://stackoverflow.com/questions/21912684/how-to-get-value-of-translatex-and-translatey">有点麻烦</a>。</p>\n<p>接着，我又看了一个答案的<a href="http://meowtec.github.io/demo/sort-v/">实现</a>。他的方法是利用 CSS 中的 <code>left</code>。而 <code>left</code> 的值是相对于设定了 <code>position: relative</code> 的 <em>parent</em>。</p>\n<p>我不是很懂上面的方法。但是我想到了另一个方法：<strong><code>left</code> 是相对于他本身</strong>。也就是设置他本身为 <code>position: relative</code> 而不是他的 <em>parent</em>。</p>\n<pre class="hljs"><code><span class="hljs-selector-class">.bar</span> {\n  <span class="hljs-attribute">position</span>: relative;\n  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-comment">/* must set, or not transition when value in falsy */</span>\n  <span class="hljs-comment">/*transition: left 1s;*/</span>\n}\n</code></pre>\n<p>我之所以设置 <code>left</code> 为 <code>0</code>，是因为我们要用 CSS3 的 <code>transition</code> 实现渐变的效果。</p>\n<p>然后，每次交换的时候，我们只需要把他当前的 <code>left</code> 加/减 柱形图的宽度。没错，这就是这种方法的「缺点」之一，我们需要用 JS 写死柱形图的宽度。</p>\n<pre class="hljs"><code>swap () {\n  <span class="hljs-comment">// ...</span>\n\n  <span class="hljs-keyword">const</span> getLeft = <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>\n    <span class="hljs-built_in">parseInt</span>(item.style.left.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-2</span>)) || <span class="hljs-number">0</span> <span class="hljs-comment">// rm \'px\'</span>\n\n  item1.style.left = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.barWidth + getLeft(item1)}</span>px`</span>\n  item2.style.left = <span class="hljs-string">`<span class="hljs-subst">${-<span class="hljs-keyword">this</span>.barWidth + getLeft(item2)}</span>px`</span>\n}\n</code></pre>\n<p>在交换的时候，我们要先找到对应的 DOM 元素，也就是上面代码中的 <code>item</code> 和 <code>item2</code>。</p>\n<p>怎么找？（假设我们排序的是一堆数字）<br>\n一开始我想到了两种方法。</p>\n<p>第一种是，根据数字，找到具有对用数字的 DOM 元素，就像这样：</p>\n<pre class="hljs"><code>swap (value1, value2) {\n  <span class="hljs-keyword">const</span> item1 = <span class="hljs-keyword">this</span>.el.querySelector(<span class="hljs-string">`[data-value=\'<span class="hljs-subst">${value1}</span>\']`</span>)\n}\n</code></pre>\n<p>但这种方法是行不通的。为什么？<br>\n因为当有多个数字相同的时候，我们找到的 DOM 元素不一定是我们想要交换的。因为 <code>querySelector</code> 返回的总是第一个匹配的元素。</p>\n<p>那我们在 <code>item1</code> 后面才开始找 <code>item2</code> 行不行？使用 CSS3 的 <code>~</code> 选择器。比如这样：</p>\n<pre class="hljs"><code>swap (value1, value2) {\n  <span class="hljs-keyword">const</span> item1 = <span class="hljs-keyword">this</span>.el.querySelector(<span class="hljs-string">`[data-value=\'<span class="hljs-subst">${value1}</span>\']`</span>)\n  <span class="hljs-keyword">const</span> item2 = <span class="hljs-keyword">this</span>.el.querySelector(<span class="hljs-string">`[data-value=\'<span class="hljs-subst">${value2}</span>\'] ~ data-value=\'<span class="hljs-subst">${value2}</span>\']`</span>)\n}\n</code></pre>\n<p>这种方法有时可以，有时是不可以的。为什么？<br>\n因为我们的 DOM 结构根本就没有变化，只是用 CSS 的 <code>left</code> 在视觉上改变了位置而已。</p>\n<p>因此，我们的第二种方法当然就是在交换的时候，不仅改变 <code>left</code> 的值，而且交换 DOM 的位置。</p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swapDOM</span>(<span class="hljs-params">element1, element2</span>) </span>{\n  element1.parentNode.insertBefore(element2, element1);\n}\n</code></pre>\n<p>但是，这种方法还是行不通的。因为 <code>insertBefore</code> 会把 <code>element2</code> 从 DOM 中删掉。这样的话，就没有了「交换」的渐变效果。</p>\n<p>果然，我们还是不能 DOM 元素。那么只能返回第一种方法。</p>\n<p>这个时候我突然想到了 React 中循环的时候需要写上 <code>key</code> 属性。然后。。。然后只要把 <code>key</code> 和 数字绑定在一起，查找数字对应的 DOM 元素只需要使用 <code>key</code> 就行。</p>\n<pre class="hljs"><code><span class="hljs-comment">// data = [64, 39, 78, 36]</span>\n<span class="hljs-keyword">this</span>.items = data.map(<span class="hljs-function">(<span class="hljs-params">d, i</span>) =&gt;</span> ({<span class="hljs-attr">key</span>: <span class="hljs-string">`key-<span class="hljs-subst">${i}</span>`</span>, <span class="hljs-attr">value</span>: d}))\n\nswap (key1, key2) {\n  <span class="hljs-keyword">const</span> item1 = <span class="hljs-keyword">this</span>.el.querySelector(<span class="hljs-string">`[data-key=\'<span class="hljs-subst">${key1}</span>\']`</span>)\n}\n</code></pre>\n<p>终于搞定了「交换」动画了，不知道有没有更好的实现方法呢？</p>\n<h2 id="swap-animation-finish-in-a-flash"><a class="header-anchor" href="#swap-animation-finish-in-a-flash" aria-hidden="true">#</a> Swap Animation Finish in a Flash</h2>\n<p>假设我们的排序算法是这样的：</p>\n<pre class="hljs"><code>sort () {\n  <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">this</span>.items\n\n  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; items.length - i - <span class="hljs-number">1</span>; j++) {\n      <span class="hljs-keyword">const</span> item1 = items[j]\n      <span class="hljs-keyword">const</span> item2 = items[j + <span class="hljs-number">1</span>]\n\n      <span class="hljs-keyword">if</span> (less(item2.value, item1.value)) {\n        swap(j, j + <span class="hljs-number">1</span>, items)\n      }\n    }\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items\n}\n</code></pre>\n<p>注意到，我们的 <code>swap</code> 函数是在 <code>for</code> 循环里面调用的，这是没错的。</p>\n<p>然而我们的「交换」动画就跑完了，根本没有渐变的效果，我们想要的是等到前一个交换动画完成后，下一个才发生。为什么会这样？因为我们的两个 <code>for</code> 是瞬间就可以跑完的= =</p>\n<p>怎么解决这个问题呢？<code>setInterval</code>？好像会把排序算法的逻辑扰乱。<br>\n突然，我想到了 jQuery 好像有个动画队列的东西。</p>\n<p>也就是说，<strong>我们可以把所有的动画先放在一个队列里面。然后再一个一个地出队，一个一个地调用。</strong></p>\n<pre class="hljs"><code><span class="hljs-keyword">for</span> () {\n  <span class="hljs-keyword">for</span> () {\n    <span class="hljs-keyword">if</span> (less(item2.value, item1.value)) {\n      <span class="hljs-keyword">this</span>.queue.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.swap(item1.key, item2.key))\n    }\n  }\n}\n\nplay () {\n  <span class="hljs-keyword">const</span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.queue.length === <span class="hljs-number">0</span>) {\n      clearInterval(intervalId)\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-keyword">const</span> swap = <span class="hljs-keyword">this</span>.queue.shift()\n      swap()\n    }\n  }, <span class="hljs-number">2</span> * <span class="hljs-number">1000</span>)\n}\n</code></pre>\n<p>看了知乎上的答案，这个问题还有其他实现的方法。<strong>总的来说，就是如何解决异步编程问题。</strong></p>\n<h2 id="tips"><a class="header-anchor" href="#tips" aria-hidden="true">#</a> Tips</h2>\n<p>可以利用 CSS 的 伪元素<code>::before</code> 以及 <code>attr</code> 函数，来实现柱形图上显示对应的数字。</p>\n<pre class="hljs"><code><span class="hljs-selector-class">.bar</span><span class="hljs-selector-pseudo">::before</span> {\n  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(data-value);\n  <span class="hljs-attribute">position</span>: absolute;\n  <span class="hljs-attribute">top</span>: -<span class="hljs-number">16px</span>;\n  <span class="hljs-attribute">color</span>: <span class="hljs-number">#233</span>;\n}\n</code></pre>\n<h2 id="continue"><a class="header-anchor" href="#continue" aria-hidden="true">#</a> Continue</h2>\n<p>我们的代码还可以继续优化，比如接口如何设计，使得可以扩展于其他的排序算法。还有用户体验,比如，排序前中后状态的颜色都设为不同，等等。</p>\n',frontmatter:"title: 冒泡排序可视化\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-03-27 23:01:37\nforeword: 实现一个冒泡排序的可视化。"}},function(s,a){s.exports={attributes:{title:"fetch api 用起来！",author:"Drake Leung",tags:[],categories:[],date:"2016-08-15T00:16:49.000Z",foreword:"超级简单的 fetch 。"},body:'<p>今天把 vue-resource 砍掉，换成了 <a href="http://devdocs.io/dom/globalfetch/fetch">fetch</a> 。<br>\n然而，代码体积在 build 之后只是少了 2K =。=</p>\n<p>为了兼容旧浏览器，我们将使用这个的 polyfill : <a href="https://github.com/github/fetch">whatwg-fetch</a> ；如果还想兼容 node 的话：<a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a> 。安装请看对应的文档。</p>\n<h2 id="fetch-api"><a class="header-anchor" href="#fetch-api" aria-hidden="true">#</a> fetch api</h2>\n<p>最简单的 <code>fetch</code> 接口是下面这样子的：</p>\n<pre class="hljs"><code><span class="hljs-comment">/**\n * fetch\n *\n * @param {string} url \n * @param {object} config\n * @return {promise}\n*/</span>\nfetch(<span class="hljs-string">\'/api/heros/, {\n  method: \'</span>GET<span class="hljs-string">\',\n})\n</span></code></pre>\n<p>更详情的请看文档啦：<a href="http://devdocs.io/dom/globalfetch/fetch">globalfetch.fetch</a> 。</p>\n<h2 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 常用例子</h2>\n<p>看这个：<a href="https://github.com/github/fetch#usage">fetch - usage</a> 。</p>\n<h2 id="-2"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> 可能遇到的坑</h2>\n<ul>\n<li>不发送 cookie</li>\n<li>不 catch 404 或者 500 等 HTTP 错误状态码。</li>\n</ul>\n<p>解决办法可以查看 <a href="https://github.com/github/fetch#caveats">fetch - caveats</a> 。</p>\n<h2 id="-3"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> 拦截器</h2>\n<p>如果我们想在每个请求之前或者之后进行某些操作的话，就需要用到拦截器啦。<br>\n下面我们用到的是拦截器是 <a href="https://github.com/werk85/fetch-intercept">fetch-intercept</a> 。可以去看看源码，只有 80 行不到，超级优美的代码。</p>\n<p>如果我们想每个请求都发送 cookie 的话，就必须要设置 <a href="https://github.com/github/fetch#sending-cookies">credentials</a> 。但是我不想每个请求都设置一遍，这时我们就可以用到拦截器啦。</p>\n<pre class="hljs"><code><span class="hljs-keyword">import</span> fetchIntercept\n\nfetchIntercept.register({\n  request(url, config = {}) {\n    <span class="hljs-keyword">const</span> myConf = {\n      <span class="hljs-attr">credentials</span>: <span class="hljs-string">\'include\'</span>, <span class="hljs-comment">// send cookie</span>\n    }\n\n    <span class="hljs-keyword">return</span> [\n      url,\n      defaults(config, myConf), <span class="hljs-comment">// merge 2 objects</span>\n    ]\n  },\n})\n</code></pre>\n<p>同样地，我们可以简化请求的 URL 。比如说，</p>\n<ul>\n<li><code>/rootHost/api/heros/</code></li>\n<li><code>/rootHost/api/coolBoys/</code></li>\n</ul>\n<p>这个时候我们就可以把 <code>/rootHost/api/</code> 提取出来。</p>\n<pre class="hljs"><code>fetchIntercept.register({\n  request(url, config = {}) {\n    <span class="hljs-keyword">return</span> [\n     <span class="hljs-string">`<span class="hljs-subst">${apiHost()}</span>/api/<span class="hljs-subst">${url}</span>,\n     config,\n    ]\n  },\n})\n\nfetch(\'heros/\')\nfetch(\'coolBoys/\')\n</span></code></pre>\n<p>类似地，我们也可以用在 GET 请求时带的 query string 。</p>\n<p>另外，因为 fetch 不会 catch 404 等错误，所以需要我们手动设置。</p>\n<pre class="hljs"><code>fetchIntercept.register({\n  response(res) {\n    <span class="hljs-keyword">if</span> (res.status &gt;= <span class="hljs-number">200</span> &amp;&amp; res.status &lt; <span class="hljs-number">300</span>) <span class="hljs-keyword">return</span> res\n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(res.statusText)\n  },\n})\n</code></pre>\n<p>可以看到使用了拦截器之后，我们的代码就变得优美多了 :)</p>\n<h2 id="see-also"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>\n<ul>\n<li><a href="https://github.com/github/fetch">whatwg-fetch</a></li>\n<li><a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a></li>\n<li><a href="https://github.com/werk85/fetch-intercept">fetch-intercept</a></li>\n</ul>\n',frontmatter:"title: fetch api 用起来！\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-08-15 00:16:49\nforeword: 超级简单的 fetch 。"}},function(s,a){s.exports={attributes:{title:"google chrome Devtools Overview",author:"Drake Leung",tags:["google chrome","devtools"],categories:["Tools"],date:"2015-07-16T01:29:29.000Z",foreword:"学习google chrome DevTools的４个部分. 分别为Console, Elements, Network以及Sources."},body:'<p>官方文档: <a href="https://developer.chrome.com/devtools">Chrome DevTools</a></p>\n<h2 id="console"><a class="header-anchor" href="#console" aria-hidden="true">#</a> Console</h2>\n<h3 id="basic-operation"><a class="header-anchor" href="#basic-operation" aria-hidden="true">#</a> Basic Operation</h3>\n<ul>\n<li>打开: <code>Ctrl + Shift + J</code></li>\n<li><code>Shift + Enter</code>可以换行，当你要写多行代码的时候。</li>\n<li>删除console history: <code>Ctrl + L</code></li>\n<li>drawer: 假设你在其他tab里面，想要看到<code>Console</code>tab的东西，就可以可以按<code>Esc</code>来显示drawer<br>\n<img src="http://ww3.sinaimg.cn/large/7f85b91egw1eu3hckqtijj20rg0c8dj9.jpg" alt=""></li>\n</ul>\n<h3 id="console-api"><a class="header-anchor" href="#console-api" aria-hidden="true">#</a> Console API</h3>\n<p>在DevTools里面定义了一个全局对象<code>console</code>。他有许多有用的API</p>\n<ul>\n<li>\n<p>打印日志: <code>console.log(arg1, arg2)</code>。<code>.log()</code>可以有多个参数，<code>console.log(\'loved?\', true)</code></p>\n</li>\n<li>\n<p>打印错误日志: <code>console.error()</code>以及打印警告日志: <code>console.warn()</code></p>\n</li>\n<li>\n<p>用CSS来style你的日志: <code>%c</code>作为指示，第2个参数写CSS。</p>\n<pre class="hljs"><code><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"%cThis will be formatted with large, blue text"</span>, <span class="hljs-string">"color: blue; font-size: x-large"</span>);\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'%cBlue! %cRed!\'</span>, <span class="hljs-string">\'color: blue;\'</span>, <span class="hljs-string">\'color: red;\'</span>);\n</code></pre>\n<p>这样就可以在console里面写一些漂亮的彩蛋了。</p>\n</li>\n<li>\n<p>把DOM元素格式化为JavaScript对象: <code>console.dir()</code>, 如<code>console.dir(document)</code></p>\n</li>\n<li>\n<p>测量时间: 传一个<code>string</code>作为给<code>.time()</code>作为开始，这个string就是time marker。结束<br>\n的话就<code>timeEnd(string)</code>。string和前面的一样。</p>\n<pre class="hljs"><code><span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Array initialize"</span>);\n    <span class="hljs-keyword">var</span> array= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>);\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {\n        array[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();\n    };\n<span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Array initialize"</span>);\n</code></pre>\n</li>\n</ul>\n<h3 id="command-line-api"><a class="header-anchor" href="#command-line-api" aria-hidden="true">#</a> Command Line API</h3>\n<ul>\n<li>\n<p>自动补全: 比如输入<code>doc</code>就会有提示。如果是单个提示时，可以使用<code>tab</code>来补全。而多个时，按<code>↑</code><br>\n和<code>↓</code>进行选择，然后按<code>→</code>补全当前。</p>\n</li>\n<li>\n<p>选择元素: <code>$()</code>是<code>querySelector()</code>的简写，而<code>$$()</code>是<code>querySelectorAll()</code></p>\n</li>\n<li>\n<p><code>$0~$4</code>保存了你在<strong>Element tab</strong>里面选择过的5个元素。</p>\n</li>\n</ul>\n<h2 id="network"><a class="header-anchor" href="#network" aria-hidden="true">#</a> Network</h2>\n<p><img src="http://ww2.sinaimg.cn/large/7f85b91egw1eu3ifwyikzj20ov08i77o.jpg" alt=""></p>\n<ul>\n<li>可以检查你的文件路径有没有写对。</li>\n<li>直播下载网易云音乐的歌曲。</li>\n</ul>\n<h2 id="elements"><a class="header-anchor" href="#elements" aria-hidden="true">#</a> Elements</h2>\n<p>对着你想要审查的元素，鼠标右击 -&gt; Inspect Element。或者<code>Ctrl + Shift + C</code>.<br>\n可以随便修改删除一些标签啊，比如去掉广告浮窗，或者这样啊，<br>\n<img src="http://ww1.sinaimg.cn/large/7f85b91egw1eu3g2gwgaij20dh0a4aaz.jpg" alt=""></p>\n<ul>\n<li>color picker: 按<code>shift</code> + click可以切换颜色的表示方法。</li>\n<li>adding new CSS rules</li>\n<li>toggle element state<br>\n<img src="http://ww4.sinaimg.cn/large/7f85b91egw1eu3gx9r0ppj20dc01r0sp.jpg" alt=""></li>\n</ul>\n<h2 id="sources"><a class="header-anchor" href="#sources" aria-hidden="true">#</a> Sources</h2>\n<p>Sources tab可以查看你的文件。<br>\n<img src="http://ww3.sinaimg.cn/large/7f85b91egw1eu392veow8j20uk0rm0vv.jpg" alt=""></p>\n<h3 id="debugging-javascript-with-breakpoints"><a class="header-anchor" href="#debugging-javascript-with-breakpoints" aria-hidden="true">#</a> debugging JavaScript with breakpoints</h3>\n<ol>\n<li>\n<p>按<code>Ctrl + P</code>就可以搜索我们的文件，此时会调到<strong>Sources tab</strong>。接着<code>Ctrl + Shift + O</code>搜索函数名, <code>Ctrl + G</code>可以跳到任意一行，或者<code>Ctrl + Shift + F</code>在所有文件中搜索文本。</p>\n<p><img src="http://ww2.sinaimg.cn/large/7f85b91egw1eu3fzown0oj20lo08bwgi.jpg" alt=""></p>\n</li>\n<li>\n<p>单击<strong>line gutter</strong>就可以在该行设置一个breakpoint。然后你可以在右边的面板的<strong>BreakPoints</strong><br>\n找到所有设置过的breakpoint</p>\n<p><img src="http://ww2.sinaimg.cn/large/7f85b91egw1eu39fv8s2gj20le0cd400.jpg" alt=""></p>\n</li>\n<li>\n<p>Control</p>\n<ul>\n<li><strong>Continue</strong>: 继续执行，直到下一个breakpoint</li>\n<li><strong>Step over</strong>: 下一行</li>\n<li><strong>Step into</strong>: 跳进函数里面去</li>\n<li><strong>Step over</strong>: 从函数里面跳出来</li>\n<li><strong>Toggle breakpoints</strong>: 激活/不激活breakpoints</li>\n</ul>\n</li>\n<li>\n<p>查看<br>\n然后，我们就可以在<strong>Scope Vraibles</strong>那里查看你想要的变量。如果你有一直想看的变量，<br>\n可以把他添加到<strong>Watch Expressions</strong></p>\n</li>\n</ol>\n<h3 id="saving-changes-with-workspaces"><a class="header-anchor" href="#saving-changes-with-workspaces" aria-hidden="true">#</a> Saving changes with workspaces</h3>\n<p>把文件夹添加到workspace之后，你在DevTools上面修改的东西就会同步到实际的文件<br>\n当中去。<br>\n<img src="http://ww2.sinaimg.cn/large/7f85b91egw1eu3d1b12tsj20ve0bl77g.jpg" alt=""></p>\n<p>这样一来，DevTools就相当于一个编辑器了。</p>\n',frontmatter:"title: google chrome Devtools Overview\nauthor: Drake Leung\ntags: [google chrome, devtools]\ncategories: [Tools]\ndate: 2015-07-16 01:29:29\nforeword: 学习google chrome DevTools的４个部分. 分别为Console, Elements, Network以及Sources."}},function(s,a){s.exports={attributes:{title:"实现一个简单的 AMD 模块加载器",author:"Drake Leung",tags:[],categories:[],date:"2016-02-11T23:32:53.000Z",foreword:"讲一下实现过程中遇到的问题。"},body:'<p>(完整代码请看<a href="https://github.com/DrakeLeung/tiny-module-loader">GitHub - tiny module loader</a>)</p>\n<h2 id="what"><a class="header-anchor" href="#what" aria-hidden="true">#</a> What</h2>\n<p>不了解JavaScript模块化的请看<a href="http://drakeleung.github.io/blog/2016/02/07/JavaScript-Module-A-Beginner-Guide/">「译」JavaScript Modules Part1: A Beginner Guide</a>。</p>\n<p>简单来说，AMD规范定义了模块加载的方式是异步的而不是同步。</p>\n<p>接着，语法是这样子的：<code>define</code>函数去请求依赖。其中，第一个参数是依赖的模块数组，第二个参数是函数。当依赖都加载完毕之后，就会作为参数，传进这个函数里面。</p>\n<h2 id="why"><a class="header-anchor" href="#why" aria-hidden="true">#</a> Why</h2>\n<p>为了探究 AMD 模块加载器的原理，我们不妨尝试着从零开始实现他。</p>\n<p>我们只实现一个 <code>define</code> 函数。其他后面再慢慢完善。</p>\n<h2 id="how"><a class="header-anchor" href="#how" aria-hidden="true">#</a> How</h2>\n<p>主要分成3部分：下载依赖，执行依赖并导出，读取依赖并执行回调(递归地)。</p>\n<h3 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 下载依赖</h3>\n<p>接受一个依赖模块的URL，然后用Ajax请求。这时会返回包含文件内容的字符串。</p>\n<p>这个很简单，只是用<em>Promise</em>简便一点而已。</p>\n<pre class="hljs"><code><span class="hljs-comment">// getModule.js</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fetchDeps = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span>\n  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n    <span class="hljs-keyword">let</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest()\n\n    req.addEventListener(<span class="hljs-string">\'load\'</span>, () =&gt; {\n      <span class="hljs-keyword">if</span> (req.status &lt; <span class="hljs-number">400</span>) resolve(req.responseText)\n      <span class="hljs-keyword">else</span> reject(req.status)\n    }, <span class="hljs-literal">false</span>)\n\n    req.addEventListener(<span class="hljs-string">\'error\'</span>, () =&gt; {\n      reject(req.status)\n    }, <span class="hljs-literal">false</span>)\n\n    req.open(<span class="hljs-string">\'GET\'</span>, name, <span class="hljs-literal">true</span>)\n    req.send(<span class="hljs-literal">null</span>)\n  })\n</code></pre>\n<h3 id="-2"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> 执行依赖</h3>\n<p>由于请求依赖返回的是一个字符串。但我们想要的是把这个字符串当作 JavaScript 代码来执行，解决方法有2种，分别是 <code>eval()</code> 和 <code>new Function()</code>。我们采取后者。</p>\n<p>还有一种方法应该可以：动态创建 <code>&lt;script&gt;</code> 标签。</p>\n<pre class="hljs"><code><span class="hljs-comment">// getModule.js</span>\n\n<span class="hljs-keyword">let</span> currentModule = <span class="hljs-literal">null</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getModule = <span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> {\n  <span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span> = {\n    <span class="hljs-attr">exports</span>: <span class="hljs-literal">null</span>,\n    <span class="hljs-attr">exported</span>: <span class="hljs-literal">false</span>,\n    <span class="hljs-attr">onExport</span>: []\n  }\n\n  currentModule = <span class="hljs-built_in">module</span>\n  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> (<span class="hljs-string">\'\'</span>, code)() <span class="hljs-comment">// work with eval(), as well</span>\n\n  <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>\n}\n\n<span class="hljs-keyword">export</span> {\n  currentModule,\n  getModule\n}\n</code></pre>\n<p>这里有一个我觉得是最难的问题：由于 <code>new Function()</code> 执行的时候，是不返回东西的（其实我并不知道 <code>new Function</code> 的工作原理)。</p>\n<p>所以，这个时候依赖虽然是请求回来并执行了，但是他依然还没有导出(<code>exports</code>)。所以，返回的 <code>module</code> 对象的 <code>exports</code> 是 <code>null</code>的。并且，我们还用了一个变量 <code>currentModule</code> 还存储当前的变量。</p>\n<h3 id="-3"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> 导出依赖并执行回调函数</h3>\n<pre class="hljs"><code><span class="hljs-comment">// myDefine.js</span>\n\n<span class="hljs-comment">// import {</span>\n<span class="hljs-comment">//   currentModule,</span>\n<span class="hljs-comment">//   getModule</span>\n<span class="hljs-comment">// } from \'./getModule\'</span>\n<span class="hljs-comment">//</span>\n<span class="hljs-comment">// import {fetchDeps} from \'./fetchDeps\'</span>\n<span class="hljs-comment">// import {whenDepsExported} from \'./whenDepsExported\'</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> define = <span class="hljs-function">(<span class="hljs-params">deps, callback</span>) =&gt;</span> {\n  <span class="hljs-keyword">let</span> myModule = currentModule <span class="hljs-comment">// #0</span>\n  <span class="hljs-keyword">const</span> getDeps = deps.map(fetchDeps)\n\n  <span class="hljs-built_in">Promise</span>.all(getDeps)\n    .then(<span class="hljs-function"><span class="hljs-params">codes</span> =&gt;</span> {\n      <span class="hljs-keyword">const</span> modules = codes.map(getModule)\n\n      <span class="hljs-comment">// #1</span>\n      modules.forEach(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span>\n        !m.exported &amp;&amp; m.onExport.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>\n          whenDepsExported(callback, modules, myModule)\n        )\n      )\n\n      whenDepsExported(callback, modules, myModule) <span class="hljs-comment">// #2</span>\n    })\n}\n</code></pre>\n<p><code>#0</code> 我们把 <code>currentModule</code> 赋给一个局部变量，这样使得每个 <code>define</code> 都有自己的「模块」。这个也是困惑了我好久的一步。我也似懂非懂，因为反正已经 work 起来了= =</p>\n<p>这个时候问题就来了。因为我们需要递归地加载依赖，那么，肯定是加载最外面的依赖，然后才到里面。如果没有了 <code>#1</code>，那么就会执行 <code>#2</code>，这样就会导致和想我们想要的相反，即先执行最里面的依赖的回调，再执行外面的。</p>\n<p>因此，我们把最里面的模块先放到一个数组里面，然后当他的依赖执行完之后，再去执行他的回调，这时他的回调的参数才有值。</p>\n<pre class="hljs"><code><span class="hljs-comment">// whenDepsExported.js</span>\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> whenDepsExported = <span class="hljs-function">(<span class="hljs-params">cb, deps, myModule</span>) =&gt;</span> {\n  <span class="hljs-keyword">if</span> (!deps.every(<span class="hljs-function"><span class="hljs-params">dep</span> =&gt;</span> dep.exported)) <span class="hljs-keyword">return</span>\n\n  <span class="hljs-comment">// params for \'callback of define\'</span>\n  <span class="hljs-keyword">let</span> args = deps.map(<span class="hljs-function"><span class="hljs-params">dep</span> =&gt;</span> dep.exports)\n  <span class="hljs-keyword">let</span> exports = cb.apply(<span class="hljs-literal">null</span>, args)\n\n  <span class="hljs-comment">// #0</span>\n  <span class="hljs-keyword">if</span> (myModule) {\n    myModule.exports = exports\n    myModule.exported = <span class="hljs-literal">true</span>\n    myModule.onExport.forEach(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f())\n  }\n\n  <span class="hljs-keyword">return</span> exports\n}\n</code></pre>\n<p><code>#0</code> 中，我们导出了依赖，并且执行了 <code>onExport</code> 的回调函数。</p>\n<h2 id="wrap-up"><a class="header-anchor" href="#wrap-up" aria-hidden="true">#</a> Wrap up</h2>\n<p>原理看起来不是很难，但自己实现一遍还是挺难的。</p>\n<p>不过 AMD，CommonJS 这些规范倒是改善了 JavaScript 模块系统，使得 JavaScript 能够在规模较大的项目中更加容易开发，以及维护。</p>\n<p>(完整代码请看<a href="https://github.com/DrakeLeung/tiny-module-loader">GitHub - tiny module loader</a>)</p>\n<h2 id="resources"><a class="header-anchor" href="#resources" aria-hidden="true">#</a> Resources</h2>\n<ul>\n<li><a href="http://eloquentjavascript.net/10_modules.html">eloquent javascript - modules</a></li>\n</ul>\n',frontmatter:"title: 实现一个简单的 AMD 模块加载器\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-02-11 23:32:53\nforeword: 讲一下实现过程中遇到的问题。"}},function(s,a){s.exports={attributes:{title:"实现一个 flickr like 布局",author:"Drake Leung",tags:[],categories:[],date:"2016-04-29T23:27:28.000Z",foreword:"flickr 的图片都是不改变原来的横纵比，且每一行的高度都是差不多。"},body:'<p>Flickr 团队最近开源了他们图片布局的项目 - <a href="https://github.com/flickr/justified-layout/blob/master/README.md">Flickr\'s Justified Layout</a> 。那么，通过阅读其源代码后，我实现了一个简单版 - <a href="https://github.com/DrakeLeung/demo/blob/gh-pages/toys%2Fjjjustify%2FREADME.md">jjjustify</a>。点击这里可以查看在线 <a href="http://frontend-addiction.github.io/Baidu-IFE/stage03/task43/flickr/index.html">demo</a> 。</p>\n<h2 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 核心算法</h2>\n<p>整个应用的核心是：<strong>如何确定一行中的图片数量并且保持横纵比</strong> 。</p>\n<p>首先，我们需要知道一个知识：</p>\n<blockquote>\n<p>假设我们一行的高度为 300 ，宽度为 1200 。那么在这一行中的所有图片的横纵比之和就小于等于这一行的横纵比，也就是 4:1 。</p>\n</blockquote>\n<p>我们这里不用数学来证明。但是不妨想象，当一行中的图片都收缩或者拉伸之后，是可以占满整行的，这时，就相当于这一行。所以，当前行所有图片的横纵比之和要<strong>小于等于</strong>初始设定的整行的横纵比。</p>\n<p><img src="/flickr1.png" alt=""></p>\n<p>但是，为了增加灵活性，我们可以<strong>设定一个容忍度</strong>。他的取值范围是 <code>[0, 1]</code> 。如果当前行所有图片的横纵比之和介于（初始设定的整行的横纵比 * (1 +- 容忍度）的话，我们都能接受（容忍），在当前行插入该图片。</p>\n<p>举个例子：初始设定的整行的横纵比（<code>targetRowAspectRatio</code>）为 4 ，我们的容忍度（<code>tolerance</code>）为 <code>0.25</code> 。所以，只要图片们的横纵比之和介于 <code>targetRowAspectRatio * (1 - tolerance)</code> 和 <code>targetRowAspectRatio * (1 + tolerance)</code> 就让他们在当前行。</p>\n<p><img src="/flickr2.png" alt=""></p>\n<p>如果大于容忍后的横纵比的话，<strong>为了更加精确，我们可以比较绝对值</strong>。看看插入图片后的横纵比之和 - targetRowAspectRatio 的绝对值小，还是插入图片前的横纵比之和 - targetRowAspectRatio 的绝对值小。哪个小就采用哪种方案。</p>\n<p>插入新图片前的绝对值为 <code>3.5</code> :<br>\n<img src="/flickr3.png" alt=""></p>\n<p>插入后的绝对值为 <code>0.5</code> ，小于 <code>3.5</code> ，所以我们选择在当前行插入该图片。<br>\n<img src="/flickr4.png" alt=""></p>\n<p>如果小于容忍后的横纵比的话，假设还没插完图片，就继续插。如果已经插完了图片，这里我们可以选择是否铺满一行，还是就让他这样。这个时候我们的高度就是原始设定的高度。</p>\n<p>详细代码实现请参考 <a href="https://github.com/DrakeLeung/demo/blob/gh-pages/toys%2Fjjjustify%2Frrrow.js">rrrow.js</a> 的 <code>addItem()</code> 方法。</p>\n',frontmatter:"title: 实现一个 flickr like 布局\nauthor: Drake Leung\ntags: []\ncategories: []\ndate: 2016-04-29 23:27:28\nforeword: flickr 的图片都是不改变原来的横纵比，且每一行的高度都是差不多。"}},function(s,a){s.exports={attributes:{title:"let us learn RxJS",date:"2016-09-21"},body:'<p>这是一篇 RxJS 初学者教程。</p>\n<h2 id="what-is-rxjs"><a class="header-anchor" href="#what-is-rxjs" aria-hidden="true">#</a> What Is RxJS</h2>\n<p>通过<strong>阅读<a href="http://reactivex.io/rxjs/manual/overview.html">官方文档</a></strong>，不难得出：RxJS 可以很好<strong>解决异步和事件组合的问题</strong>。</p>\n<p>这个时候我就有疑问了，异步问题不是用 Promise ( async/await ) 就好了吗?<br>\n至于事件，配合框架 ( React, Vue, Angular2 等 ) 的话不也很容易解决吗？</p>\n<p>不管怎样, 让我们先看个 Hello World 吧。( 我要看 <a href="http://jsbin.com/suguho/edit?js,output">DEMO</a> )</p>\n<h3 id="rxs-hello-world"><a class="header-anchor" href="#rxs-hello-world" aria-hidden="true">#</a> Rx\'s Hello World</h3>\n<pre class="hljs"><code><span class="hljs-comment">// auto-complete</span>\n<span class="hljs-keyword">const</span> Observable = Rx.Observable\n<span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'input\'</span>)\n\n<span class="hljs-keyword">const</span> search$ = Observable.fromEvent(input, <span class="hljs-string">\'input\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.value)\n  .filter(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value.length &gt;= <span class="hljs-number">1</span>)\n  .throttleTime(<span class="hljs-number">100</span>)\n  .distinctUntilChanged()\n  .switchMap(<span class="hljs-function"><span class="hljs-params">term</span> =&gt;</span> Observable.fromPromise(wikiIt(term)))\n  .subscribe(\n    <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> renderSearchResult(x),\n    err =&gt; <span class="hljs-built_in">console</span>.error(err)\n  )\n</code></pre>\n<p>上面的代码做了以下事情：</p>\n<ul>\n<li>监听 <code>input</code> 元素的 <code>input</code> 事件</li>\n<li>一旦发生，把事件对象 <code>e</code> 映射成 <code>input</code> 元素的值</li>\n<li>接着过滤掉值长度小于 <code>1</code> 的</li>\n<li>并且还设置了一个 <code>throttle</code> ( 节流器 )，两次输入间隔不超过 <code>100</code> 毫秒为有效输入</li>\n<li>如果该值和过去最新的值相等的话，忽略他</li>\n<li>最后，拿到值便调用 Wikipedia 的一个 API</li>\n<li>最后的最后，需要 <code>subscribe</code> 才能拿到 API 返回的数据</li>\n</ul>\n<p>是不是看起来就觉得很 cool ，好想学！<br>\n短短几行代码就完成了一个 auto-complete 组件。</p>\n<h2 id="how-it-works"><a class="header-anchor" href="#how-it-works" aria-hidden="true">#</a> How It Works</h2>\n<p>那上面的代码是什么意思？<br>\nRxJS 到底是如何工作的？如何解决异步组合问题的？</p>\n<h3 id="observable"><a class="header-anchor" href="#observable" aria-hidden="true">#</a> Observable</h3>\n<p>Rx 提供了一种叫 <strong>Observable</strong> 的数据类型，兼容 ECMAScript 的 <a href="https://github.com/zenparsing/es-observable">Observable Spec Proposal</a> 草案标准。他是 Rx 最核心的数据类型，结合了 <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer Pattern</a>，<a href="https://en.wikipedia.org/wiki/Iterator_pattern">Iterator Pattern</a> 。</p>\n<p>那到底什么是 Observable ？</p>\n<blockquote>\n<p>Observable 其实就是一个<strong>异步的数组</strong>。<em>( ---&gt; <a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877#.1q1q2mwgq">2 minute introduction to rx</a> )</em></p>\n</blockquote>\n<p>不妨想像一下，<strong>数组 + 时间轴 = Observable</strong> 。</p>\n<p>数组元素的值是未来某个时间点 <em>emit</em> ( 产生 ) 的，但是我们并不关心这个时间点，因为利用了「观察者模式」<em>subscribe</em> ( 订阅 ) 了这个数组，只要他 <em>emit</em> 了值，就会自动 <em>push</em> 给我们。</p>\n<p>我们再用图来表示一下的话：</p>\n<pre class="hljs"><code>--a---b-c--d-----e--|--&gt;  \n</code></pre>\n<p>这种图叫做 <a href="http://reactivex.io/rxjs/manual/overview.html#marble-diagrams">marble diagram</a> 。<br>\n我们可以把 ASCII 的 marble 图转成 SVG 的：<a href="https://jsbin.com/vumepol/1/edit?js,output">ASCII -&gt; SVG</a> 。</p>\n<p><code>-</code> 表示时间轴，<code>a</code> ~ <code>e</code> 表示 emit 的值，<code>|</code> 则表示这个 stream 已经结束了。<br>\n比方说，<code>click</code> 事件用上图来表示：<code>a</code> 表示第 1 次点击，<code>b</code> 表示第 2 次点击，如此类推。</p>\n<p>如果你觉得 Observable 这个名字不够形象不够 cool 的话，你可把他叫做 <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams">stream</a> ，因为他的 marble 图就像 steam 一样。所以啊，下面我都会把 <em>Observable</em> 称作 <em>stream</em> 。</p>\n<h3 id="operators"><a class="header-anchor" href="#operators" aria-hidden="true">#</a> Operators</h3>\n<p>那么，我们怎么对 stream 进行操作呢？怎么把多个 stream 组合在一起呢？</p>\n<p>我们前面不是说了「 Observable 其实就是<em>异步数组</em>」吗？在 JavaScript 里的数组不是有很多内置的方法吗？比如 <code>map</code>, <code>filter</code>, <code>reduce</code> 等等。类似地，Observable 也有自己的方法，也就是所谓的 <a href="http://reactivex.io/rxjs/manual/overview.html#operators">operator</a> 。比如上面 <a href="#rx-s-hello-world">Rx\'s Hello World</a> 例子中的 <code>map</code>, <code>filter</code>, <code>throttleTime</code>, <code>distinctUntilChanged</code> 等等很多很有用的 operator 。</p>\n<p>面对 RxJS 那么多 operator ，我们要怎么学习呢？很简单：</p>\n<blockquote>\n<p><a href="http://reactivex.io/rxjs/manual/overview.html#categories-of-operators">分类别</a> + <a href="http://reactivex.io/rxjs/manual/overview.html#marble-diagrams">画 marble 图</a> + <a href="https://www.learnrxjs.io/operators/">看例子</a> + <a href="http://reactivex.io/rxjs/manual/overview.html#choose-an-operator">选</a></p>\n</blockquote>\n<p>现在，就让我们画出上面 Hello World 例子的 marble 图。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> search$ = Observable.fromEvent(input, <span class="hljs-string">\'input\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.value)\n  .filter(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value.length &gt;= <span class="hljs-number">1</span>)\n  .throttleTime(<span class="hljs-number">100</span>)\n  .distinctUntilChanged()\n  .switchMap(<span class="hljs-function"><span class="hljs-params">term</span> =&gt;</span> Observable.fromPromise(wikiIt(term)))\n  .subscribe(\n    <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> renderSearchResult(x),\n    err =&gt; <span class="hljs-built_in">console</span>.error(err)\n  )\n</code></pre>\n<p>假设输入了 5 次，每次输入的值一次为：<code>a</code>, <code>ab</code>, <code>c</code>, <code>d</code>, <code>c</code> ，并且第 3 次输入的 <code>c</code> 和第 4 次的 <code>d</code> 的时间间隔少于 <code>100ms</code> ：</p>\n<pre class="hljs"><code>---i--i---i-i-----i---|--&gt; (input)\n        map\n\n---a--a---c-d-----c---|--&gt;\n      b\n        filter\n\n---a--a---c-d-----c---|--&gt;\n      b\n      throttleTime\n\n---a--a---c-------c---|--&gt;\n      b\n  distinctUntilChanged\n\n---a--a---c----------|--&gt;\n      b\n    switchMap\n\n---x--y---z----------|--&gt;  \n</code></pre>\n<p>如果我告诉你学习 <strong>RxJS 的捷径是「学会看和画 marble 图」</strong>，你信还是不信？</p>\n<h2 id="learn-by-doing"><a class="header-anchor" href="#learn-by-doing" aria-hidden="true">#</a> Learn By Doing</h2>\n<p>现在，就让我们结合上面的知识，来实现一个简单的 canvas 画板。</p>\n<p>根据 canvas 的 <a href="http://devdocs.io/dom/canvasrenderingcontext2d/moveto">API</a> ，我们需要知道两个点的坐标，这样才能画出一条线。</p>\n<h3 id="step-1"><a class="header-anchor" href="#step-1" aria-hidden="true">#</a> Step 1</h3>\n<p><em>( 我要看 <a href="https://jsfiddle.net/DrakeLeung/a7h4wwcy/">DEMO</a> )</em></p>\n<p>那么，现在我们需要做的是<strong>创建</strong>一个关于鼠标移动的 stream 。于是，我们<strong>去文档找对应的 operator 类别</strong>，也就是 <a href="http://jsbin.com/gakosun/edit?js,console,output">Creation Operators</a> ，然后得到  <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent">fromEvent</a> 。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'canvas\'</span>)\n\n<span class="hljs-keyword">const</span> move$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mousemove\'</span>)\n</code></pre>\n<p>对应的 marble 图：</p>\n<pre class="hljs"><code>--m1---m1-m2--m3----m4---|--&gt;  (mousemove)\n</code></pre>\n<p>接着，我们需要拿到每次鼠标移动时的坐标。也就是说：需要<strong>变换</strong> stream 。<br>\n对应类别的 operator 文档：<a href="http://reactivex.io/rxjs/manual/overview.html#transformation-operators">Transformation Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map">map</a> 。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> move$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mousemove\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> ({ <span class="hljs-attr">x</span>: e.offsetX, <span class="hljs-attr">y</span>: e.offsetX }))\n</code></pre>\n<p>此时的 marble 图：</p>\n<pre class="hljs"><code>--m1---m2-m3--m4----m5---|--&gt;  (mousemove)\n        map\n--x1---x2-x3--x4----x5---|--&gt;  (点坐标)\n</code></pre>\n<p>然后，怎么拿到两个点的坐标呢？我们需要再<strong>变换</strong>一下 stream 。<br>\n对应类别的 operator 文档：<a href="http://reactivex.io/rxjs/manual/overview.html#transformation-operators">Transformation Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-bufferCount">bufferCount</a> 。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> move$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mousemove\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> ({ <span class="hljs-attr">x</span>: e.offsetX, <span class="hljs-attr">y</span>: e.offsetY }))\n  .bufferCount(<span class="hljs-number">2</span>)\n</code></pre>\n<p>marble 图：</p>\n<pre class="hljs"><code>--m1---m2-m3--m4----m5---|--&gt;  (mousemove)\n        map\n\n--x1---x2-x3--x4----x5---|--&gt;  (点坐标)\n      bufferCount(2)\n\n-------x1-----x3----x5---|---&gt; (两点坐标)\n       x2     x4\n</code></pre>\n<p>然而你会发现，此时画出来的<a href="https://jsfiddle.net/DrakeLeung/a7h4wwcy/">线段是不连续的</a>。为什么？我也不知道！！<br>\n那就让我们看看别人是怎么写的吧：<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/examples/canvaspaint/canvaspaint.js">canvas paint</a> 。</p>\n<h3 id="step-2"><a class="header-anchor" href="#step-2" aria-hidden="true">#</a> Step 2</h3>\n<p><em>( 先让我要看看 <a href="https://jsfiddle.net/DrakeLeung/vj368qy7/1/">DEMO</a> )</em></p>\n<p>换了一种思路，并没有<strong>变换</strong> stream ，而是把两个 stream <strong>组合</strong>在一起。<br>\n查看文档  <a href="http://reactivex.io/rxjs/manual/overview.html#combination-operators">Combination Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-zip">zip</a> 以及 <a href="http://reactivex.io/rxjs/manual/overview.html#filtering-operators">Filtering Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-skip">skip</a></p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> move$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mousemove\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> ({ <span class="hljs-attr">x</span>: e.offsetX, <span class="hljs-attr">y</span>: e.offsetY }))\n\n<span class="hljs-keyword">const</span> diff$ = move$\n  .zip(move$.skip(<span class="hljs-number">1</span>), (first, sec) =&gt; ([ first, sec ]))\n</code></pre>\n<p>此时的 marble 图：</p>\n<pre class="hljs"><code>--x1---x2-x3--x4----x5---|--&gt;  (move$)\n        skip(1)\n-------x2-x3--x4----x5---|--&gt;  \n\n\n\n--x1---x2-x3--x4----x5---|--&gt;  (move$)\n-------x2-x3--x4----x5---|--&gt;  \n        zip\n\n-------x1-x2--x3----x4---|--&gt;  (diff$)\n       x2 x3  x4    x5\n</code></pre>\n<p>这样一来，<code>diff$</code> emit 的值就依次为 <code>(x1, x2)</code>, <code>(x2, x3)</code>，<code>(x3, x4)</code> ……<br>\n现在，鼠标移动的时候，就可以<a href="https://jsfiddle.net/DrakeLeung/vj368qy7/1/">画出美丽的线条</a>。</p>\n<h3 id="step-3"><a class="header-anchor" href="#step-3" aria-hidden="true">#</a> Step 3</h3>\n<p><em>( 我想看 <a href="https://jsfiddle.net/DrakeLeung/vj368qy7/2/">DEMO</a> )</em></p>\n<p>就在此时我恍然大悟，终于知道前面用 <code>bufferCount</code> 为什么不行了。我们不妨来比较一下：</p>\n<pre class="hljs"><code>-------x1-----x3----x5---|---&gt; (bufferCount)\n       x2     x4\n\n-------x1-x2--x3----x4---|--&gt;  (diff$)\n       x2 x3  x4    x5\n</code></pre>\n<p><code>bufferCount</code> emit 的值依次为：<code>(x1, x2)</code>， <code>(x3, x4)</code> …… <code>x2</code> 和 <code>x3</code> 之间是有间隔的。这就是为什么线段会不连续的原因。</p>\n<p>然后看 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-bufferCount">bufferCount</a> 文档的话，你会发现<strong>可以使用 <code>bufferCount(2, 1)</code> 实现同样的效果</strong>。这样的话，我们就不需要使用 <code>zip</code> 来组合两个 stream 了。Cool ~</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> move$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mousemove\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> ({ <span class="hljs-attr">x</span>: e.offsetX, <span class="hljs-attr">y</span>: e.offsetX }))\n  .bufferCount(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)\n</code></pre>\n<p>此时的 marble 图：</p>\n<pre class="hljs"><code>--m1---m2-m3--m4----m5---|--&gt;  (mousemove)\n        map\n\n--x1---x2-x3--x4----x5---|--&gt;  (点坐标)\n      bufferCount(2, 1)\n\n-------x1-x2--x3----x4---|---&gt; (两点坐标)\n       x2 x3  x4    x5\n</code></pre>\n<h2 id="step-4"><a class="header-anchor" href="#step-4" aria-hidden="true">#</a> Step 4</h2>\n<p><em>( 我就要看 <a href="https://jsfiddle.net/DrakeLeung/vj368qy7/3/">DEMO</a> )</em></p>\n<p>接下来，我们想实现「只有鼠标按下时，才能画画，否则不能」。<br>\n首先我们需要<strong>创建</strong>两个关于鼠标动作的 stream 。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> down$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mousedown\'</span>)\n<span class="hljs-keyword">const</span> up$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mouseup\'</span>)\n</code></pre>\n<p>当鼠标按下的时候，我们需要把他<strong>变换</strong>成鼠标移动的 stream ，直到鼠标放开。<br>\n查看文档  <a href="http://reactivex.io/rxjs/manual/overview.html#transformation-operators">Transformation Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMapTo">switchMapTo</a> 。</p>\n<pre class="hljs"><code>down$.switchMapTo(move$)\n</code></pre>\n<p>此时的 marble 图：</p>\n<pre class="hljs"><code>--d---d-d-----d---d--|--&gt;  (mousedown)\n      switchMapTo\n\n--m---m-m-----m---m--|--&gt; \n</code></pre>\n<p>此时，鼠标放开了我们还能<a href="https://jsfiddle.net/DrakeLeung/vj368qy7/3/">继续画画</a>，这显然不是我们想要的。这个时候我们很容易会使用 <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-takeUntil">takeUntil</a> 这个 operator ，但是这是不对的，因为他会把 <em>stream</em> complete 掉。</p>\n<p>还是让我们看看别人是怎么写的吧：<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/examples/canvaspaint/canvaspaint.js">canvas paint</a> 。</p>\n<h3 id="step-5"><a class="header-anchor" href="#step-5" aria-hidden="true">#</a> Step 5</h3>\n<p><em>( 我只想看 <a href="https://jsfiddle.net/DrakeLeung/vj368qy7/4/">DEMO</a> )</em></p>\n<p>思路是这个样子的：</p>\n<p>把 <code>up$</code> 和 <code>down$</code> <strong>组合</strong>成一个新的 stream ，但为了分辨他们，我们需要先把他们<strong>变换</strong>成新的 stream 。<br>\n查看文档 <a href="http://reactivex.io/rxjs/manual/overview.html#combination-operators">Combination Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-merge">merge</a> 。<br>\n<a href="http://reactivex.io/rxjs/manual/overview.html#transformation-operators">Transformation Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-map">map</a> 。</p>\n<pre class="hljs"><code><span class="hljs-keyword">const</span> down$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mousedown\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">\'down\'</span>)\n<span class="hljs-keyword">const</span> up$ = Rx.Observable.fromEvent(canvas, <span class="hljs-string">\'mouseup\'</span>)\n  .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">\'up\'</span>)\n\n<span class="hljs-keyword">const</span> upAndDown$ = up$.merge(down$)\n</code></pre>\n<p>再来看看他们的 marble 图：</p>\n<pre class="hljs"><code>--d--d-d----d--d---|--&gt;  (down$)\n----u---u-u------u-|--&gt;  (up$)\n      merge\n\n--d-ud-du-u-d--d-u-|--&gt;  (upAndDown$)\n</code></pre>\n<p>此时，我们再<strong>变换</strong> <code>upAndDown$</code> 。如果是 <code>down</code> 的话，则变换成 <code>move$</code> ，否则变换成一个空的 stream 。<br>\n查看文档 <a href="http://reactivex.io/rxjs/manual/overview.html#categories-of-operators">Creation Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-empty">empty</a> 。<br>\n<a href="http://reactivex.io/rxjs/manual/overview.html#transformation-operators">Transformation Operators</a> ---&gt; <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap">switchMap</a> 。</p>\n<pre class="hljs"><code>upAndDown$\n  .switchMap(<span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span>\n    action === <span class="hljs-string">\'down\'</span> ? move$ : Rx.Observable.empty()\n  )\n</code></pre>\n<p>你要的 marble 图：</p>\n<pre class="hljs"><code>--d-ud-du-u-d--d-u-|--&gt;  (upAndDown$)\n    switchMap\n\n--m-em-me-e-m--m-e-|--&gt;\n</code></pre>\n<p>其实这个 canvas 画板不用 RxJS 实现也不会很难。但是当我们把他扩展成一个「你画我猜」之后，用 RxJS 处理异步就会变得简单起来。比如，添加新的工具栏 ( 调色板，撤销…… ) ，即时通信 ( 同步画板，聊天 ) ……</p>\n<p>另外，如果你想边学习 RxJS 边实现一些小东西的话：</p>\n<ul>\n<li><a href="https://github.com/staltz/rxjs-training">staltz - rxjs training</a></li>\n<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">GitHub - Who to Follow</a></li>\n<li><a href="https://github.com/Reactive-Extensions/RxJS/tree/master/examples">RxJS 4.x Example</a></li>\n<li><a href="https://github.com/JayKan/RxJS-Playground">RxJs Playground</a></li>\n<li><a href="https://github.com/channikhabra/yarr">Yet Another RSS Reader</a></li>\n<li><a href="https://medium.com/front-end-hacking/rx-ifying-a-chat-room-built-with-reactjs-and-socket-io-459156b7d7ab#.bw55b1xqj">rx-ifying a chat room built with reactjs and socket io</a></li>\n<li><a href="https://github.com/hdjirdeh/angular2-hn">angular2-hacknews</a></li>\n</ul>\n<h2 id="production"><a class="header-anchor" href="#production" aria-hidden="true">#</a> Production</h2>\n<p>怎么把 RxJS 应用到实际生产的 web 应用当中呢？<br>\n怎么结合到当前流行的框架当中呢？</p>\n<h3 id="vue"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h3>\n<p>你可以直接在各种 <a href="http://vuejs.org/api/#Options-Lifecycle-Hooks">Lifecycle Hooks</a> 中使用 RxJS 。</p>\n<p>比如 <code>created</code> 的时候初始化一个 Observable ，<code>beforeDestroy</code> 时就取消订阅 Observable 。( 查看<a href="http://jsbin.com/cafodu/edit?html,js,output"> DEMO </a> )</p>\n<pre class="hljs"><code><span class="hljs-keyword">new</span> Vue({\n  <span class="hljs-attr">el</span>: <span class="hljs-string">\'#app\'</span>,\n  <span class="hljs-attr">data</span>: {\n    <span class="hljs-attr">time</span>: <span class="hljs-string">\'\'</span>\n  },\n  \n  created () {\n    <span class="hljs-keyword">this</span>.timer$ = Rx.Observable.interval(<span class="hljs-number">1000</span>)\n      .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())\n      .map(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> moment(d).format(<span class="hljs-string">\'hh:mm:ss\'</span>))\n      .subscribe(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.time = t\n      })\n  },\n  \n  beforeDestroy () {\n    <span class="hljs-keyword">this</span>.timer$.unsubscribe()\n  }\n})\n</code></pre>\n<p>其实已经有对应的插件 <a href="https://github.com/vuejs/vue-rx">vue-rx</a> 帮我们干了上面的 dirty work 。他会分别在 <code>init</code> 和 <code>beforeDestroy</code> 的时候自动地订阅和取消订阅 Observable ：<a href="https://github.com/vuejs/vue-rx/blob/master/vue-rx.js#L22-L51">Vue.js + RxJS binding mixin in 20 lines</a> 。</p>\n<p>因此，我们可以直接把一个 Observable 写到 <code>data</code> 中：<a href="https://github.com/vuejs/vue-rx/blob/master/example/example.html#L26-L65">vue-rx/example.html</a> 。</p>\n<h3 id="react"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h3>\n<p>类似地，React 也可以在他组件的 <a href="https://facebook.github.io/react/docs/component-specs.html#lifecycle-methods">lifecycle hooks</a> 里调用 RxJS：<a href="https://github.com/belfz/fully-reactive-react-example">fully-reactive-react</a> 。<br>\n也可以使用 <a href="https://github.com/christianalfoni/rxjs-react-component">rxjs-react-component</a> 把 Observable 绑定到 <code>state</code> 。<br>\n如果你结合 Redux 的话，可以使用这个 <a href="https://github.com/redux-observable/redux-observable">redux-oservable</a> 。</p>\n<h3 id="angular2"><a class="header-anchor" href="#angular2" aria-hidden="true">#</a> Angular2</h3>\n<p>RxJS 已经是 Angular2 的标配，不多说。<br>\n更多可查看对应的文档 <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#!#rxjs">Angular2 - Server Communication</a> 。</p>\n<p>更多关于 RxJS 的集成：<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/examples/community.md">RxJS community</a> 。</p>\n<h2 id="you-might-not-need-rxjs"><a class="header-anchor" href="#you-might-not-need-rxjs" aria-hidden="true">#</a> You Might Not Need RxJS</h2>\n<p>根据 <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/designguidelines/readme.md#21-use-rxjs-for-orchestrating-asynchronous-and-event-based-computations">When to Use RxJS</a> ，我们可以知道 RxJS 的适用场景是：</p>\n<ul>\n<li>多个复杂的异步或者事件组合在一起</li>\n<li>处理多个数据序列（有一定顺序）</li>\n</ul>\n<p>我觉得，如果你没被异步问题困扰的话，那就不要使用 RxJS 吧，因为 Promise 已经能够解决简单的异步问题了。至于 Promise 和 Observable 的区别是什么呢？可以看 <a href="https://www.google.com.hk/search?q=promise+vs+observable">Promise VS Observable</a> 。</p>\n<p>讲真，<strong>RxJS 在实际生产中适用的业务场景有哪些</strong>？哪些场景是需要多个异步组合在一起的？游戏吗？即时通信？还有一些特殊的业务。是我的写的业务太少了吗？还是我平时写业务的时候，为写而写，没有把他们抽象起来。</p>\n<p>另外，我倒是对 Teambition 关于 RxJS 的思路有点感兴趣：<em><a href="https://github.com/xufei/blog/issues/36#issuecomment-246662343">xufei - 数据的关联计算 -&gt; Brooooooklyn 评论</a></em> &amp; <a href="https://github.com/xufei/blog/issues/37">xufei - 对当前单页应用的技术栈思考</a>。</p>\n<h2 id="summary"><a class="header-anchor" href="#summary" aria-hidden="true">#</a> Summary</h2>\n<ul>\n<li>RxJS 是用来解决异步和事件组合问题</li>\n<li>Observable = <a href="https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877#.1q1q2mwgq">异步数组</a> = 数组 + 时间轴 = stream</li>\n<li>Operators =  <a href="http://reactivex.io/rxjs/manual/overview.html#categories-of-operators">分类别</a> + <a href="http://reactivex.io/rxjs/manual/overview.html#marble-diagrams">画 marble 图</a> + <a href="https://www.learnrxjs.io/operators/">看例子</a> + <a href="http://reactivex.io/rxjs/manual/overview.html#choose-an-operator">选</a></li>\n<li><strong>更多更详细的更准确的请看<a href="http://reactivex.io/rxjs/">文档</a>！</strong></li>\n</ul>\n<p>让我们一起来学习 RxJS 吧!</p>\n',
frontmatter:"title: 'let us learn RxJS'\ndate: '2016-09-21'"}},function(s,a){s.exports={attributes:{title:"my 2016 review",date:"2017-01-02"},body:'<p>我总觉得，「总结」 这种东西是成功人士才会干的事情。像我这种混子，活着都已经觉得很艰难了（我只是为了表达我最近看了「银魂」）。</p>\n<p>没写过总结的人一般在写了第一段之后是不知道怎么继续写下去的。当遇到这种情况的时候我都会用「总-分-总」结构。</p>\n<p>写总结这种东西，对于记性不好的人来说简直难啊。如果有人帮我记录就好了，最好总结也帮我写！因此，我决定以后多发朋友圈或者微博。</p>\n<h2 id="2016"><a class="header-anchor" href="#2016" aria-hidden="true">#</a> 2016</h2>\n<p>我本来打算使用「时间倒叙法」来总结我的2016年，或者分成「工作」，「学校」和「生活」三部曲。如果使用前者的话就会写成流水帐，后者的话我又不太喜欢。那究竟是选择前者还是后者呢？先不讨论这个吧，你们觉得标题就使用单纯的数字「2016」真的好吗，总觉得怪怪的，要不要加上一些形容词呢？比如「2016好棒棒」，或者「&lt;2016&gt; 💩 &lt;/2016&gt;」。</p>\n<p>2016发生了许多在我意料之外的事情，有好有不好的，为此我做出了许多艰难的决定，比如写这篇总结。总的来说还是好的，不过会有坑也说不定，毕竟2017还会发生许多在我意料之外的事情。</p>\n<p>我觉得再这样写下去的话会很难，所以还是采用三部曲来凑字数吧。</p>\n<h3 id=""><a class="header-anchor" href="#" aria-hidden="true">#</a> 工作</h3>\n<p>7-12月去了魔都实习。</p>\n<p>我想说我学到了很多东西，但是我却没有好好总结，幸好平时要求写周报；<br>\n我想说我没有做出什么特别值得骄傲的事情，但是一些微小的工作还是有的。<br>\n我想说❤️感谢这些日子以来的照顾以及下午茶❤️ !!<br>\n怎样，这排比句可以吧？</p>\n<p>不得不说，这几个月的实习我过得很愉快。下面是不是应该要说一下实习感言：感谢xxx ，让我xxx ；感谢xxx ，没有你们，我xxx ；最后感谢一下自己。</p>\n<h3 id="-2"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> 生活</h3>\n<p>第一次面试，第一次坐飞机，第一次租房子，没了。吃了很多没吃过的东西。小龙虾，还有但是我记不得了。就两句话，字数应该还不够吧，再写写咯。</p>\n<p>第一次面试很紧张，面试官给我的可乐我喝了但是忘记带走了。🐍</p>\n<p>第一次坐飞机也很紧张，我怕迟到赶不上啊。面试约的是下午 2 点，所以我飞机要早上8点，所以我只好在机场附近住一晚。我觉得下面应该要有张✈️蓝天白云✈️的照片会很合适。</p>\n<p>第一次租房子好麻烦，这里我省略了10000字。</p>\n<p>还是喜欢广东的天气，够暖和，我现在只穿一件短袖，你敢信？终于快要写完了，嘻嘻。</p>\n<h2 id="2017"><a class="header-anchor" href="#2017" aria-hidden="true">#</a> 2017</h2>\n<p>这里毫无疑问是要陈述一下 2017 年的目标有哪些，那我不鸡婆咯。</p>\n<ul>\n<li>每周给家里打一次电话至少</li>\n<li>超过 100 star 的项目</li>\n<li>每个月一篇 blog 至少</li>\n<li>多运动</li>\n<li>长胖</li>\n<li>旅游</li>\n<li>追回ex</li>\n</ul>\n<p>我感觉都很难啊。打电话回家不知道说什么。渣渣怎么能写出超过 100 star 的项目。太冷或者太热都不想运动。长胖感觉很难啊，关键是吸收。旅游没什么好玩的而且很累人。但是我最想做的事还是追回我的 ex 。好难啊，这就是为什么我不想写总结的原因。列举一些很难完成的事情，因为最初的心里预期是很难完成的，所以到时候没完成也可以找借口。但想一想，如果总结能写出来的话，应该没有什么坏处吧。</p>\n<p>还是让我们一起来看「神探夏洛克-第四季」吧，想想就激动不已～😌</p>\n',frontmatter:"title: 'my 2016 review'\ndate: '2017-01-02'"}},function(s,a,n){"use strict";function e(s){return s&&s.__esModule?s:{default:s}}var l=n(9),t=e(l),p=n(64),o=e(p),c=n(63),r=e(c);new t.default({el:"#app",router:r.default,render:function(s){return s(o.default)}})}],[216]);
//# sourceMappingURL=app.56ff7b599358718bbf02.js.map